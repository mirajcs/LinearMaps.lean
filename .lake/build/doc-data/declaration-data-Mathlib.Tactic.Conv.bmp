{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.«command#simpOnly_=&gt;__»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">«command#simpOnly_=&gt;__»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"* `#simp => e` runs `simp` on the expression `e` and displays the resulting expression after\n  simplification.\n* `#simp only [lems] => e` runs `simp only [lems]` on `e`.\n* The `=>` is optional, so `#simp e` and `#simp only [lems] e` have the same behavior.\n  It is mostly useful for disambiguating the expression `e` from the lemmas.\n","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.«command#simpOnly_=>__»","kind":"def","line":152,"name":"Mathlib.Tactic.Conv.«command#simpOnly_=>__»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Conv.lean#L152-L159"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.«command#whnfR_»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">«command#whnfR_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The command `#whnfR e` evaluates `e` to Weak Head Normal Form with Reducible transparency,\nthat is, it uses `whnf` but only unfolding reducible definitions.\n","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.«command#whnfR_»","kind":"def","line":150,"name":"Mathlib.Tactic.Conv.«command#whnfR_»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Conv.lean#L150-L150"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.«command#whnf_»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">«command#whnf_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The command `#whnf e` evaluates `e` to Weak Head Normal Form, which means that the \"head\"\nof the expression is reduced to a primitive - a lambda or forall, or an axiom or inductive type.\nIt is similar to `#reduce e`, but it does not reduce the expression completely,\nonly until the first constructor is exposed. For example:\n```\nopen Nat List\nset_option pp.notation false\n#whnf [1, 2, 3].map succ\n-- cons (succ 1) (map succ (cons 2 (cons 3 nil)))\n#reduce [1, 2, 3].map succ\n-- cons 2 (cons 3 (cons 4 nil))\n```\nThe head of this expression is the `List.cons` constructor,\nso we can see from this much that the list is not empty,\nbut the subterms `Nat.succ 1` and `List.map Nat.succ (List.cons 2 (List.cons 3 List.nil))` are\nstill unevaluated. `#reduce` is equivalent to using `#whnf` on every subexpression.\n","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.«command#whnf_»","kind":"def","line":144,"name":"Mathlib.Tactic.Conv.«command#whnf_»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Conv.lean#L144-L144"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.withReducible\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">withReducible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.withReducible","kind":"def","line":123,"name":"Mathlib.Tactic.Conv.withReducible","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Conv.lean#L123-L124"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.«command#conv_=&gt;_»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">«command#conv_=&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The command `#conv tac => e` will run a conv tactic `tac` on `e`, and display the resulting\nexpression (discarding the proof).\nFor example, `#conv rw [true_and_iff] => True ∧ False` displays `False`.\nThere are also shorthand commands for several common conv tactics:\n\n* `#whnf e` is short for `#conv whnf => e`\n* `#simp e` is short for `#conv simp => e`\n* `#norm_num e` is short for `#conv norm_num => e`\n* `#push_neg e` is short for `#conv push_neg => e`\n","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.«command#conv_=>_»","kind":"def","line":99,"name":"Mathlib.Tactic.Conv.«command#conv_=>_»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Conv.lean#L99-L120"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convRefine_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convRefine_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Use `refine` in `conv` mode. ","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convRefine_","kind":"def","line":96,"name":"Mathlib.Tactic.Conv.convRefine_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Conv.lean#L96-L96"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.elabDischargeConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">elabDischargeConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>","info":{"doc":"Elaborator for the `discharge` tactic. ","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.elabDischargeConv","kind":"def","line":78,"name":"Mathlib.Tactic.Conv.elabDischargeConv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Conv.lean#L78-L93"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.dischargeConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">dischargeConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"* `discharge => tac` is a conv tactic which rewrites target `p` to `True` if `tac` is a tactic\n  which proves the goal `⊢ p`.\n* `discharge` without argument returns `⊢ p` as a subgoal.\n","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.dischargeConv","kind":"def","line":71,"name":"Mathlib.Tactic.Conv.dischargeConv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Conv.lean#L71-L76"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.«convConvIn__=&gt;_»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">«convConvIn__=&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`conv in pat => cs` runs the `conv` tactic sequence `cs`\non the first subexpression matching the pattern `pat` in the target.\nThe converted expression becomes the new target subgoal, like `conv => cs`.\n\nThe arguments `in` are the same as those as the in `pattern`.\nIn fact, `conv in pat => cs` is a macro for `conv => pattern pat; cs`.\n\nThe syntax also supports the `occs` clause. Example:\n```lean\nconv in (occs := *) x + y => rw [add_comm]\n```\n","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.«convConvIn__=>_»","kind":"def","line":68,"name":"Mathlib.Tactic.Conv.«convConvIn__=>_»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Conv.lean#L68-L69"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convRun_conv_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convRun_conv_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convRun_conv_","kind":"def","line":53,"name":"Mathlib.Tactic.Conv.convRun_conv_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Conv.lean#L53-L53"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convRHS\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convRHS</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`conv_rhs => cs` runs the `conv` tactic sequence `cs` on the right hand side of the target.\n\nIn general, for an `n`-ary operator as the target, it traverses into the last argument.\nIt is a synonym for `conv => arg -1; cs`.\n\n* `conv_rhs at h => cs` runs `cs` on the right hand side of hypothesis `h`.\n* `conv_rhs in pat => cs` first looks for a subexpression matching `pat` (see the `pattern`\n  conv tactic) and then traverses into the right hand side of this subexpression.\n  This syntax also supports the `occs` clause for the pattern.\n","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convRHS","kind":"def","line":37,"name":"Mathlib.Tactic.Conv.convRHS","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Conv.lean#L37-L48"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convLHS\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convLHS</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`conv_lhs => cs` runs the `conv` tactic sequence `cs` on the left hand side of the target.\n\nIn general, for an `n`-ary operator as the target, it traverses into the second to last argument.\nIt is a synonym for `conv => arg -2; cs`.\n\n* `conv_lhs at h => cs` runs `cs` on the left hand side of hypothesis `h`.\n* `conv_lhs in pat => cs` first looks for a subexpression matching `pat` (see also the `pattern`\n  conv tactic) and then traverses into the left hand side of this subexpression.\n  This syntax also supports the `occs` clause for the pattern.\n","docLink":"./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convLHS","kind":"def","line":21,"name":"Mathlib.Tactic.Conv.convLHS","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Conv.lean#L21-L32"}}],"imports":["Init","Mathlib.Init","Lean.Elab.Tactic.Conv.Basic","Lean.Elab.Command"],"instances":[],"name":"Mathlib.Tactic.Conv"}