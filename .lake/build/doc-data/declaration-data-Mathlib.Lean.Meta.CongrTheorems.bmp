{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.trySolve\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">trySolve</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ty</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>","info":{"doc":"Driver for `trySolveCore`. ","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.trySolve","kind":"def","line":357,"name":"Lean.Meta.mkRichHCongr.trySolve","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L357-L364"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.trySolveCore\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">trySolveCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Given a type that is a bunch of equalities implying a goal (for example, a basic\ncongruence lemma), prove it if possible. Basic congruence lemmas should be provable by this.\nThere are some extra tricks for handling arguments to richer congruence lemmas. ","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.trySolveCore","kind":"def","line":342,"name":"Lean.Meta.mkRichHCongr.trySolveCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L342-L355"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.withNewEqs.loop\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">withNewEqs</span>.<span class=\"name\">loop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">info</span> : <a href=\"./Lean/Meta/Basic.html#Lean.Meta.FunInfo\">FunInfo</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs </span><span class=\"fn\">ys</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fixedParams</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">CongrArgKind</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>))</span></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">kinds</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">CongrArgKind</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eqs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>))</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.withNewEqs.loop","kind":"opaque","line":321,"name":"Lean.Meta.mkRichHCongr.withNewEqs.loop","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L321-L337"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.withNewEqs\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">withNewEqs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">info</span> : <a href=\"./Lean/Meta/Basic.html#Lean.Meta.FunInfo\">FunInfo</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs </span><span class=\"fn\">ys</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fixedParams</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">CongrArgKind</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>))</span></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Introduce variables for equalities between the arrays of variables. Uses `fixedParams`\nto control whether to introduce an equality for each pair. The array of triples passed to `k`\nconsists of (1) the simple congr lemma HEq arg, (2) the richer HEq arg, and (3) how to\ncompute 1 in terms of 2. ","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.withNewEqs","kind":"def","line":319,"name":"Lean.Meta.mkRichHCongr.withNewEqs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L319-L338"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.doubleTelescope.loop\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">doubleTelescope</span>.<span class=\"name\">loop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numVars</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fixed</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ftyx </span><span class=\"fn\">ftyy</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs </span><span class=\"fn\">ys</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fixed'</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.doubleTelescope.loop","kind":"opaque","line":293,"name":"Lean.Meta.mkRichHCongr.doubleTelescope.loop","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L293-L313"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.doubleTelescope\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">doubleTelescope</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fty</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numVars</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fixed</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Similar to doing `forallBoundedTelescope` twice, but makes use of the `fixed` array, which\nis used as a hint for whether both variables should be the same. This is only a hint though,\nsince we respect it only if the binding domains are equal.\nWe affix `'` to the second list of variables, and all the variables are introduced\nwith default binder info. Calls `k` with the xs, ys, and a revised `fixed` array ","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.doubleTelescope","kind":"def","line":291,"name":"Lean.Meta.mkRichHCongr.doubleTelescope","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L291-L314"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fType</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">info</span> : <a href=\"./Lean/Meta/Basic.html#Lean.Meta.FunInfo\">FunInfo</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fixedFun</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fixedParams</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">forceHEq</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">CongrTheorem</a></span></div></div>","info":{"doc":"`mkRichHCongr fType funInfo fixedFun fixedParams forceHEq`\ncreate a congruence lemma to prove that `Eq/HEq (f a₁ ... aₙ) (f' a₁' ... aₙ')`.\nThe functions have type `fType` and the number of arguments is governed by the `funInfo` data.\nEach argument produces an `Eq/HEq aᵢ aᵢ'` hypothesis, but we also provide these hypotheses\nthe additional facts that the preceding equalities have been proved (unlike in `mkHCongrWithArity`).\nThe first two arguments of the resulting theorem are for `f` and `f'`, followed by a proof\nof `f = f'`, unless `fixedFun` is `true` (see below).\n\nWhen including hypotheses about previous hypotheses, we make use of dependency information\nand only include relevant equalities.\n\nThe argument `fty` denotes the type of `f`. The arity of the resulting congruence lemma is\ncontrolled by the size of the `info` array.\n\nFor the purpose of generating nicer lemmas (to help `to_additive` for example),\nthis function supports generating lemmas where certain parameters\nare meant to be fixed:\n\n* If `fixedFun` is `false` (the default) then the lemma starts with three arguments for `f`, `f'`,\n  and `h : f = f'`. Otherwise, if `fixedFun` is `true` then the lemma starts with just `f`.\n\n* If the `fixedParams` argument has `true` for a particular argument index, then this is a hint\n  that the congruence lemma may use the same parameter for both sides of the equality. There is\n  no guarantee -- it respects it if the types are equal for that parameter (i.e., if the parameter\n  does not depend on non-fixed parameters).\n\nIf `forceHEq` is `true` then the conclusion of the generated theorem is a `HEq`.\nOtherwise it might be an `Eq` if the equality is homogeneous.\n\nThis is the interpretation of the `CongrArgKind`s in the generated congruence theorem:\n* `.eq` corresponds to having three arguments `(x : α) (x' : α) (h : x = x')`.\n  Note that `h` might have additional hypotheses.\n* `.heq` corresponds to having three arguments `(x : α) (x' : α') (h : x ≍ x')`\n  Note that `h` might have additional hypotheses.\n* `.fixed` corresponds to having a single argument `(x : α)` that is fixed between the LHS and RHS\n* `.subsingletonInst` corresponds to having two arguments `(x : α) (x' : α')` for which the\n  congruence generator was able to prove that `x ≍ x'` already. This is a slight abuse of\n  this `CongrArgKind` since this is used even for types that are not subsingleton typeclasses.\n\nNote that the first entry in this array is for the function itself.\n","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr","kind":"def","line":176,"name":"Lean.Meta.mkRichHCongr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L176-L364"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.fastSubsingletonElim\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">fastSubsingletonElim</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Like `subsingletonElim` but uses `FastSubsingleton` to fail fast. ","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.fastSubsingletonElim","kind":"def","line":162,"name":"Lean.Meta.fastSubsingletonElim","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L162-L174"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.withSubsingletonAsFast\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">withSubsingletonAsFast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mx</span> : <span class=\"fn\"><span class=\"fn\">(<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Runs `mx` in a context where all local `Subsingleton` and `IsEmpty` instances\nhave associated `FastSubsingleton` and `FastIsEmpty` instances.\nThe function passed to `mx` eliminates these instances from expressions,\nsince they are only locally valid inside this context.\n","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.withSubsingletonAsFast","kind":"def","line":142,"name":"Lean.Meta.withSubsingletonAsFast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L142-L160"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonForall\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastSubsingletonForall</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">inst</span> : <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">FastSubsingleton</a> <span class=\"fn\">(<span class=\"fn\">β</span> <span class=\"fn\">x</span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">FastSubsingleton</a> <span class=\"fn\">((<span class=\"fn\">x</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">x</span></span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonForall","kind":"instance","line":138,"name":"Lean.Meta.instFastSubsingletonForall","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L138-L140"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonForallOfFastIsEmpty\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastSubsingletonForallOfFastIsEmpty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">inst</span> : <span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\">FastIsEmpty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">FastSubsingleton</a> <span class=\"fn\">((<span class=\"fn\">x</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">x</span></span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonForallOfFastIsEmpty","kind":"instance","line":134,"name":"Lean.Meta.instFastSubsingletonForallOfFastIsEmpty","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L134-L136"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastIsEmptyFinOfNatNat\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastIsEmptyFinOfNatNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\">FastIsEmpty</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Fin\">Fin</a> <span class=\"fn\">0</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastIsEmptyFinOfNatNat","kind":"instance","line":132,"name":"Lean.Meta.instFastIsEmptyFinOfNatNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L132-L132"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastIsEmptyFalse\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastIsEmptyFalse</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\">FastIsEmpty</a> <a href=\"./Init/Prelude.html#False\">False</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastIsEmptyFalse","kind":"instance","line":130,"name":"Lean.Meta.instFastIsEmptyFalse","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L130-L130"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastIsEmptyEmpty\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastIsEmptyEmpty</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\">FastIsEmpty</a> <a href=\"./Init/Prelude.html#Empty\">Empty</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastIsEmptyEmpty","kind":"instance","line":128,"name":"Lean.Meta.instFastIsEmptyEmpty","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L128-L128"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonPUnit\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastSubsingletonPUnit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">FastSubsingleton</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit.{u_1}</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonPUnit","kind":"instance","line":126,"name":"Lean.Meta.instFastSubsingletonPUnit","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L126-L126"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonFinOfNatNat\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastSubsingletonFinOfNatNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">FastSubsingleton</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Fin\">Fin</a> <span class=\"fn\">1</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonFinOfNatNat","kind":"instance","line":124,"name":"Lean.Meta.instFastSubsingletonFinOfNatNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L124-L124"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonDecidable\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastSubsingletonDecidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">FastSubsingleton</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">p</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonDecidable","kind":"instance","line":122,"name":"Lean.Meta.instFastSubsingletonDecidable","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L122-L122"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingleton\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastSubsingleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">FastSubsingleton</a> <span class=\"fn\">p</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingleton","kind":"instance","line":120,"name":"Lean.Meta.instFastSubsingleton","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L120-L120"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonOfFastIsEmpty\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instFastSubsingletonOfFastIsEmpty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">inst</span> : <span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\">FastIsEmpty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">FastSubsingleton</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.instFastSubsingletonOfFastIsEmpty","kind":"instance","line":117,"name":"Lean.Meta.instFastSubsingletonOfFastIsEmpty","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L117-L118"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton.helim\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastSubsingleton</span>.<span class=\"name\">helim</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">FastSubsingleton</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HEq\">≍</a> <span class=\"fn\">b</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton.helim","kind":"theorem","line":112,"name":"Lean.Meta.FastSubsingleton.helim","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L112-L115"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton.elim\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastSubsingleton</span>.<span class=\"name\">elim</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">FastSubsingleton</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton.elim","kind":"theorem","line":109,"name":"Lean.Meta.FastSubsingleton.elim","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L109-L110"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty.inst\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastIsEmpty</span>.<span class=\"name\">inst</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\">FastIsEmpty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/IsEmpty.html#IsEmpty\">IsEmpty</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty.inst","kind":"theorem","line":107,"name":"Lean.Meta.FastIsEmpty.inst","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L107-L107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastIsEmpty</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">inst</span> : <span class=\"fn\"><a href=\"./Mathlib/Logic/IsEmpty.html#IsEmpty\">IsEmpty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\">FastIsEmpty</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty.mk","kind":"ctor","line":106,"name":"Lean.Meta.FastIsEmpty.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L106-L106"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastIsEmpty</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"A version of `IsEmpty` with few instances. It should fail fast. ","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastIsEmpty","kind":"class","line":105,"name":"Lean.Meta.FastIsEmpty","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L105-L107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton.inst\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastSubsingleton</span>.<span class=\"name\">inst</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">FastSubsingleton</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"The subsingleton instance. ","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton.inst","kind":"theorem","line":103,"name":"Lean.Meta.FastSubsingleton.inst","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L103-L103"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastSubsingleton</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">inst</span> : <span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\">FastSubsingleton</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton.mk","kind":"ctor","line":101,"name":"Lean.Meta.FastSubsingleton.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L101-L101"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FastSubsingleton</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"A version of `Subsingleton` with few instances. It should fail fast. ","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.FastSubsingleton","kind":"class","line":100,"name":"Lean.Meta.FastSubsingleton","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L100-L103"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'.prove\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkHCongrWithArity'</span>.<span class=\"name\">prove</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">params</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Close the goal given only the fvars in `params`, or else fails. ","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'.prove","kind":"def","line":82,"name":"Lean.Meta.mkHCongrWithArity'.prove","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L82-L96"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'.process\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkHCongrWithArity'</span>.<span class=\"name\">process</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cthm</span> : <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">CongrTheorem</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">argKinds</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">CongrArgKind</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">argKinds'</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">CongrArgKind</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">params </span><span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">letArgs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">CongrTheorem</a></span></div></div>","info":{"doc":"Process the congruence theorem by trying to pre-prove arguments using `prove`.\n\n- `cthm` is the original `CongrTheorem`, modified only after visiting every argument.\n- `type` is type of the congruence theorem, after all the parameters so far have been applied.\n- `argKinds` is the list of `CongrArgKind`s, which this function recurses on.\n- `argKinds'` is the accumulated array of `CongrArgKind`s, which is the original array but\n  with some kinds replaced by `.subsingletonInst`.\n- `params` is the *new* list of parameters, as fvars that need to be abstracted at the end.\n- `args` is the list of arguments (fvars) to supply to `cthm.proof` before abstracting `params`.\n- `letArgs` records `(fvar, expr)` assignments for each `fvar` that was solved for by `prove`.\n","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'.process","kind":"def","line":50,"name":"Lean.Meta.mkHCongrWithArity'.process","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L50-L80"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkHCongrWithArity'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numArgs</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">CongrTheorem</a></span></div></div>","info":{"doc":"Generates a congruence lemma for a function `f` for `numArgs` of its arguments.\nThe only `Lean.Meta.CongrArgKind` kinds that appear in such a lemma\nare `.eq`, `.heq`, and `.subsingletonInst`.\nThe resulting lemma proves either an `Eq` or a `HEq` depending on whether the types\nof the LHS and RHS are equal or not.\n\nThis function is a wrapper around `Lean.Meta.mkHCongrWithArity`.\nIt transforms the resulting congruence lemma by trying to automatically prove hypotheses\nusing subsingleton lemmas, and if they are so provable they are recorded with `.subsingletonInst`.\nNote that this is slightly abusing `.subsingletonInst` since\n(1) the argument might not be for a `Decidable` instance and\n(2) the argument might not even be an instance. ","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'","kind":"def","line":22,"name":"Lean.Meta.mkHCongrWithArity'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Lean/Meta/CongrTheorems.lean#L22-L96"}}],"imports":["Init","Lean.Meta.Tactic.Cleanup","Lean.Meta.Tactic.Refl","Mathlib.Logic.IsEmpty"],"instances":[{"className":"Lean.Meta.FastSubsingleton","name":"Lean.Meta.instFastSubsingletonOfFastIsEmpty","typeNames":[]},{"className":"Lean.Meta.FastSubsingleton","name":"Lean.Meta.instFastSubsingleton","typeNames":[]},{"className":"Lean.Meta.FastSubsingleton","name":"Lean.Meta.instFastSubsingletonDecidable","typeNames":["Decidable"]},{"className":"Lean.Meta.FastSubsingleton","name":"Lean.Meta.instFastSubsingletonFinOfNatNat","typeNames":["Fin"]},{"className":"Lean.Meta.FastSubsingleton","name":"Lean.Meta.instFastSubsingletonPUnit","typeNames":["PUnit"]},{"className":"Lean.Meta.FastIsEmpty","name":"Lean.Meta.instFastIsEmptyEmpty","typeNames":["Empty"]},{"className":"Lean.Meta.FastIsEmpty","name":"Lean.Meta.instFastIsEmptyFalse","typeNames":["False"]},{"className":"Lean.Meta.FastIsEmpty","name":"Lean.Meta.instFastIsEmptyFinOfNatNat","typeNames":["Fin"]},{"className":"Lean.Meta.FastSubsingleton","name":"Lean.Meta.instFastSubsingletonForallOfFastIsEmpty","typeNames":[]},{"className":"Lean.Meta.FastSubsingleton","name":"Lean.Meta.instFastSubsingletonForall","typeNames":[]}],"name":"Mathlib.Lean.Meta.CongrTheorems"}