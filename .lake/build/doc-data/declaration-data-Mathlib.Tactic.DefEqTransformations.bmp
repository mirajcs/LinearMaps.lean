{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_struct\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convEta_struct</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`eta_struct at loc` transforms structure constructor applications such as `S.mk x.1 ... x.n`\n(pretty printed as, for example, `{a := x.a, b := x.b, ...}`) into `x`.\nThis also exists as a `conv`-mode tactic.\n\nThe transformation is known as eta reduction for structures, and it yields definitionally\nequal expressions.\n\nFor example, given `x : α × β`, then `(x.1, x.2)` becomes `x` after this transformation.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_struct","kind":"def","line":340,"name":"Mathlib.Tactic.convEta_struct","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L340-L341"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStructStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`eta_struct at loc` transforms structure constructor applications such as `S.mk x.1 ... x.n`\n(pretty printed as, for example, `{a := x.a, b := x.b, ...}`) into `x`.\nThis also exists as a `conv`-mode tactic.\n\nThe transformation is known as eta reduction for structures, and it yields definitionally\nequal expressions.\n\nFor example, given `x : α × β`, then `(x.1, x.2)` becomes `x` after this transformation.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructStx","kind":"def","line":327,"name":"Mathlib.Tactic.etaStructStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L327-L338"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructAll\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStructAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Finds all occurrences of expressions of the form `S.mk x.1 ... x.n` where `S.mk`\nis a structure constructor and replaces them by `x`. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructAll","kind":"def","line":318,"name":"Mathlib.Tactic.etaStructAll","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L318-L325"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStruct?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStruct?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tryWhnfR</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Checks if the expression is of the form `S.mk x.1 ... x.n` with `n` nonzero\nand `S.mk` a structure constructor and returns `x`.\nEach projection `x.i` can be either a native projection or from a projection function.\n\n`tryWhnfR` controls whether to try applying `whnfR` to arguments when none of them\nare obviously projections.\n\nOnce an obviously correct projection is found, relies on the structure eta rule in `isDefEq`. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStruct?","kind":"def","line":279,"name":"Mathlib.Tactic.etaStruct?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L279-L316"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.getProjectedExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">getProjectedExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>))</span></span></div></div>","info":{"doc":"Given an expression that's either a native projection or a registered projection\nfunction, gives (1) the name of the structure type, (2) the index of the projection, and\n(3) the object being projected. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.getProjectedExpr","kind":"def","line":266,"name":"Mathlib.Tactic.getProjectedExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L266-L277"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_expand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convEta_expand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`eta_expand at loc` eta expands all sub-expressions at the given location.\nIt also beta reduces any applications of eta expanded terms, so it puts it\ninto an eta-expanded \"normal form.\"\nThis also exists as a `conv`-mode tactic.\n\nFor example, if `f` takes two arguments, then `f` becomes `fun x y => f x y`\nand `f x` becomes `fun y => f x y`.\n\nThis can be useful to turn, for example, a raw `HAdd.hAdd` into `fun x y => x + y`.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_expand","kind":"def","line":260,"name":"Mathlib.Tactic.convEta_expand","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L260-L261"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaExpandStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`eta_expand at loc` eta expands all sub-expressions at the given location.\nIt also beta reduces any applications of eta expanded terms, so it puts it\ninto an eta-expanded \"normal form.\"\nThis also exists as a `conv`-mode tactic.\n\nFor example, if `f` takes two arguments, then `f` becomes `fun x y => f x y`\nand `f x` becomes `fun y => f x y`.\n\nThis can be useful to turn, for example, a raw `HAdd.hAdd` into `fun x y => x + y`.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandStx","kind":"def","line":246,"name":"Mathlib.Tactic.etaExpandStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L246-L258"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandAll\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaExpandAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Eta expand every sub-expression in the given expression.\n\nAs a side-effect, beta reduces any pre-existing instances of eta expanded terms. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandAll","kind":"opaque","line":224,"name":"Mathlib.Tactic.etaExpandAll","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L224-L244"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_reduce\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convEta_reduce</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`eta_reduce at loc` eta reduces all sub-expressions at the given location.\nThis also exists as a `conv`-mode tactic.\n\nFor example, `fun x y => f x y` becomes `f` after eta reduction.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_reduce","kind":"def","line":218,"name":"Mathlib.Tactic.convEta_reduce","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L218-L219"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaReduceStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`eta_reduce at loc` eta reduces all sub-expressions at the given location.\nThis also exists as a `conv`-mode tactic.\n\nFor example, `fun x y => f x y` becomes `f` after eta reduction.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceStx","kind":"def","line":209,"name":"Mathlib.Tactic.etaReduceStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L209-L216"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceAll\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaReduceAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Eta reduce everything ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceAll","kind":"def","line":202,"name":"Mathlib.Tactic.etaReduceAll","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L202-L207"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convUnfold_projs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convUnfold_projs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`unfold_projs at loc` unfolds projections of class instances at the given location.\nThis also exists as a `conv`-mode tactic.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convUnfold_projs","kind":"def","line":196,"name":"Mathlib.Tactic.convUnfold_projs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L196-L197"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjsStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldProjsStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`unfold_projs at loc` unfolds projections of class instances at the given location.\nThis also exists as a `conv`-mode tactic.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjsStx","kind":"def","line":189,"name":"Mathlib.Tactic.unfoldProjsStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L189-L194"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldProjs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Recursively unfold all the projection applications for class instances. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjs","kind":"def","line":181,"name":"Mathlib.Tactic.unfoldProjs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L181-L187"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convRefold_let___\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convRefold_let___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`refold_let x y z at loc` looks for the bodies of local definitions `x`, `y`, and `z` at the given\nlocation and replaces them with `x`, `y`, or `z`. This is the inverse of \"zeta reduction.\"\nThis also exists as a `conv`-mode tactic.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convRefold_let___","kind":"def","line":171,"name":"Mathlib.Tactic.convRefold_let___","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L171-L172"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.refoldLetStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">refoldLetStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`refold_let x y z at loc` looks for the bodies of local definitions `x`, `y`, and `z` at the given\nlocation and replaces them with `x`, `y`, or `z`. This is the inverse of \"zeta reduction.\"\nThis also exists as a `conv`-mode tactic.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.refoldLetStx","kind":"def","line":158,"name":"Mathlib.Tactic.refoldLetStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L158-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.refoldFVars\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">refoldFVars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvars</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">loc?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"For each fvar, looks for its body in `e` and replaces it with the fvar. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.refoldFVars","kind":"def","line":140,"name":"Mathlib.Tactic.refoldFVars","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L140-L156"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldFVars\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldFVars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvars</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Unfold all the fvars from `fvars` in `e` that have local definitions (are \"let-bound\"). ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldFVars","kind":"def","line":124,"name":"Mathlib.Tactic.unfoldFVars","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L124-L136"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticReduce__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticReduce__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`reduce at loc` completely reduces the given location.\nThis also exists as a `conv`-mode tactic.\n\nThis does the same transformation as the `#reduce` command.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticReduce__","kind":"def","line":112,"name":"Mathlib.Tactic.tacticReduce__","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L112-L119"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convBeta_reduce\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convBeta_reduce</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`beta_reduce at loc` completely beta reduces the given location.\nThis also exists as a `conv`-mode tactic.\n\nThis means that whenever there is an applied lambda expression such as\n`(fun x => f x) y` then the argument is substituted into the lambda expression\nyielding an expression such as `f y`.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convBeta_reduce","kind":"def","line":106,"name":"Mathlib.Tactic.convBeta_reduce","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L106-L107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.betaReduceStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">betaReduceStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`beta_reduce at loc` completely beta reduces the given location.\nThis also exists as a `conv`-mode tactic.\n\nThis means that whenever there is an applied lambda expression such as\n`(fun x => f x) y` then the argument is substituted into the lambda expression\nyielding an expression such as `f y`.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.betaReduceStx","kind":"def","line":95,"name":"Mathlib.Tactic.betaReduceStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L95-L104"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticWhnf__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticWhnf__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`whnf at loc` puts the given location into weak-head normal form.\nThis also exists as a `conv`-mode tactic.\n\nWeak-head normal form is when the outer-most expression has been fully reduced, the expression\nmay contain subexpressions which have not been reduced.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticWhnf__","kind":"def","line":82,"name":"Mathlib.Tactic.tacticWhnf__","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L82-L90"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqConvTactic\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">runDefEqConvTactic</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Like `Mathlib.Tactic.runDefEqTactic` but for `conv` mode. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqConvTactic","kind":"def","line":75,"name":"Mathlib.Tactic.runDefEqConvTactic","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L75-L77"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqTactic\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">runDefEqTactic</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">loc?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.location</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tacticName</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">checkDefEq</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"For the main goal, use `m` to transform the types of locations specified by `loc?`.\nIf `loc?` is none, then transforms the type of target. `m` is provided with an expression\nwith instantiated metavariables as well as, if the location is a local hypothesis, the fvar.\n\n`m` *must* transform expressions to defeq expressions.\nIf `checkDefEq = true` (the default) then `runDefEqTactic` will throw an error\nif the resulting expression is not definitionally equal to the original expression. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqTactic","kind":"def","line":50,"name":"Mathlib.Tactic.runDefEqTactic","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L50-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Lean.MVarId.changeLocalDecl'\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">changeLocalDecl'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvarId</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">typeNew</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">checkDefEq</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>","info":{"doc":"This is `Lean.MVarId.changeLocalDecl` but makes sure to preserve local variable order.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Lean.MVarId.changeLocalDecl'","kind":"def","line":25,"name":"Lean.MVarId.changeLocalDecl'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/DefEqTransformations.lean#L25-L48"}}],"imports":["Init","Mathlib.Tactic.Basic","Mathlib.Tactic.Basic"],"instances":[],"name":"Mathlib.Tactic.DefEqTransformations"}