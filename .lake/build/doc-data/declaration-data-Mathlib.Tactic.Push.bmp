{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabPushTree\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">elabPushTree</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElab\">Lean.Elab.Command.CommandElab</a></div></div>","info":{"doc":"`#push_discr_tree X` shows the discrimination tree of all lemmas used by `push X`.\nThis can be helpful when you are constructing a set of `push` lemmas for the constant `X`.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabPushTree","kind":"def","line":380,"name":"Mathlib.Tactic.Push.elabPushTree","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L380-L397"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushTree\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushTree</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`#push_discr_tree X` shows the discrimination tree of all lemmas used by `push X`.\nThis can be helpful when you are constructing a set of `push` lemmas for the constant `X`.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushTree","kind":"def","line":374,"name":"Mathlib.Tactic.Push.pushTree","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L374-L378"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullCommand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pullCommand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The syntax is `#pull head e`, where `head` is a constant and `e` is an expression,\nwhich will print the `pull head` form of `e`.\n\n`#pull` understands local variables, so you can use them to introduce parameters.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullCommand","kind":"def","line":366,"name":"Mathlib.Tactic.Push.pullCommand","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L366-L368"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPull____\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">convPull____</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`pull c` rewrites the goal by pulling the constant `c` closer to the head of the expression.\nFor instance, `pull _ ∈ _` rewrites `x ∈ y ∨ ¬ x ∈ z` into `x ∈ y ∪ zᶜ`.\nMore precisely, the `pull` tactic repeatedly rewrites an expression by applying lemmas\nof the form `... (c ...) = c ...` (where `c` can appear 1 or more times on the left hand side).\n`pull` is the inverse tactic to `push`. To extend the `pull` tactic, you can tag a lemma\nwith the `@[push]` attribute. `pull` works as both a tactic and a conv tactic.\n\nA lemma is considered a `pull` lemma if its reverse direction is a `push` lemma\nthat actually moves the given constant away from the head. For example\n- `not_or : ¬ (p ∨ q) ↔ ¬ p ∧ ¬ q` is a `pull` lemma, but `not_not : ¬ ¬ p ↔ p` is not.\n- `log_mul : log (x * y) = log x + log y` is a `pull` lemma, but `log_abs : log |x| = log x` is not.\n- `Pi.mul_def : f * g = fun (i : ι) => f i * g i` and `Pi.one_def : 1 = fun (x : ι) => 1` are both\n  `pull` lemmas for `fun`, because every `push fun _ ↦ _` lemma is also considered a `pull` lemma.\n\nTODO: define a `@[pull]` attribute for tagging `pull` lemmas that are not `push` lemmas.\n\n* `pull _ ~ _` pulls the operator or relation `~`.\n* `pull c at l1 l2 ...` rewrites at the given locations.\n* `pull c at *` rewrites at all hypotheses and the goal.\n* `pull (disch := tac) c` uses the tactic `tac` to discharge any hypotheses for `@[push]` lemmas.\n\nExamples:\n* `pull _ ∈ _` rewrites `x ∈ y ∨ ¬ x ∈ z` into `x ∈ y ∪ zᶜ`.\n* `pull (disch := positivity) Real.log` rewrites `log a + 2 * log b` into `log (a * b ^ 2)`.\n* `pull fun _ ↦ _` rewrites `f ^ 2 + 5` into `fun x => f x ^ 2 + 5` where `f` is a function.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPull____","kind":"def","line":354,"name":"Mathlib.Tactic.Push.convPull____","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L354-L358"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushNegCommand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushNegCommand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`#push_neg e`, where `e` is an expression,\nprints the `push_neg` form of `e`.\n\n`#push_neg` understands local variables, so you can use them to introduce parameters.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushNegCommand","kind":"def","line":351,"name":"Mathlib.Tactic.Push.pushNegCommand","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L351-L352"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushCommand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushCommand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`#push head e`, where `head` is a constant and `e` is an expression,\nprints the `push head` form of `e`.\n\n`#push` understands local variables, so you can use them to introduce parameters.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushCommand","kind":"def","line":341,"name":"Mathlib.Tactic.Push.pushCommand","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L341-L343"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPush_neg_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">convPush_neg_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`push_neg` rewrites the goal by pushing negations deeper into an expression.\nFor instance, the goal `¬ ∀ x, ∃ y, x ≤ y` will be transformed by `push_neg` into\n`∃ x, ∀ y, y < x`. Binder names are preserved (contrary to what would happen with `simp`\nusing the relevant lemmas). `push_neg` works as both a tactic and a conv tactic.\n\n`push_neg` is a special case of the more general `push` tactic, namely `push Not`.\nThe `push` tactic can be extended using the `@[push]` attribute. `push` has special-casing\nbuilt in for `push Not`.\n\nTactics that introduce a negation usually have a version that automatically calls `push_neg` on\nthat negation. These include `by_cases!`, `contrapose!` and `by_contra!`.\n\n* `push_neg at l1 l2 ...` rewrites at the given locations.\n* `push_neg at *` rewrites at each hypothesis and the goal.\n* `push_neg +distrib` rewrites `¬ (p ∧ q)` into `¬ p ∨ ¬ q` (by default, the tactic rewrites it\n  into `p → ¬ q` instead).\n\nExample:\n\n```lean\nexample (h : ¬ ∀ ε > 0, ∃ δ > 0, ∀ x, |x - x₀| ≤ δ → |f x - y₀| ≤ ε) :\n    ∃ ε > 0, ∀ δ > 0, ∃ x, |x - x₀| ≤ δ ∧ ε < |f x - y₀| := by\n  push_neg at h\n  -- Now we have the hypothesis `h : ∃ ε > 0, ∀ δ > 0, ∃ x, |x - x₀| ≤ δ ∧ ε < |f x - y₀|`\n  exact h\n```\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPush_neg_","kind":"def","line":333,"name":"Mathlib.Tactic.Push.convPush_neg_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L333-L333"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPush_____\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">convPush_____</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`push c` rewrites the goal by pushing the constant `c` deeper into an expression.\nFor instance, `push _ ∈ _` rewrites `x ∈ {y} ∪ zᶜ` into `x = y ∨ ¬ x ∈ z`.\nMore precisely, the `push` tactic repeatedly rewrites an expression by applying lemmas\nof the form `c ... = ... (c ...)` (where `c` can appear 0 or more times on the right hand side).\nTo extend the `push` tactic, you can tag a lemma of this form with the `@[push]` attribute.\n\nTo instead move a constant closer to the head of the expression, use the `pull` tactic.\n\n`push` works as both a tactic and a conv tactic.\n\n* `push _ ~ _` pushes the (binary) operator `~`, `push ~ _` pushes the (unary) operator `~`.\n* `push c at l1 l2 ...` rewrites at the given locations.\n* `push c at *` rewrites at all hypotheses and the goal.\n* `push (disch := tac) c` uses the tactic `tac` to discharge any hypotheses for `@[push]` lemmas.\n\nExamples:\n* `push _ ∈ _` rewrites `x ∈ {y} ∪ zᶜ` into `x = y ∨ ¬ x ∈ z`.\n* `push (disch := positivity) Real.log` rewrites `log (a * b ^ 2)` into `log a + 2 * log b`.\n* `push ¬ _` is the same as `push_neg` or `push Not`, and it rewrites\n  `¬ ∀ ε > 0, ∃ δ > 0, δ < ε` into `∃ ε > 0, ∀ δ > 0, ε ≤ δ`.\n* `push fun _ ↦ _` rewrites `fun x => f x ^ 2 + 5` into `f ^ 2 + 5`\n* `push ∀ _, _` rewrites `∀ a, p a ∧ q a` into `(∀ a, p a) ∧ (∀ a, q a)`.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPush_____","kind":"def","line":321,"name":"Mathlib.Tactic.Push.convPush_____","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L321-L330"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#pullFun\"><span class=\"name\">pullFun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"A simproc variant of `pull fun _ ↦ _`, to be used as `simp [pullFun]`. ","docLink":"./Mathlib/Tactic/Push.html#pullFun","kind":"def","line":316,"name":"pullFun","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L316-L317"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#pushFun\"><span class=\"name\">pushFun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"A simproc variant of `push fun _ ↦ _`, to be used as `simp [↓pushFun]`. ","docLink":"./Mathlib/Tactic/Push.html#pushFun","kind":"def","line":313,"name":"pushFun","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L313-L314"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pull\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pull</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`pull c` rewrites the goal by pulling the constant `c` closer to the head of the expression.\nFor instance, `pull _ ∈ _` rewrites `x ∈ y ∨ ¬ x ∈ z` into `x ∈ y ∪ zᶜ`.\nMore precisely, the `pull` tactic repeatedly rewrites an expression by applying lemmas\nof the form `... (c ...) = c ...` (where `c` can appear 1 or more times on the left hand side).\n`pull` is the inverse tactic to `push`. To extend the `pull` tactic, you can tag a lemma\nwith the `@[push]` attribute. `pull` works as both a tactic and a conv tactic.\n\nA lemma is considered a `pull` lemma if its reverse direction is a `push` lemma\nthat actually moves the given constant away from the head. For example\n- `not_or : ¬ (p ∨ q) ↔ ¬ p ∧ ¬ q` is a `pull` lemma, but `not_not : ¬ ¬ p ↔ p` is not.\n- `log_mul : log (x * y) = log x + log y` is a `pull` lemma, but `log_abs : log |x| = log x` is not.\n- `Pi.mul_def : f * g = fun (i : ι) => f i * g i` and `Pi.one_def : 1 = fun (x : ι) => 1` are both\n  `pull` lemmas for `fun`, because every `push fun _ ↦ _` lemma is also considered a `pull` lemma.\n\nTODO: define a `@[pull]` attribute for tagging `pull` lemmas that are not `push` lemmas.\n\n* `pull _ ~ _` pulls the operator or relation `~`.\n* `pull c at l1 l2 ...` rewrites at the given locations.\n* `pull c at *` rewrites at all hypotheses and the goal.\n* `pull (disch := tac) c` uses the tactic `tac` to discharge any hypotheses for `@[push]` lemmas.\n\nExamples:\n* `pull _ ∈ _` rewrites `x ∈ y ∨ ¬ x ∈ z` into `x ∈ y ∪ zᶜ`.\n* `pull (disch := positivity) Real.log` rewrites `log a + 2 * log b` into `log (a * b ^ 2)`.\n* `pull fun _ ↦ _` rewrites `f ^ 2 + 5` into `fun x => f x ^ 2 + 5` where `f` is a function.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pull","kind":"def","line":279,"name":"Mathlib.Tactic.Push.pull","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L279-L311"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">push_neg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`push_neg` rewrites the goal by pushing negations deeper into an expression.\nFor instance, the goal `¬ ∀ x, ∃ y, x ≤ y` will be transformed by `push_neg` into\n`∃ x, ∀ y, y < x`. Binder names are preserved (contrary to what would happen with `simp`\nusing the relevant lemmas). `push_neg` works as both a tactic and a conv tactic.\n\n`push_neg` is a special case of the more general `push` tactic, namely `push Not`.\nThe `push` tactic can be extended using the `@[push]` attribute. `push` has special-casing\nbuilt in for `push Not`.\n\nTactics that introduce a negation usually have a version that automatically calls `push_neg` on\nthat negation. These include `by_cases!`, `contrapose!` and `by_contra!`.\n\n* `push_neg at l1 l2 ...` rewrites at the given locations.\n* `push_neg at *` rewrites at each hypothesis and the goal.\n* `push_neg +distrib` rewrites `¬ (p ∧ q)` into `¬ p ∨ ¬ q` (by default, the tactic rewrites it\n  into `p → ¬ q` instead).\n\nExample:\n\n```lean\nexample (h : ¬ ∀ ε > 0, ∃ δ > 0, ∀ x, |x - x₀| ≤ δ → |f x - y₀| ≤ ε) :\n    ∃ ε > 0, ∀ δ > 0, ∃ x, |x - x₀| ≤ δ ∧ ε < |f x - y₀| := by\n  push_neg at h\n  -- Now we have the hypothesis `h : ∃ ε > 0, ∀ δ > 0, ∃ x, |x - x₀| ≤ δ ∧ ε < |f x - y₀|`\n  exact h\n```\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push_neg","kind":"def","line":247,"name":"Mathlib.Tactic.Push.push_neg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L247-L277"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`push c` rewrites the goal by pushing the constant `c` deeper into an expression.\nFor instance, `push _ ∈ _` rewrites `x ∈ {y} ∪ zᶜ` into `x = y ∨ ¬ x ∈ z`.\nMore precisely, the `push` tactic repeatedly rewrites an expression by applying lemmas\nof the form `c ... = ... (c ...)` (where `c` can appear 0 or more times on the right hand side).\nTo extend the `push` tactic, you can tag a lemma of this form with the `@[push]` attribute.\n\nTo instead move a constant closer to the head of the expression, use the `pull` tactic.\n\n`push` works as both a tactic and a conv tactic.\n\n* `push _ ~ _` pushes the (binary) operator `~`, `push ~ _` pushes the (unary) operator `~`.\n* `push c at l1 l2 ...` rewrites at the given locations.\n* `push c at *` rewrites at all hypotheses and the goal.\n* `push (disch := tac) c` uses the tactic `tac` to discharge any hypotheses for `@[push]` lemmas.\n\nExamples:\n* `push _ ∈ _` rewrites `x ∈ {y} ∪ zᶜ` into `x = y ∨ ¬ x ∈ z`.\n* `push (disch := positivity) Real.log` rewrites `log (a * b ^ 2)` into `log a + 2 * log b`.\n* `push ¬ _` is the same as `push_neg` or `push Not`, and it rewrites\n  `¬ ∀ ε > 0, ∃ δ > 0, δ < ε` into `∃ ε > 0, ∀ δ > 0, ε ≤ δ`.\n* `push fun _ ↦ _` rewrites `fun x => f x ^ 2 + 5` into `f ^ 2 + 5`\n* `push ∀ _, _` rewrites `∀ a, p a ∧ q a` into `(∀ a, p a) ∧ (∀ a, q a)`.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushStx","kind":"def","line":217,"name":"Mathlib.Tactic.Push.pushStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L217-L245"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">push</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config\">Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Tactic/Simp/Rewrite.html#Lean.Meta.Simp.Discharge\">Lean.Meta.Simp.Discharge</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">head</span> : <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">loc</span> : <a href=\"./Lean/Elab/Tactic/Location.html#Lean.Elab.Tactic.Location\">Lean.Elab.Tactic.Location</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">failIfUnchanged</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Run the `push` tactic. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push","kind":"def","line":211,"name":"Mathlib.Tactic.Push.push","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L211-L215"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabDischarger\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">elabDischarger</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.discharger</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Lean/Meta/Tactic/Simp/Rewrite.html#Lean.Meta.Simp.Discharge\">Lean.Meta.Simp.Discharge</a></span></div></div>","info":{"doc":"Elaborate the `(disch := ...)` syntax for a `simp`-like tactic. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabDischarger","kind":"def","line":207,"name":"Mathlib.Tactic.Push.elabDischarger","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L207-L209"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabHead\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">elabHead</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a></span></div></div>","info":{"doc":"Elaborator for the argument passed to `push`. It accepts a constant, or a function ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabHead","kind":"def","line":189,"name":"Mathlib.Tactic.Push.elabHead","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L189-L203"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.resolvePushId?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">resolvePushId?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"`resolvePushId?` is a version of `resolveId?` that also supports notations like `_ ∈ _`,\n`∃ x, _` and `∑ x, _`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.resolvePushId?","kind":"def","line":167,"name":"Mathlib.Tactic.Push.resolvePushId?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L167-L187"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.isUnderscore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">isUnderscore</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Return `true` if `stx` is an underscore, i.e. `_` or `fun $_ => _`/`fun $_ ↦ _`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.isUnderscore","kind":"def","line":162,"name":"Mathlib.Tactic.Push.isUnderscore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L162-L165"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pullCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">head</span> : <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tgt</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Tactic/Simp/Rewrite.html#Lean.Meta.Simp.Discharge\">Lean.Meta.Simp.Discharge</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Common entry point to the implementation of `pull`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullCore","kind":"def","line":149,"name":"Mathlib.Tactic.Push.pullCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L149-L157"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullStep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pullStep</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">head</span> : <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"Try to rewrite using a `pull` lemma. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullStep","kind":"def","line":134,"name":"Mathlib.Tactic.Push.pullStep","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L134-L147"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">head</span> : <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config\">Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Tactic/Simp/Rewrite.html#Lean.Meta.Simp.Discharge\">Lean.Meta.Simp.Discharge</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tgt</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Common entry point to the implementation of `push`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushCore","kind":"def","line":123,"name":"Mathlib.Tactic.Push.pushCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L123-L132"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushStep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushStep</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">head</span> : <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"Try to rewrite using a `push` lemma. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushStep","kind":"def","line":107,"name":"Mathlib.Tactic.Push.pushStep","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L107-L121"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushSimpConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushSimpConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.Simp.Config\">Lean.Meta.Simp.Config</a></div></div>","info":{"doc":"The `simp` configuration used in `push`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushSimpConfig","kind":"def","line":102,"name":"Mathlib.Tactic.Push.pushSimpConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L102-L105"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabPushConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">elabPushConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config\">Config</a></span></span></div></div>","info":{"doc":"Function elaborating `Push.Config`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabPushConfig","kind":"def","line":75,"name":"Mathlib.Tactic.Push.elabPushConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L75-L76"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config.distrib\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">Config</span>.<span class=\"name\">distrib</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"If `true` (default `false`), rewrite `¬ (p ∧ q)` into `¬ p ∨ ¬ q` instead of `p → ¬ q`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config.distrib","kind":"def","line":73,"name":"Mathlib.Tactic.Push.Config.distrib","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L73-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">distrib</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config\">Config</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config.mk","kind":"ctor","line":71,"name":"Mathlib.Tactic.Push.Config.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L71-L71"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The configuration options for the `push` tactic. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config","kind":"structure","line":70,"name":"Mathlib.Tactic.Push.Config","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L70-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push_neg.use_distrib\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">push_neg</span>.<span class=\"name\">use_distrib</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Set `distrib` to true in `push_neg` and related tactics. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push_neg.use_distrib","kind":"opaque","line":63,"name":"Mathlib.Tactic.Push.push_neg.use_distrib","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L63-L66"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_forall_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_forall_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\">(<a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">s</span> <span class=\"fn\">x</span></span></span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Core.html#Exists\">∃</a> <a href=\"./Init/Core.html#Exists\">(</a><span class=\"fn\">x</span> <a href=\"./Init/Core.html#Exists\">:</a> <span class=\"fn\">α</span><a href=\"./Init/Core.html#Exists\">)</a><a href=\"./Init/Core.html#Exists\">,</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\">s</span> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_forall_eq","kind":"theorem","line":61,"name":"Mathlib.Tactic.Push.not_forall_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L61-L61"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_and_or_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_and_or_eq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\">(<a href=\"./Init/Prelude.html#Not\">¬</a>(<span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">q</span>)) <a href=\"./Init/Prelude.html#Eq\">=</a> (<a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">q</span>)</div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_and_or_eq","kind":"theorem","line":60,"name":"Mathlib.Tactic.Push.not_and_or_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L60-L60"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_and_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_and_eq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\">(<a href=\"./Init/Prelude.html#Not\">¬</a>(<span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">q</span>)) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\">p</span> → <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">q</span>)</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_and_eq","kind":"theorem","line":59,"name":"Mathlib.Tactic.Push.not_and_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L59-L59"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_exists\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_exists</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><a href=\"./Init/Core.html#Exists\">Exists</a> <span class=\"fn\">s</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/BinderNameHint.html#binderNameHint\">binderNameHint</a> <span class=\"fn\">x</span> <span class=\"fn\">s</span> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\">s</span> <span class=\"fn\">x</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_exists","kind":"theorem","line":38,"name":"Mathlib.Tactic.Push.not_exists","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L38-L39"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_iff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_iff</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Not\">¬</a>(<span class=\"fn\">p</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">q</span>) <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#And\">∧</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">q</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">q</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_iff","kind":"theorem","line":36,"name":"Mathlib.Tactic.Push.not_iff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Push.lean#L36-L37"}}],"imports":["Init","Lean.Elab.Tactic.Location","Mathlib.Logic.Basic","Mathlib.Tactic.Basic","Mathlib.Tactic.Conv","Mathlib.Tactic.Push.Attr","Mathlib.Util.AtLocation"],"instances":[],"name":"Mathlib.Tactic.Push"}