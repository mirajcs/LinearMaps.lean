{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.wlog!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">wlog!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`wlog h : P` adds an assumption `h : P` to the main goal, and adds a side goal that\nrequires showing that the case `h : ¬ P` can be reduced to the case where `P` holds\n(typically by symmetry). The side goal will be at the top of the stack. In this side goal,\nthere will be two additional assumptions:\n- `h : ¬ P`: the assumption that `P` does not hold\n- `this`: which is the statement that in the old context `P` suffices to prove the goal.\n  By default, the entire context is reverted to produce `this`.\n\n* `wlog h : P with H` gives the name `H` to the statement that `P` proves the goal.\n* `wlog h : P generalizing x y ...` reverts certain parts of the context before creating the new\n  goal. In this way, the wlog-claim `this` can be applied to `x` and `y` in different orders\n  (exploiting symmetry, which is the typical use case).\n* `wlog! h : P` also calls `push_neg` at the generated hypothesis `h`.\n  `wlog! h : P ∧ Q` will transform `¬ (P ∧ Q)` to `P → ¬ Q`\n* `wlog! +distrib h : P` also calls `push_neg +distrib` at the generated hypothesis `h`.\n  `wlog! +distrib h : P ∧ Q` will transform `¬ (P ∧ Q)` to `¬P ∨ ¬Q`.\n","docLink":"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.wlog!","kind":"def","line":162,"name":"Mathlib.Tactic.wlog!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/WLOG.lean#L162-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.wlog\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">wlog</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`wlog h : P` adds an assumption `h : P` to the main goal, and adds a side goal that\nrequires showing that the case `h : ¬ P` can be reduced to the case where `P` holds\n(typically by symmetry). The side goal will be at the top of the stack. In this side goal,\nthere will be two additional assumptions:\n- `h : ¬ P`: the assumption that `P` does not hold\n- `this`: which is the statement that in the old context `P` suffices to prove the goal.\n  By default, the entire context is reverted to produce `this`.\n\n* `wlog h : P with H` gives the name `H` to the statement that `P` proves the goal.\n* `wlog h : P generalizing x y ...` reverts certain parts of the context before creating the new\n  goal. In this way, the wlog-claim `this` can be applied to `x` and `y` in different orders\n  (exploiting symmetry, which is the typical use case).\n* `wlog! h : P` also calls `push_neg` at the generated hypothesis `h`.\n  `wlog! h : P ∧ Q` will transform `¬ (P ∧ Q)` to `P → ¬ Q`\n* `wlog! +distrib h : P` also calls `push_neg +distrib` at the generated hypothesis `h`.\n  `wlog! +distrib h : P ∧ Q` will transform `¬ (P ∧ Q)` to `¬P ∨ ¬Q`.\n","docLink":"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.wlog","kind":"def","line":138,"name":"Mathlib.Tactic.wlog","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/WLOG.lean#L138-L156"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.wlogCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">wlogCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">Lean.TSyntaxArray</a> <span class=\"fn\">`ident</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`ident</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pushConfig</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.optConfig</span>)</span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"The implementation of `wlog` and `wlog!` ","docLink":"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.wlogCore","kind":"def","line":119,"name":"Mathlib.Tactic.wlogCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/WLOG.lean#L119-L136"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/WLOG.html#Lean.MVarId.wlog\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">wlog</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">TSyntaxArray</a> <span class=\"fn\">`ident</span>)</span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Elab.Tactic.TacticM</a> <a href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult\">Mathlib.Tactic.WLOGResult</a></span></div></div>","info":{"doc":"`wlog goal h P xs H` will return two goals: the `hypothesisGoal`, which adds an assumption\n`h : P` to the context of `goal`, and the `reductionGoal`, which requires showing that the case\n`h : ¬ P` can be reduced to the case where `P` holds (typically by symmetry).\n\nIn `reductionGoal`, there will be two additional assumptions:\n- `h : ¬ P`: the assumption that `P` does not hold\n- `H`: which is the statement that in the old context `P` suffices to prove the goal.\n  If `H` is `none`, the name `this` is used.\n\nIf `xs` is `none`, all hypotheses are reverted to produce the reduction goal's hypothesis `H`.\nOtherwise, the `xs` are elaborated to hypotheses in the context of `goal`, and only those\nhypotheses are reverted (and any that depend on them).\n\nIf `h` is `none`, the hypotheses of types `P` and `¬ P` in both branches will be inaccessible. ","docLink":"./Mathlib/Tactic/WLOG.html#Lean.MVarId.wlog","kind":"def","line":56,"name":"Lean.MVarId.wlog","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/WLOG.lean#L56-L117"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult.revertedFVarIds\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">WLOGResult</span>.<span class=\"name\">revertedFVarIds</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult\">WLOGResult</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span></div></div>","info":{"doc":"The array of `FVarId`s that was reverted to produce the reduction hypothesis `H` in\n`reductionGoal`, which are still present in the context of `reductionGoal` (but not necessarily\n`hypothesisGoal`). ","docLink":"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult.revertedFVarIds","kind":"def","line":54,"name":"Mathlib.Tactic.WLOGResult.revertedFVarIds","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/WLOG.lean#L54-L54"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult.hypothesisFVarId\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">WLOGResult</span>.<span class=\"name\">hypothesisFVarId</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult\">WLOGResult</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></div></div>","info":{"doc":"The `FVarId` of the hypothesis `h` in `hypothesisGoal` ","docLink":"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult.hypothesisFVarId","kind":"def","line":50,"name":"Mathlib.Tactic.WLOGResult.hypothesisFVarId","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/WLOG.lean#L50-L50"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult.hypothesisGoal\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">WLOGResult</span>.<span class=\"name\">hypothesisGoal</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult\">WLOGResult</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></div></div>","info":{"doc":"The original goal with the additional assumption `h : P`. ","docLink":"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult.hypothesisGoal","kind":"def","line":48,"name":"Mathlib.Tactic.WLOGResult.hypothesisGoal","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/WLOG.lean#L48-L48"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult.reductionFVarIds\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">WLOGResult</span>.<span class=\"name\">reductionFVarIds</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult\">WLOGResult</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></div></div>","info":{"doc":"The pair `(HFVarId, negHypFVarId)` of `FVarIds` for `reductionGoal`:\n\n* `HFVarId`: `H`, the statement that in the original context `P` suffices to prove the goal.\n* `negHypFVarId`: `h : ¬ P`, the assumption that `P` does not hold\n","docLink":"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult.reductionFVarIds","kind":"def","line":46,"name":"Mathlib.Tactic.WLOGResult.reductionFVarIds","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/WLOG.lean#L46-L46"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult.reductionGoal\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">WLOGResult</span>.<span class=\"name\">reductionGoal</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult\">WLOGResult</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></div></div>","info":{"doc":"The `reductionGoal` requires showing that the case `h : ¬ P` can be reduced to the case where\n`P` holds. It has two additional assumptions in its context:\n\n* `h : ¬ P`: the assumption that `P` does not hold\n* `H`: the statement that in the original context `P` suffices to prove the goal.\n","docLink":"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult.reductionGoal","kind":"def","line":40,"name":"Mathlib.Tactic.WLOGResult.reductionGoal","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/WLOG.lean#L40-L40"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">WLOGResult</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">reductionGoal</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">reductionFVarIds</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hypothesisGoal</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hypothesisFVarId</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">revertedFVarIds</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult\">WLOGResult</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult.mk","kind":"ctor","line":33,"name":"Mathlib.Tactic.WLOGResult.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/WLOG.lean#L33-L33"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">WLOGResult</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The result of running `wlog` on a goal. ","docLink":"./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.WLOGResult","kind":"structure","line":32,"name":"Mathlib.Tactic.WLOGResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/WLOG.lean#L32-L54"}}],"imports":["Init","Lean.Meta.Tactic.Cases","Lean.MetavarContext","Mathlib.Tactic.Core","Mathlib.Tactic.Push"],"instances":[],"name":"Mathlib.Tactic.WLOG"}