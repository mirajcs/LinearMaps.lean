{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.commandInsert_to_additive_translation__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToAdditive</span>.<span class=\"name\">commandInsert_to_additive_translation__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`insert_to_additive_translation mulName addName` inserts the translation `mulName ↦ addName`\ninto the `to_additive` dictionary. This is useful for translating namespaces that don't (yet)\nhave a corresponding translated declaration. ","docLink":"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.commandInsert_to_additive_translation__","kind":"def","line":394,"name":"Mathlib.Tactic.ToAdditive.commandInsert_to_additive_translation__","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToAdditive.lean#L394-L398"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.data\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToAdditive</span>.<span class=\"name\">data</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Translate/Core.html#Mathlib.Tactic.Translate.TranslateData\">Translate.TranslateData</a></div></div>","info":{"doc":"The bundle of environment extensions for `to_additive` ","docLink":"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.data","kind":"def","line":377,"name":"Mathlib.Tactic.ToAdditive.data","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToAdditive.lean#L377-L383"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.abbreviationDict\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToAdditive</span>.<span class=\"name\">abbreviationDict</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#String\">String</a> <a href=\"./Init/Prelude.html#String\">String</a></span></div></div>","info":{"doc":"We need to fix a few abbreviations after applying `nameDict`, i.e. replacing `ZeroLE` by `Nonneg`.\nThis dictionary contains these fixes.\nThe input should contain entries that is in `lowerCamelCase` (e.g. `ltzero`; the initial sequence\nof capital letters should be lower-cased) and the output should be in `UpperCamelCase`\n(e.g. `LTZero`).\nWhen applying the dictionary, we lower-case the output if the input was also given in lower-case.\n","docLink":"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.abbreviationDict","kind":"def","line":330,"name":"Mathlib.Tactic.ToAdditive.abbreviationDict","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToAdditive.lean#L330-L375"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.nameDict\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToAdditive</span>.<span class=\"name\">nameDict</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#String\">String</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a>)</span></span></div></div>","info":{"doc":"Dictionary used by `guessName` to autogenerate names.\nThis only transforms single name components, unlike `abbreviationDict`.\n\nNote: `guessName` capitalizes the output according to the capitalization of the input.\nIn order for this to work, the input should always start with a lower case letter, and the output\nshould always start with an upper case letter.\n","docLink":"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.nameDict","kind":"def","line":286,"name":"Mathlib.Tactic.ToAdditive.nameDict","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToAdditive.lean#L286-L328"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.translations\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToAdditive</span>.<span class=\"name\">translations</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>","info":{"doc":"Maps multiplicative names to their additive counterparts. ","docLink":"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.translations","kind":"opaque","line":283,"name":"Mathlib.Tactic.ToAdditive.translations","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToAdditive.lean#L283-L284"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.doTranslateAttr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToAdditive</span>.<span class=\"name\">doTranslateAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"The global `do_translate`/`dont_translate` attributes specify whether operations on\na given type should be translated. `dont_translate` can be used for types that are translated,\nsuch as `MonoidAlgebra` -> `AddMonoidAlgebra`, or for fixed types, such as `Fin n`/`ZMod n`.\n`do_translate` is for types without arguments, like `Unit` and `Empty`, where the structure on it\ncan be translated.\n\nNote: The name generation is not aware of `dont_translate`, so if some part of a lemma is not\n  translated thanks to this, you generally have to specify the translated name manually.\n","docLink":"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.doTranslateAttr","kind":"opaque","line":268,"name":"Mathlib.Tactic.ToAdditive.doTranslateAttr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToAdditive.lean#L268-L269"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.argInfoAttr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToAdditive</span>.<span class=\"name\">argInfoAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <a href=\"./Mathlib/Tactic/Translate/Core.html#Mathlib.Tactic.Translate.ArgInfo\">Translate.ArgInfo</a></span></div></div>","info":{"doc":"`argInfoAttr` stores the declarations that need some extra information to be translated. ","docLink":"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.argInfoAttr","kind":"opaque","line":265,"name":"Mathlib.Tactic.ToAdditive.argInfoAttr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToAdditive.lean#L265-L266"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.ignoreArgsAttr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToAdditive</span>.<span class=\"name\">ignoreArgsAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span></div></div>","info":{"doc":"An attribute that tells that certain arguments of this definition are not\ninvolved when translating.\nThis helps the translation heuristic by also transforming definitions if `ℕ` or another\nfixed type occurs as one of these arguments. ","docLink":"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.ignoreArgsAttr","kind":"opaque","line":253,"name":"Mathlib.Tactic.ToAdditive.ignoreArgsAttr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToAdditive.lean#L253-L263"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.attrTo_additive?_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToAdditive</span>.<span class=\"name\">attrTo_additive?_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The attribute `to_additive` can be used to automatically transport theorems\nand definitions (but not inductive types and structures) from a multiplicative\ntheory to an additive theory.\n\nTo use this attribute, just write:\n\n```\n@[to_additive]\ntheorem mul_comm' {α} [CommSemigroup α] (x y : α) : x * y = y * x := mul_comm x y\n```\n\nThis code will generate a theorem named `add_comm'`. It is also\npossible to manually specify the name of the new declaration:\n\n```\n@[to_additive add_foo]\ntheorem foo := sorry\n```\n\nAn existing documentation string will _not_ be automatically used, so if the theorem or definition\nhas a doc string, a doc string for the additive version should be passed explicitly to\n`to_additive`.\n\n```\n/-- Multiplication is commutative -/\n@[to_additive /-- Addition is commutative -/]\ntheorem mul_comm' {α} [CommSemigroup α] (x y : α) : x * y = y * x := CommSemigroup.mul_comm\n```\n\nThe transport tries to do the right thing in most cases using several\nheuristics described below.  However, in some cases it fails, and\nrequires manual intervention.\n\nUse the `(reorder := ...)` syntax to reorder the arguments in the generated additive declaration.\nThis is specified using cycle notation. For example `(reorder := α β, 5 6)` swaps the arguments\n`α` and `β` with each other and the fifth and the sixth argument and `(reorder := 3 4 5)` will move\nthe fifth argument before the third argument. This is mostly useful to translate declarations using\n`Pow` to those using `SMul`.\n\nUse the `to_additive existing` syntax to use an existing additive declaration, instead of\nautomatically generating it. This attempts to autogenerate the `(reorder := ...)` argument.\n\nUse the `(attr := ...)` syntax to apply attributes to both the multiplicative and the additive\nversion:\n\n```\n@[to_additive (attr := simp)] lemma mul_one' {G : Type*} [Group G] (x : G) : x * 1 = x := mul_one x\n```\n\nFor `simps` this also ensures that some generated lemmas are added to the additive dictionary.\n`@[to_additive (attr := to_additive)]` is a special case, where the `to_additive`\nattribute is added to the generated lemma only, to additivize it again.\nThis is useful for lemmas about `Pow` to generate both lemmas about `SMul` and `VAdd`. Example:\n```\n@[to_additive (attr := to_additive VAdd_lemma, simp) SMul_lemma]\nlemma Pow_lemma ... :=\n```\nIn the above example, the `simp` is added to all 3 lemmas. All other options to `to_additive`\n(like the generated name or `(reorder := ...)`) are not passed down,\nand can be given manually to each individual `to_additive` call.\n\n## Implementation notes\n\nThe transport process generally works by taking all the names of\nidentifiers appearing in the name, type, and body of a declaration and\ncreating a new declaration by mapping those names to additive versions\nusing a simple string-based dictionary and also using all declarations\nthat have previously been labeled with `to_additive`. The dictionary is `ToAdditive.nameDict`\nand can be found in the `Tactic.ToAdditive.GuessName` file. If you introduce a new name which\nshould be translated by `to_additive` you should add the translation to this dictionary.\n\nIn the `mul_comm'` example above, `to_additive` maps:\n* `mul_comm'` to `add_comm'`,\n* `CommSemigroup` to `AddCommSemigroup`,\n* `x * y` to `x + y` and `y * x` to `y + x`, and\n* `CommSemigroup.mul_comm'` to `AddCommSemigroup.add_comm'`.\n\n### Heuristics\n\n`to_additive` uses heuristics to determine whether a particular identifier has to be\nmapped to its additive version. The basic heuristic is\n\n* Only map an identifier to its additive version if its first argument doesn't\n  contain any unapplied identifiers.\n\nExamples:\n* `@Mul.mul Nat n m` (i.e. `(n * m : Nat)`) will not change to `+`, since its\n  first argument is `Nat`, an identifier not applied to any arguments.\n* `@Mul.mul (α × β) x y` will change to `+`. It's first argument contains only the identifier\n  `Prod`, but this is applied to arguments, `α` and `β`.\n* `@Mul.mul (α × Int) x y` will not change to `+`, since its first argument contains `Int`.\n\nThe reasoning behind the heuristic is that the first argument is the type which is \"additivized\",\nand this usually doesn't make sense if this is on a fixed type.\n\nThere are some exceptions to this heuristic:\n\n* Identifiers that have the `@[to_additive]` attribute are ignored.\n  For example, multiplication in `↥Semigroup` is replaced by addition in `↥AddSemigroup`.\n  You can turn this behavior off by *also* adding the `@[to_additive_dont_translate]` attribute.\n* If an identifier `d` has attribute `@[to_additive (relevant_arg := α)]` then the argument\n  `α` is checked for a fixed type, instead of checking the first argument.\n  `@[to_additive]` will automatically add the attribute `(relevant_arg := α)` to a\n  declaration when the first argument has no multiplicative type-class, but argument `α` does.\n* If an identifier has attribute `@[to_additive_ignore_args n1 n2 ...]` then all the arguments in\n  positions `n1`, `n2`, ... will not be checked for unapplied identifiers (start counting from 1).\n  For example, `ContMDiffMap` has attribute `@[to_additive_ignore_args 21]`, which means\n  that its 21st argument `(n : WithTop ℕ)` can contain `ℕ`\n  (usually in the form `Top.top ℕ ...`) and still be additivized.\n  So `@Mul.mul (C^∞⟮I, N; I', G⟯) _ f g` will be additivized.\n\n### Troubleshooting\n\nIf `@[to_additive]` fails because the additive declaration raises a type mismatch, there are\nvarious things you can try.\nThe first thing to do is to figure out what `@[to_additive]` did wrong by looking at the type\nmismatch error.\n\n* Option 1: The most common case is that it didn't additivize a declaration that should be\n  additivized. This happened because the heuristic applied, and the first argument contains a\n  fixed type, like `ℕ` or `ℝ`. However, the heuristic misfires on some other declarations.\n  Solutions:\n  * First figure out what the fixed type is in the first argument of the declaration that didn't\n    get additivized. Note that this fixed type can occur in implicit arguments. If manually finding\n    it is hard, you can run `set_option trace.translate_detail true` and search the output for the\n    fragment \"contains the fixed type\" to find what the fixed type is.\n  * If the fixed type has an additive counterpart (like `↥Semigroup`), give it the `@[to_additive]`\n    attribute.\n  * If the fixed type has nothing to do with algebraic operations (like `TopCat`), add the attribute\n    `@[to_additive_do_translate]` to the fixed type `Foo`.\n  * If the fixed type occurs inside the `k`-th argument of a declaration `d`, and the\n    `k`-th argument is not connected to the multiplicative structure on `d`, consider adding\n    attribute `[to_additive_ignore_args k]` to `d`.\n    Example: `ContMDiffMap` ignores the argument `(n : WithTop ℕ)`\n  * If none of the arguments have a multiplicative structure, then the heuristic should not apply at\n    all. This can be achieved with the option `(relevant_arg := _)`.\n* Option 2: It additivized a declaration `d` that should remain multiplicative. Solution:\n  * Make sure the first argument of `d` is a type with a multiplicative structure. If not, can you\n    reorder the (implicit) arguments of `d` so that the first argument becomes a type with a\n    multiplicative structure (and not some indexing type)?\n    The reason is that `@[to_additive]` doesn't additivize declarations if their first argument\n    contains fixed types like `ℕ` or `ℝ`. See section Heuristics.\n    If the first argument is not the argument with a multiplicative type-class, `@[to_additive]`\n    should have automatically added the attribute `(relevant_arg := ...)` to the declaration.\n    You can test this by running the following (where `d` is the full name of the declaration):\n    ```\n      open Lean in run_cmd logInfo m!\"{ToAdditive.relevantArgAttr.find? (← getEnv) `d}\"\n    ```\n    The expected output is `n` where the `n`-th (0-indexed) argument of `d` is a type (family)\n    with a multiplicative structure on it. `none` means `0`.\n    If you get a different output (or a failure), you could add the attribute\n    `@[to_additive (relevant_arg := n)]` manually, where `n` is an (1-indexed) argument with a\n    multiplicative structure.\n* Option 3: Arguments / universe levels are incorrectly ordered in the additive version.\n  This likely only happens when the multiplicative declaration involves `pow`/`^`. Solutions:\n  * Ensure that the order of arguments of all relevant declarations are the same for the\n    multiplicative and additive version. This might mean that arguments have an \"unnatural\" order\n    (e.g. `Monoid.npow n x` corresponds to `x ^ n`, but it is convenient that `Monoid.npow` has this\n    argument order, since it matches `AddMonoid.nsmul n x`.\n  * If this is not possible, add `(reorder := ...)` argument to `to_additive`.\n\nIf neither of these solutions work, and `to_additive` is unable to automatically generate the\nadditive version of a declaration, manually write and prove the additive version.\nOften the proof of a lemma/theorem can just be the multiplicative version of the lemma applied to\n`multiplicative G`.\nAfterwards, apply the attribute manually:\n\n```\nattribute [to_additive foo_add_bar] foo_bar\n```\n\nThis will allow future uses of `to_additive` to recognize that\n`foo_bar` should be replaced with `foo_add_bar`.\n\n### Handling of hidden definitions\n\nBefore transporting the “main” declaration `src`, `to_additive` first\nscans its type and value for names starting with `src`, and transports\nthem. This includes auxiliary definitions like `src._match_1`\n\nIn addition to transporting the “main” declaration, `to_additive` transports\nits equational lemmas and tags them as equational lemmas for the new declaration.\n\n### Structure fields and constructors\n\nIf `src` is a structure, then the additive version has to be already written manually.\nIn this case `to_additive` adds all structure fields to its mapping.\n\n### Name generation\n\n* If `@[to_additive]` is called without a `name` argument, then the\n  new name is autogenerated.  First, it takes the longest prefix of\n  the source name that is already known to `to_additive`, and replaces\n  this prefix with its additive counterpart. Second, it takes the last\n  part of the name (i.e., after the last dot), and replaces common\n  name parts (“mul”, “one”, “inv”, “prod”) with their additive versions.\n\n* You can add a namespace translation using the following command:\n  ```\n  insert_to_additive_translation QuotientGroup QuotientAddGroup\n  ```\n  Later uses of `@[to_additive]` on declarations in the `QuotientGroup`\n  namespace will be created in the `QuotientAddGroup` namespace.\n  This is not necessary if there is already a declaration with name `QuotientGroup`.\n\n* If `@[to_additive]` is called with a `name` argument `new_name`\n  /without a dot/, then `to_additive` updates the prefix as described\n  above, then replaces the last part of the name with `new_name`.\n\n* If `@[to_additive]` is called with a `name` argument\n  `NewNamespace.new_name` /with a dot/, then `to_additive` uses this\n  new name as is.\n\nAs a safety check, in the first case `to_additive` double checks\nthat the new name differs from the original one. ","docLink":"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.attrTo_additive?_","kind":"def","line":250,"name":"Mathlib.Tactic.ToAdditive.attrTo_additive?_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToAdditive.lean#L250-L250"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.to_additive\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToAdditive</span>.<span class=\"name\">to_additive</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The attribute `to_additive` can be used to automatically transport theorems\nand definitions (but not inductive types and structures) from a multiplicative\ntheory to an additive theory.\n\nTo use this attribute, just write:\n\n```\n@[to_additive]\ntheorem mul_comm' {α} [CommSemigroup α] (x y : α) : x * y = y * x := mul_comm x y\n```\n\nThis code will generate a theorem named `add_comm'`. It is also\npossible to manually specify the name of the new declaration:\n\n```\n@[to_additive add_foo]\ntheorem foo := sorry\n```\n\nAn existing documentation string will _not_ be automatically used, so if the theorem or definition\nhas a doc string, a doc string for the additive version should be passed explicitly to\n`to_additive`.\n\n```\n/-- Multiplication is commutative -/\n@[to_additive /-- Addition is commutative -/]\ntheorem mul_comm' {α} [CommSemigroup α] (x y : α) : x * y = y * x := CommSemigroup.mul_comm\n```\n\nThe transport tries to do the right thing in most cases using several\nheuristics described below.  However, in some cases it fails, and\nrequires manual intervention.\n\nUse the `(reorder := ...)` syntax to reorder the arguments in the generated additive declaration.\nThis is specified using cycle notation. For example `(reorder := α β, 5 6)` swaps the arguments\n`α` and `β` with each other and the fifth and the sixth argument and `(reorder := 3 4 5)` will move\nthe fifth argument before the third argument. This is mostly useful to translate declarations using\n`Pow` to those using `SMul`.\n\nUse the `to_additive existing` syntax to use an existing additive declaration, instead of\nautomatically generating it. This attempts to autogenerate the `(reorder := ...)` argument.\n\nUse the `(attr := ...)` syntax to apply attributes to both the multiplicative and the additive\nversion:\n\n```\n@[to_additive (attr := simp)] lemma mul_one' {G : Type*} [Group G] (x : G) : x * 1 = x := mul_one x\n```\n\nFor `simps` this also ensures that some generated lemmas are added to the additive dictionary.\n`@[to_additive (attr := to_additive)]` is a special case, where the `to_additive`\nattribute is added to the generated lemma only, to additivize it again.\nThis is useful for lemmas about `Pow` to generate both lemmas about `SMul` and `VAdd`. Example:\n```\n@[to_additive (attr := to_additive VAdd_lemma, simp) SMul_lemma]\nlemma Pow_lemma ... :=\n```\nIn the above example, the `simp` is added to all 3 lemmas. All other options to `to_additive`\n(like the generated name or `(reorder := ...)`) are not passed down,\nand can be given manually to each individual `to_additive` call.\n\n## Implementation notes\n\nThe transport process generally works by taking all the names of\nidentifiers appearing in the name, type, and body of a declaration and\ncreating a new declaration by mapping those names to additive versions\nusing a simple string-based dictionary and also using all declarations\nthat have previously been labeled with `to_additive`. The dictionary is `ToAdditive.nameDict`\nand can be found in the `Tactic.ToAdditive.GuessName` file. If you introduce a new name which\nshould be translated by `to_additive` you should add the translation to this dictionary.\n\nIn the `mul_comm'` example above, `to_additive` maps:\n* `mul_comm'` to `add_comm'`,\n* `CommSemigroup` to `AddCommSemigroup`,\n* `x * y` to `x + y` and `y * x` to `y + x`, and\n* `CommSemigroup.mul_comm'` to `AddCommSemigroup.add_comm'`.\n\n### Heuristics\n\n`to_additive` uses heuristics to determine whether a particular identifier has to be\nmapped to its additive version. The basic heuristic is\n\n* Only map an identifier to its additive version if its first argument doesn't\n  contain any unapplied identifiers.\n\nExamples:\n* `@Mul.mul Nat n m` (i.e. `(n * m : Nat)`) will not change to `+`, since its\n  first argument is `Nat`, an identifier not applied to any arguments.\n* `@Mul.mul (α × β) x y` will change to `+`. It's first argument contains only the identifier\n  `Prod`, but this is applied to arguments, `α` and `β`.\n* `@Mul.mul (α × Int) x y` will not change to `+`, since its first argument contains `Int`.\n\nThe reasoning behind the heuristic is that the first argument is the type which is \"additivized\",\nand this usually doesn't make sense if this is on a fixed type.\n\nThere are some exceptions to this heuristic:\n\n* Identifiers that have the `@[to_additive]` attribute are ignored.\n  For example, multiplication in `↥Semigroup` is replaced by addition in `↥AddSemigroup`.\n  You can turn this behavior off by *also* adding the `@[to_additive_dont_translate]` attribute.\n* If an identifier `d` has attribute `@[to_additive (relevant_arg := α)]` then the argument\n  `α` is checked for a fixed type, instead of checking the first argument.\n  `@[to_additive]` will automatically add the attribute `(relevant_arg := α)` to a\n  declaration when the first argument has no multiplicative type-class, but argument `α` does.\n* If an identifier has attribute `@[to_additive_ignore_args n1 n2 ...]` then all the arguments in\n  positions `n1`, `n2`, ... will not be checked for unapplied identifiers (start counting from 1).\n  For example, `ContMDiffMap` has attribute `@[to_additive_ignore_args 21]`, which means\n  that its 21st argument `(n : WithTop ℕ)` can contain `ℕ`\n  (usually in the form `Top.top ℕ ...`) and still be additivized.\n  So `@Mul.mul (C^∞⟮I, N; I', G⟯) _ f g` will be additivized.\n\n### Troubleshooting\n\nIf `@[to_additive]` fails because the additive declaration raises a type mismatch, there are\nvarious things you can try.\nThe first thing to do is to figure out what `@[to_additive]` did wrong by looking at the type\nmismatch error.\n\n* Option 1: The most common case is that it didn't additivize a declaration that should be\n  additivized. This happened because the heuristic applied, and the first argument contains a\n  fixed type, like `ℕ` or `ℝ`. However, the heuristic misfires on some other declarations.\n  Solutions:\n  * First figure out what the fixed type is in the first argument of the declaration that didn't\n    get additivized. Note that this fixed type can occur in implicit arguments. If manually finding\n    it is hard, you can run `set_option trace.translate_detail true` and search the output for the\n    fragment \"contains the fixed type\" to find what the fixed type is.\n  * If the fixed type has an additive counterpart (like `↥Semigroup`), give it the `@[to_additive]`\n    attribute.\n  * If the fixed type has nothing to do with algebraic operations (like `TopCat`), add the attribute\n    `@[to_additive_do_translate]` to the fixed type `Foo`.\n  * If the fixed type occurs inside the `k`-th argument of a declaration `d`, and the\n    `k`-th argument is not connected to the multiplicative structure on `d`, consider adding\n    attribute `[to_additive_ignore_args k]` to `d`.\n    Example: `ContMDiffMap` ignores the argument `(n : WithTop ℕ)`\n  * If none of the arguments have a multiplicative structure, then the heuristic should not apply at\n    all. This can be achieved with the option `(relevant_arg := _)`.\n* Option 2: It additivized a declaration `d` that should remain multiplicative. Solution:\n  * Make sure the first argument of `d` is a type with a multiplicative structure. If not, can you\n    reorder the (implicit) arguments of `d` so that the first argument becomes a type with a\n    multiplicative structure (and not some indexing type)?\n    The reason is that `@[to_additive]` doesn't additivize declarations if their first argument\n    contains fixed types like `ℕ` or `ℝ`. See section Heuristics.\n    If the first argument is not the argument with a multiplicative type-class, `@[to_additive]`\n    should have automatically added the attribute `(relevant_arg := ...)` to the declaration.\n    You can test this by running the following (where `d` is the full name of the declaration):\n    ```\n      open Lean in run_cmd logInfo m!\"{ToAdditive.relevantArgAttr.find? (← getEnv) `d}\"\n    ```\n    The expected output is `n` where the `n`-th (0-indexed) argument of `d` is a type (family)\n    with a multiplicative structure on it. `none` means `0`.\n    If you get a different output (or a failure), you could add the attribute\n    `@[to_additive (relevant_arg := n)]` manually, where `n` is an (1-indexed) argument with a\n    multiplicative structure.\n* Option 3: Arguments / universe levels are incorrectly ordered in the additive version.\n  This likely only happens when the multiplicative declaration involves `pow`/`^`. Solutions:\n  * Ensure that the order of arguments of all relevant declarations are the same for the\n    multiplicative and additive version. This might mean that arguments have an \"unnatural\" order\n    (e.g. `Monoid.npow n x` corresponds to `x ^ n`, but it is convenient that `Monoid.npow` has this\n    argument order, since it matches `AddMonoid.nsmul n x`.\n  * If this is not possible, add `(reorder := ...)` argument to `to_additive`.\n\nIf neither of these solutions work, and `to_additive` is unable to automatically generate the\nadditive version of a declaration, manually write and prove the additive version.\nOften the proof of a lemma/theorem can just be the multiplicative version of the lemma applied to\n`multiplicative G`.\nAfterwards, apply the attribute manually:\n\n```\nattribute [to_additive foo_add_bar] foo_bar\n```\n\nThis will allow future uses of `to_additive` to recognize that\n`foo_bar` should be replaced with `foo_add_bar`.\n\n### Handling of hidden definitions\n\nBefore transporting the “main” declaration `src`, `to_additive` first\nscans its type and value for names starting with `src`, and transports\nthem. This includes auxiliary definitions like `src._match_1`\n\nIn addition to transporting the “main” declaration, `to_additive` transports\nits equational lemmas and tags them as equational lemmas for the new declaration.\n\n### Structure fields and constructors\n\nIf `src` is a structure, then the additive version has to be already written manually.\nIn this case `to_additive` adds all structure fields to its mapping.\n\n### Name generation\n\n* If `@[to_additive]` is called without a `name` argument, then the\n  new name is autogenerated.  First, it takes the longest prefix of\n  the source name that is already known to `to_additive`, and replaces\n  this prefix with its additive counterpart. Second, it takes the last\n  part of the name (i.e., after the last dot), and replaces common\n  name parts (“mul”, “one”, “inv”, “prod”) with their additive versions.\n\n* You can add a namespace translation using the following command:\n  ```\n  insert_to_additive_translation QuotientGroup QuotientAddGroup\n  ```\n  Later uses of `@[to_additive]` on declarations in the `QuotientGroup`\n  namespace will be created in the `QuotientAddGroup` namespace.\n  This is not necessary if there is already a declaration with name `QuotientGroup`.\n\n* If `@[to_additive]` is called with a `name` argument `new_name`\n  /without a dot/, then `to_additive` updates the prefix as described\n  above, then replaces the last part of the name with `new_name`.\n\n* If `@[to_additive]` is called with a `name` argument\n  `NewNamespace.new_name` /with a dot/, then `to_additive` uses this\n  new name as is.\n\nAs a safety check, in the first case `to_additive` double checks\nthat the new name differs from the original one. ","docLink":"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.to_additive","kind":"def","line":32,"name":"Mathlib.Tactic.ToAdditive.to_additive","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToAdditive.lean#L32-L247"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.to_additive_dont_translate\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToAdditive</span>.<span class=\"name\">to_additive_dont_translate</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The global `do_translate`/`dont_translate` attributes specify whether operations on\na given type should be translated. `dont_translate` can be used for types that are translated,\nsuch as `MonoidAlgebra` -> `AddMonoidAlgebra`, or for fixed types, such as `Fin n`/`ZMod n`.\n`do_translate` is for types without arguments, like `Unit` and `Empty`, where the structure on it\ncan be translated.\n\nNote: The name generation is not aware of `dont_translate`, so if some part of a lemma is not\n  translated thanks to this, you generally have to specify the translated name manually.\n","docLink":"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.to_additive_dont_translate","kind":"def","line":29,"name":"Mathlib.Tactic.ToAdditive.to_additive_dont_translate","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToAdditive.lean#L29-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.to_additive_do_translate\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToAdditive</span>.<span class=\"name\">to_additive_do_translate</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The global `do_translate`/`dont_translate` attributes specify whether operations on\na given type should be translated. `dont_translate` can be used for types that are translated,\nsuch as `MonoidAlgebra` -> `AddMonoidAlgebra`, or for fixed types, such as `Fin n`/`ZMod n`.\n`do_translate` is for types without arguments, like `Unit` and `Empty`, where the structure on it\ncan be translated.\n\nNote: The name generation is not aware of `dont_translate`, so if some part of a lemma is not\n  translated thanks to this, you generally have to specify the translated name manually.\n","docLink":"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.to_additive_do_translate","kind":"def","line":26,"name":"Mathlib.Tactic.ToAdditive.to_additive_do_translate","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToAdditive.lean#L26-L27"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.to_additive_ignore_args\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToAdditive</span>.<span class=\"name\">to_additive_ignore_args</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"An attribute that tells that certain arguments of this definition are not\ninvolved when translating.\nThis helps the translation heuristic by also transforming definitions if `ℕ` or another\nfixed type occurs as one of these arguments. ","docLink":"./Mathlib/Tactic/Translate/ToAdditive.html#Mathlib.Tactic.ToAdditive.to_additive_ignore_args","kind":"def","line":23,"name":"Mathlib.Tactic.ToAdditive.to_additive_ignore_args","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToAdditive.lean#L23-L24"}}],"imports":["Init","Mathlib.Tactic.Translate.Core"],"instances":[],"name":"Mathlib.Tactic.Translate.ToAdditive"}