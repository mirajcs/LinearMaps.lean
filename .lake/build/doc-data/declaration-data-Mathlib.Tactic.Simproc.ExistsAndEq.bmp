{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.existsAndEq\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">existsAndEq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"Triggers at goals of the form `∃ a, body` and checks if `body` allows a single value `a'`\nfor `a`. If so, replaces `a` with `a'` and removes quantifier.\n\nIt looks through nested quantifiers and conjunctions searching for a `a = a'`\nor `a' = a` subexpression. ","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.existsAndEq","kind":"def","line":415,"name":"ExistsAndEq.existsAndEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L415-L434"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.mkBeforeToAfter\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">mkBeforeToAfter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$α»</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">P'</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a'</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newBody</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvars</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.VarQ\">VarQ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">path</span> : <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.Path\">Path</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">(<a href=\"./Init/Core.html#Exists\">∃</a> <a href=\"./Init/Core.html#Exists\">(</a><span class=\"fn\">a</span> <a href=\"./Init/Core.html#Exists\">:</a> <span class=\"fn\">«$α»</span><a href=\"./Init/Core.html#Exists\">)</a><a href=\"./Init/Core.html#Exists\">,</a> <span class=\"fn\"><span class=\"fn\">«$p»</span> <span class=\"fn\">a</span></span>) → <span class=\"fn\">«$P'»</span></span>)</span></span></div></div>","info":{"doc":"Generates a proof of `∃ a, p a → P'`. We assume that `fvars = [f₁, ..., fₙ]` are free variables\nand `P' = ∃ f₁ ... fₙ, newBody`, and `path` leads to `a = a'` in `∃ a, p a`.\n\nThe proof follows the following structure:\n```\nexample {α β : Type} (f : β → α) {p : α → Prop} :\n    (∃ a, p a ∧ ∃ b, a = f b) → (∃ b, p (f b) ∧ f b = f b) := by\n  -- withLocalDeclQ\n  intro h\n  refine h.elim (fun a ha ↦ ?_)\n  -- withExistsElimAlongPath: following the path we unpack all existential quantifiers.\n  -- at the end `hs = [hb]`.\n  have h' := ha\n  replace h' := h'.right\n  refine Exists.elim h' (fun b hb ↦ ?_)\n  replace h' := hb\n  have h_eq := h'\n  clear h'\n  -- go: we traverse `P` and `goal` simultaneously\n  have h' := ha\n  refine Exists.intro b ?_\n  refine And.intro ?_ ?_\n  -- outside the path goal must concide with `h_eq ▸ h'`\n  · replace h' := h'.left\n    exact Eq.mp (congrArg (fun t ↦ p t) h_eq) h'\n  -- inside the path:\n  · replace h' := h'.right\n    -- when `h'` starts with existential quantifier we replace it with next hypothesis from `hs`.\n    replace h' := hb\n    -- at the end the goal must be `x' = x'`.\n    rfl\n``` ","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.mkBeforeToAfter","kind":"def","line":322,"name":"ExistsAndEq.mkBeforeToAfter","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L322-L413"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.withNestedExistsIntro\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">withNestedExistsIntro</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">P </span><span class=\"fn\">body</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">exs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.VarQ\">VarQ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">act</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$body»</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$P»</span>)</span></span></div></div>","info":{"doc":"When `P = ∃ f₁ ... fₙ, body`, where `exs = [f₁, ..., fₙ]`, this function takes\n`act : body` and proves `P` using `Exists.intro`.\n\nExample:\n```\nexs = []: act\nexs = [b]:\n  P := ∃ b, body\n  Exists.intro b act\nexs = [b, c]:\n  P := ∃ b c, body\n  Exists.intro b (Exists.intro c act)\n...\n``` ","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.withNestedExistsIntro","kind":"def","line":295,"name":"ExistsAndEq.withNestedExistsIntro","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L295-L320"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.withExistsElimAlongPath\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">withExistsElimAlongPath</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">P </span><span class=\"fn\">goal</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">Q(<span class=\"fn\">«$P»</span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">exs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.VarQ\">VarQ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">path</span> : <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.Path\">Path</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">act</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$a'»</span>)</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.HypQ\">HypQ</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$goal»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$goal»</span>)</span></span></div></div>","info":{"doc":"Given `act : (a = a') → hb₁ → hb₂ → ... → hbₙ → goal` where `hb₁, ..., hbₙ` are hypotheses\nobtained when unpacking existential quantifiers with variables from `exs`, it proves `goal` using\n`Exists.elim`. We use this to prove implication in the forward direction. ","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.withExistsElimAlongPath","kind":"def","line":286,"name":"ExistsAndEq.withExistsElimAlongPath","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L286-L293"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.withExistsElimAlongPathImp\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">withExistsElimAlongPathImp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">P </span><span class=\"fn\">goal</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">Q(<span class=\"fn\">«$P»</span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">exs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.VarQ\">VarQ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">path</span> : <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.Path\">Path</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.HypQ\">HypQ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">act</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$a'»</span>)</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.HypQ\">HypQ</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$goal»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$goal»</span>)</span></span></div></div>","info":{"doc":"Recursive implementation for `withExistsElimAlongPath`. ","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.withExistsElimAlongPathImp","kind":"opaque","line":245,"name":"ExistsAndEq.withExistsElimAlongPathImp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L245-L284"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.mkAfterToBefore\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">mkAfterToBefore</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$α»</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">P'</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a'</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newBody</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvars</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.VarQ\">VarQ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">path</span> : <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.Path\">Path</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$P'»</span> → <a href=\"./Init/Core.html#Exists\">∃</a> <a href=\"./Init/Core.html#Exists\">(</a><span class=\"fn\">a</span> <a href=\"./Init/Core.html#Exists\">:</a> <span class=\"fn\">«$α»</span><a href=\"./Init/Core.html#Exists\">)</a><a href=\"./Init/Core.html#Exists\">,</a> <span class=\"fn\"><span class=\"fn\">«$p»</span> <span class=\"fn\">a</span></span></span>)</span></span></div></div>","info":{"doc":"Generates a proof of `P' → ∃ a, p a`. We assume that `fvars = [f₁, ..., fₙ]` are free variables\nand `P' = ∃ f₁ ... fₙ, newBody`, and `path` leads to `a = a'` in `∃ a, p a`.\n\nThe proof follows the following structure:\n```\nexample {α β : Type} (f : β → α) {p : α → Prop} :\n    (∃ b, p (f b) ∧ f b = f b) → (∃ a, p a ∧ ∃ b, a = f b) := by\n  -- withLocalDeclQ\n  intro h\n  -- withNestedExistsElim : we unpack all quantifiers in `P` to get `h : newBody`.\n  refine h.elim (fun b h ↦ ?_)\n  -- use `a'` in the leading existential quantifier\n  refine Exists.intro (f b) ?_\n  -- then we traverse `newBody` and goal simultaneously\n  refine And.intro ?_ ?_\n  -- at branches outside the path `h` must concide with goal\n  · replace h := h.left\n    exact h\n  -- inside path we substitute variables from `fvars` into existential quantifiers.\n  · replace h := h.right\n    refine Exists.intro b ?_\n    -- at the end the goal must be `x' = x'`.\n    rfl\n``` ","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.mkAfterToBefore","kind":"def","line":177,"name":"ExistsAndEq.mkAfterToBefore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L177-L243"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.withNestedExistsElim\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">withNestedExistsElim</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">P </span><span class=\"fn\">body </span><span class=\"fn\">goal</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">exs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.VarQ\">VarQ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">Q(<span class=\"fn\">«$P»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">act</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$body»</span>)</span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$goal»</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$goal»</span>)</span></span></div></div>","info":{"doc":"When `P = ∃ f₁ ... fₙ, body`, where `exs = [f₁, ..., fₙ]`, this function takes\n`act : body → goal` and proves `P → goal` using `Exists.elim`.\n\nExample:\n```\nexs = []: act h\nexs = [b]:\n  P := ∃ b, body\n  Exists.elim h (fun b hb ↦ act hb)\nexs = [b, c]:\n  P := ∃ b c, body\n  Exists.elim h (fun b hb ↦\n    Exists.elim hb (fun c hc ↦ act hc)\n  )\n...\n``` ","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.withNestedExistsElim","kind":"def","line":145,"name":"ExistsAndEq.withNestedExistsElim","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L145-L175"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.findEq\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">findEq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">path</span> : <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.Path\">Path</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.VarQ\">VarQ</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/LocalContext.html#Lean.LocalContext\">Lean.LocalContext</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></div></div>","info":{"doc":"Given `P : Prop` and `a : α`, traverses the expression `P` to find a subexpression of\nthe form `a = a'` or `a' = a` for some `a'`. It branches at each `And` and walks into\nexistential quantifiers.\n\nReturns a tuple `(fvars, lctx, P', a')`, where:\n* `fvars` is a list of all variables bound by existential quantifiers along the path.\n* `lctx` is the local context containing all these free variables.\n* `P'` is `P` with all existential quantifiers along the path removed, and corresponding bound\n  variables replaced with `fvars`.\n* `a'` is the expression found that must be equal to `a`.\n  It may contain free variables from `fvars`. ","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.findEq","kind":"def","line":103,"name":"ExistsAndEq.findEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L103-L143"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.findEqPath\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">findEqPath</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.Path\">Path</a>)</span></span></div></div>","info":{"doc":"Finds a `Path` for `findEq`. It leads to a subexpression `a = a'` or `a' = a`, where\n`a'` doesn't contain the free variable `a`.\nThis is a fast version that quickly returns `none` when the simproc\nis not applicable. ","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.findEqPath","kind":"opaque","line":77,"name":"ExistsAndEq.findEqPath","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L77-L101"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.mkNestedExists\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">mkNestedExists</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvars</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.VarQ\">VarQ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">body</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span></span></div></div>","info":{"doc":"Constructs `∃ f₁ f₂ ... fₙ, body`, where `[f₁, ..., fₙ] = fvars`. ","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.mkNestedExists","kind":"def","line":67,"name":"ExistsAndEq.mkNestedExists","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L67-L75"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.instInhabitedHypQ\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">instInhabitedHypQ</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.HypQ\">HypQ</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.instInhabitedHypQ","kind":"instance","line":55,"name":"ExistsAndEq.instInhabitedHypQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L55-L56"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.HypQ\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">HypQ</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Qq-fied version of `Expr` proving some `P : Prop`. ","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.HypQ","kind":"def","line":52,"name":"ExistsAndEq.HypQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L52-L53"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.instInhabitedVarQ\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">instInhabitedVarQ</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.VarQ\">VarQ</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.instInhabitedVarQ","kind":"instance","line":49,"name":"ExistsAndEq.instInhabitedVarQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L49-L50"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.VarQ\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">VarQ</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Qq-fied version of `Expr`. Here, we use it to store free variables introduced when unpacking\nexistential quantifiers. ","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.VarQ","kind":"def","line":45,"name":"ExistsAndEq.VarQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L45-L47"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.Path\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">Path</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Type for storing the path in the body expression leading to `a = a'`. We store only the chosen\ndirections at each `And` node because there is no branching at `Exists` nodes, and `Exists` nodes\nwill be removed from the body. ","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.Path","kind":"def","line":40,"name":"ExistsAndEq.Path","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L40-L43"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.instInhabitedGoTo.default\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">instInhabitedGoTo</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.GoTo\">GoTo</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.instInhabitedGoTo.default","kind":"def","line":38,"name":"ExistsAndEq.instInhabitedGoTo.default","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L38-L38"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.instInhabitedGoTo\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">instInhabitedGoTo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.GoTo\">GoTo</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.instInhabitedGoTo","kind":"instance","line":38,"name":"ExistsAndEq.instInhabitedGoTo","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L38-L38"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.instBEqGoTo.beq\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">instBEqGoTo</span>.<span class=\"name\">beq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.GoTo\">GoTo</a> → <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.GoTo\">GoTo</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.instBEqGoTo.beq","kind":"def","line":38,"name":"ExistsAndEq.instBEqGoTo.beq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L38-L38"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.instBEqGoTo\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">instBEqGoTo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.GoTo\">GoTo</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.instBEqGoTo","kind":"instance","line":38,"name":"ExistsAndEq.instBEqGoTo","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L38-L38"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.GoTo.right\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">GoTo</span>.<span class=\"name\">right</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.GoTo\">GoTo</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.GoTo.right","kind":"ctor","line":37,"name":"ExistsAndEq.GoTo.right","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L37-L37"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.GoTo.left\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">GoTo</span>.<span class=\"name\">left</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.GoTo\">GoTo</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.GoTo.left","kind":"ctor","line":37,"name":"ExistsAndEq.GoTo.left","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L37-L37"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.GoTo\"><span class=\"name\">ExistsAndEq</span>.<span class=\"name\">GoTo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Type for storing the chosen branch at `And` nodes. ","docLink":"./Mathlib/Tactic/Simproc/ExistsAndEq.html#ExistsAndEq.GoTo","kind":"inductive","line":35,"name":"ExistsAndEq.GoTo","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Simproc/ExistsAndEq.lean#L35-L38"}}],"imports":["Init","Mathlib.Init","Qq","Qq","Qq.MatchImpl","Qq.Typ"],"instances":[{"className":"BEq","name":"ExistsAndEq.instBEqGoTo","typeNames":["ExistsAndEq.GoTo"]},{"className":"Inhabited","name":"ExistsAndEq.instInhabitedGoTo","typeNames":["ExistsAndEq.GoTo"]},{"className":"Inhabited","name":"ExistsAndEq.instInhabitedVarQ","typeNames":["ExistsAndEq.VarQ"]},{"className":"Inhabited","name":"ExistsAndEq.instInhabitedHypQ","typeNames":["ExistsAndEq.HypQ"]}],"name":"Mathlib.Tactic.Simproc.ExistsAndEq"}