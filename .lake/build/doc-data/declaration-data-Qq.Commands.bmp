{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Commands.html#Qq.«tacticRun_tacq_=&gt;_»\"><span class=\"name\">Qq</span>.<span class=\"name\">«tacticRun_tacq_=&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`run_tacq` is the Qq analogue to `run_tac` which allows executing arbitrary `TacticM` code.\nIn contrast to `run_tac`, the local context of the main goal can be directly accessed as quoted\nexpressions. Optionally, the annotated goal can also be saved using the syntax `run_tacq $g =>`.\nExample:\n```\nexample (a b : Nat) (h : a = b) : True := by\n  run_tacq goal =>\n    let p : Q(Prop) := q($a = $b)\n    let t ← Lean.Meta.inferType h\n    Lean.logInfo p\n    Lean.logInfo <| toString (← Lean.Meta.isDefEq t p)\n    Lean.logInfo <| toString (← Lean.Meta.isDefEq h.ty p)\n    Lean.logInfo goal\n    Lean.logInfo goal.ty\n  trivial\n```\nSee also: `by_elabq`.\n","docLink":"./Qq/Commands.html#Qq.«tacticRun_tacq_=>_»","kind":"def","line":70,"name":"Qq.«tacticRun_tacq_=>_»","sourceLink":"https://github.com/leanprover-community/quote4/blob/bd58c9efe2086d56ca361807014141a860ddbf8c/Qq/Commands.lean#L70-L89"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Commands.html#Qq.termBy_elabq_\"><span class=\"name\">Qq</span>.<span class=\"name\">termBy_elabq_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`by_elabq` is the Qq analogue to `by_elab` which allows executing arbitrary `TermElabM` code in\nplace of a term. In contrast to `by_elab`, the local context can be directly accessed as quoted\nexpressions and the return type is Q-annotated.\nExample:\n```\ndef f (x : Prop) [Decidable x] : Int :=\n  by_elabq\n    Lean.logInfo x\n    Lean.logInfo x.ty\n    return q(if $x then 2 else 3)\n```\nSee also: `run_tacq`.\n","docLink":"./Qq/Commands.html#Qq.termBy_elabq_","kind":"def","line":33,"name":"Qq.termBy_elabq_","sourceLink":"https://github.com/leanprover-community/quote4/blob/bd58c9efe2086d56ca361807014141a860ddbf8c/Qq/Commands.lean#L33-L68"}}],"imports":["Init","Qq.Macro","Lean","Lean.Elab.Term.TermElabM","Qq.Macro","Qq.AssertInstancesCommute"],"instances":[],"name":"Qq.Commands"}