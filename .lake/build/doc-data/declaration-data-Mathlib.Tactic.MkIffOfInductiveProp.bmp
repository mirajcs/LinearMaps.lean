{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIffOfInductiveProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">mkIffOfInductiveProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`mk_iff_of_inductive_prop i r` makes an `iff` rule for the inductively-defined proposition `i`.\nThe new rule `r` has the shape `∀ ps is, i as ↔ ⋁_j, ∃ cs, is = cs`, where\n* `ps` are the type parameters,\n* `is` are the indices,\n* `j` ranges over all possible constructors,\n* the `cs` are the parameters for each of the constructors, and\n* the equalities `is = cs` are the instantiations for\n  each constructor for each of the indices to the inductive type `i`.\n\nIn each case, we remove constructor parameters (i.e. `cs`) when the corresponding equality would\nbe just `c = i` for some index `i`.\n\nFor example, `mk_iff_of_inductive_prop` on `List.Chain` produces:\n\n```lean\n∀ { α : Type*} (R : α → α → Prop) (a : α) (l : List α),\n  Chain R a l ↔ l = [] ∨ ∃ (b : α) (l' : List α), R a b ∧ Chain R b l ∧ l = b :: l'\n```\n\nSee also the `mk_iff` user attribute.\n","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIffOfInductiveProp","kind":"def","line":382,"name":"Mathlib.Tactic.MkIff.mkIffOfInductiveProp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L382-L404"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">mkIff</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Applying the `mk_iff` attribute to an inductively-defined proposition `mk_iff` makes an `iff` rule\n`r` with the shape `∀ ps is, i as ↔ ⋁_j, ∃ cs, is = cs`, where\n* `ps` are the type parameters,\n* `is` are the indices,\n* `j` ranges over all possible constructors,\n* the `cs` are the parameters for each of the constructors, and\n* the equalities `is = cs` are the instantiations for each constructor for each of\n  the indices to the inductive type `i`.\n\nIn each case, we remove constructor parameters (i.e. `cs`) when the corresponding equality would\nbe just `c = i` for some index `i`.\n\nFor example, if we try the following:\n```lean\n@[mk_iff]\nstructure Foo (m n : Nat) : Prop where\n  equal : m = n\n  sum_eq_two : m + n = 2\n```\n\nThen `#check foo_iff` returns:\n```lean\nfoo_iff : ∀ (m n : Nat), Foo m n ↔ m = n ∧ m + n = 2\n```\n\nYou can add an optional string after `mk_iff` to change the name of the generated lemma.\nFor example, if we try the following:\n```lean\n@[mk_iff bar]\nstructure Foo (m n : Nat) : Prop where\n  equal : m = n\n  sum_eq_two : m + n = 2\n```\n\nThen `#check bar` returns:\n```lean\nbar : ∀ (m n : ℕ), Foo m n ↔ m = n ∧ m + n = 2\n```\n\nSee also the user command `mk_iff_of_inductive_prop`.\n","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIff","kind":"def","line":338,"name":"Mathlib.Tactic.MkIff.mkIff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L338-L380"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIffOfInductivePropImpl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">mkIffOfInductivePropImpl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ind </span><span class=\"fn\">rel</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">relStx</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Implementation for both `mk_iff` and `mk_iff_of_inductive_prop`.\n","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIffOfInductivePropImpl","kind":"def","line":297,"name":"Mathlib.Tactic.MkIff.mkIffOfInductivePropImpl","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L297-L336"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.toInductive\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">toInductive</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvar</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">gs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape\">Shape</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Proves the right to left direction of a generated iff theorem.\n","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.toInductive","kind":"def","line":253,"name":"Mathlib.Tactic.MkIff.toInductive","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L253-L295"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.listBoolMerge\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">listBoolMerge</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span>)</span></span></span></span></div></div>","info":{"doc":"Iterate over two lists, if the first element of the first list is `false`, insert `none` into the\nresult and continue with the tail of first list. Otherwise, wrap the first element of the second\nlist with `some` and continue with the tails of both lists. Return when either list is empty.\n\nExample:\n```\nlistBoolMerge [false, true, false, true] [0, 1, 2, 3, 4] = [none, (some 0), none, (some 1)]\n```\n","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.listBoolMerge","kind":"def","line":237,"name":"Mathlib.Tactic.MkIff.listBoolMerge","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L237-L251"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.nCasesProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">nCasesProd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvar</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></div></div>","info":{"doc":"Calls `cases` on `h` (assumed to be a binary product) `n` times, and returns\nthe resulting subgoal and the new hypotheses.\n","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.nCasesProd","kind":"def","line":225,"name":"Mathlib.Tactic.MkIff.nCasesProd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L225-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.nCasesSum\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">nCasesSum</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvar</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>))</span></span></div></div>","info":{"doc":"Calls `cases` on `h` (assumed to be a binary sum) `n` times, and returns\nthe resulting subgoals and their corresponding new hypotheses.\n","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.nCasesSum","kind":"def","line":212,"name":"Mathlib.Tactic.MkIff.nCasesSum","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L212-L223"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.toCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">toCases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvar</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">shape</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape\">Shape</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Proves the left to right direction of a generated iff theorem.\n`shape` is the output of a call to `constrToProp`.\n","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.toCases","kind":"def","line":191,"name":"Mathlib.Tactic.MkIff.toCases","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L191-L210"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.splitThenConstructor\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">splitThenConstructor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvar</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Splits the goal `n` times via `refine ⟨?_,?_⟩`, and then applies `constructor` to\nclose the resulting subgoals.\n","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.splitThenConstructor","kind":"def","line":172,"name":"Mathlib.Tactic.MkIff.splitThenConstructor","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L172-L189"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.constrToProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">constrToProp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">univs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">params </span><span class=\"fn\">idxs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape\">Shape</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"Converts an inductive constructor `c` into a `Shape` that will be used later in\nwhile proving the iff theorem, and a proposition representing the constructor.\n","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.constrToProp","kind":"def","line":137,"name":"Mathlib.Tactic.MkIff.constrToProp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L137-L170"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.neqs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">Shape</span>.<span class=\"name\">neqs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape\">Shape</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>","info":{"doc":"The number of equalities, or `none` in the case when we've reduced something\nof the form `p ∧ True` to just `p`.\n","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.neqs","kind":"def","line":135,"name":"Mathlib.Tactic.MkIff.Shape.neqs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L135-L135"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.variablesKept\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">Shape</span>.<span class=\"name\">variablesKept</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape\">Shape</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"For each forall-bound variable in the type of the constructor, minus\nthe \"params\" that apply to the entire inductive type, this list contains `true`\nif that variable has been kept after `compactRelation`.\n\nFor example, `List.Chain.nil` has type\n```lean\n  ∀ {α : Type u_1} {R : α → α → Prop} {a : α}, List.Chain R a []`\n```\nand the first two variables `α` and `R` are \"params\", while the `a : α` gets\neliminated in a `compactRelation`, so `variablesKept = [false]`.\n\n`List.Chain.cons` has type\n```lean\n  ∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α},\n     R a b → List.Chain R b l → List.Chain R a (b :: l)\n```\nand the `a : α` gets eliminated, so `variablesKept = [false,true,true,true,true]`.\n","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.variablesKept","kind":"def","line":130,"name":"Mathlib.Tactic.MkIff.Shape.variablesKept","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L130-L130"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">Shape</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">variablesKept</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">neqs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape\">Shape</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.mk","kind":"ctor","line":111,"name":"Mathlib.Tactic.MkIff.Shape.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L111-L111"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">Shape</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Auxiliary data associated with a single constructor of an inductive declaration.\n","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape","kind":"structure","line":109,"name":"Mathlib.Tactic.MkIff.Shape","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L109-L135"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.List.init\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">List</span>.<span class=\"name\">init</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"Drops the final element of a list. ","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.List.init","kind":"def","line":103,"name":"Mathlib.Tactic.MkIff.List.init","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L103-L107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOrList\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">mkOrList</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"`mkOrList [x1, x2, ...]` is defined as `x1 ∨ (x2 ∨ ...)`, or `False` if the list is empty. ","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOrList","kind":"def","line":100,"name":"Mathlib.Tactic.MkIff.mkOrList","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L100-L101"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkAndList\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">mkAndList</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"`mkAndList [x1, x2, ...]` is defined as `x1 ∧ (x2 ∧ ...)`, or `True` if the list is empty. ","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkAndList","kind":"def","line":97,"name":"Mathlib.Tactic.MkIff.mkAndList","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L97-L98"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOpList\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">mkOpList</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op </span><span class=\"fn\">empty</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"`mkOpList op empty [x1, x2, ...]` is defined as `op x1 (op x2 ...)`.\nReturns `empty` if the list is empty. ","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOpList","kind":"def","line":90,"name":"Mathlib.Tactic.MkIff.mkOpList","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L90-L95"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkExistsList\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">mkExistsList</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inner</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Generates an expression of the form `∃ (args), inner`. `args` is assumed to be a list of fvars.\nWhen possible, `p ∧ q` is used instead of `∃ (_ : p), q`. ","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkExistsList","kind":"def","line":77,"name":"Mathlib.Tactic.MkIff.mkExistsList","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L77-L88"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.compactRelation\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">compactRelation</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> →\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">(<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></span></div></div>","info":{"doc":"`compactRelation bs as_ps`: Produce a relation of the form:\n```lean\nR := fun as ↦ ∃ bs, ⋀_i a_i = p_i[bs]\n```\nThis relation is user-visible, so we compact it by removing each `b_j` where a `p_i = b_j`, and\nhence `a_i = b_j`. We need to take care when there are `p_i` and `p_j` with `p_i = p_j = b_k`.\n","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.compactRelation","kind":"opaque","line":51,"name":"Mathlib.Tactic.MkIff.compactRelation","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/MkIffOfInductiveProp.lean#L51-L70"}}],"imports":["Init","Lean.Elab.DeclarationRange","Lean.Meta.Tactic.Cases","Mathlib.Lean.Meta","Mathlib.Lean.Name","Mathlib.Tactic.TypeStar"],"instances":[],"name":"Mathlib.Tactic.MkIffOfInductiveProp"}