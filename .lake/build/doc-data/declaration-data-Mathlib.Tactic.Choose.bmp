{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.tacticChoose!___Using_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">tacticChoose!___Using_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"* `choose a b h h' using hyp` takes a hypothesis `hyp` of the form\n  `∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b ∧ Q x y a b`\n  for some `P Q : X → Y → A → B → Prop` and outputs\n  into context a function `a : X → Y → A`, `b : X → Y → B` and two assumptions:\n  `h : ∀ (x : X) (y : Y), P x y (a x y) (b x y)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x y) (b x y)`. It also works with dependent versions.\n\n* `choose! a b h h' using hyp` does the same, except that it will remove dependency of\n  the functions on propositional arguments if possible. For example if `Y` is a proposition\n  and `A` and `B` are nonempty in the above example then we will instead get\n  `a : X → A`, `b : X → B`, and the assumptions\n  `h : ∀ (x : X) (y : Y), P x y (a x) (b x)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x) (b x)`.\n\nThe `using hyp` part can be omitted,\nwhich will effectively cause `choose` to start with an `intro hyp`.\n\nLike `intro`, the `choose` tactic supports type annotations to specify the expected type\nof the introduced variables. This is useful for documentation and for catching mistakes early:\n```\nexample (h : ∃ n : ℕ, n > 0) : True := by\n  choose (n : ℕ) (hn : n > 0) using h\n  trivial\n```\nIf the provided type does not match the actual type, an error is raised.\n\nExamples:\n\n```\nexample (h : ∀ n m : ℕ, ∃ i j, m = n + i ∨ m + j = n) : True := by\n  choose i j h using h\n  guard_hyp i : ℕ → ℕ → ℕ\n  guard_hyp j : ℕ → ℕ → ℕ\n  guard_hyp h : ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n\n  trivial\n```\n\n```\nexample (h : ∀ i : ℕ, i < 7 → ∃ j, i < j ∧ j < i+i) : True := by\n  choose! f h h' using h\n  guard_hyp f : ℕ → ℕ\n  guard_hyp h : ∀ (i : ℕ), i < 7 → i < f i\n  guard_hyp h' : ∀ (i : ℕ), i < 7 → f i < i + i\n  trivial\n```\n","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.tacticChoose!___Using_","kind":"def","line":289,"name":"Mathlib.Tactic.Choose.tacticChoose!___Using_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L289-L290"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">choose</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"* `choose a b h h' using hyp` takes a hypothesis `hyp` of the form\n  `∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b ∧ Q x y a b`\n  for some `P Q : X → Y → A → B → Prop` and outputs\n  into context a function `a : X → Y → A`, `b : X → Y → B` and two assumptions:\n  `h : ∀ (x : X) (y : Y), P x y (a x y) (b x y)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x y) (b x y)`. It also works with dependent versions.\n\n* `choose! a b h h' using hyp` does the same, except that it will remove dependency of\n  the functions on propositional arguments if possible. For example if `Y` is a proposition\n  and `A` and `B` are nonempty in the above example then we will instead get\n  `a : X → A`, `b : X → B`, and the assumptions\n  `h : ∀ (x : X) (y : Y), P x y (a x) (b x)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x) (b x)`.\n\nThe `using hyp` part can be omitted,\nwhich will effectively cause `choose` to start with an `intro hyp`.\n\nLike `intro`, the `choose` tactic supports type annotations to specify the expected type\nof the introduced variables. This is useful for documentation and for catching mistakes early:\n```\nexample (h : ∃ n : ℕ, n > 0) : True := by\n  choose (n : ℕ) (hn : n > 0) using h\n  trivial\n```\nIf the provided type does not match the actual type, an error is raised.\n\nExamples:\n\n```\nexample (h : ∀ n m : ℕ, ∃ i j, m = n + i ∨ m + j = n) : True := by\n  choose i j h using h\n  guard_hyp i : ℕ → ℕ → ℕ\n  guard_hyp j : ℕ → ℕ → ℕ\n  guard_hyp h : ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n\n  trivial\n```\n\n```\nexample (h : ∀ i : ℕ, i < 7 → ∃ j, i < j ∧ j < i+i) : True := by\n  choose! f h h' using h\n  guard_hyp f : ℕ → ℕ\n  guard_hyp h : ∀ (i : ℕ), i < 7 → i < f i\n  guard_hyp h' : ∀ (i : ℕ), i < 7 → f i < i + i\n  trivial\n```\n","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose","kind":"def","line":232,"name":"Mathlib.Tactic.Choose.choose","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L232-L279"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.elabChoose\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">elabChoose</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nondep</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg\">ChooseArg</a></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span></span></span></span></div></div>","info":{"doc":"A loop around `choose1`. The main entry point for the `choose` tactic. ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.elabChoose","kind":"def","line":203,"name":"Mathlib.Tactic.Choose.elabChoose","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L203-L230"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose1WithInfo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">choose1WithInfo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nondep</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">arg</span> : <a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg\">ChooseArg</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></div></div>","info":{"doc":"A wrapper around `choose1` that parses identifiers, adds variable info to new variables,\nand optionally checks the type annotation. ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose1WithInfo","kind":"def","line":184,"name":"Mathlib.Tactic.Choose.choose1WithInfo","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L184-L201"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose1\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">choose1</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nondep</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">data</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></div></div>","info":{"doc":"Changes `(h : ∀ xs, ∃ a:α, p a) ⊢ g` to `(d : ∀ xs, a) ⊢ (s : ∀ xs, p (d xs)) → g` and\n`(h : ∀ xs, p xs ∧ q xs) ⊢ g` to `(d : ∀ xs, p xs) ⊢ (s : ∀ xs, q xs) → g`.\n`choose1` returns a tuple of\n\n- the error result (see `ElimStatus`)\n- the data new free variable that was \"chosen\"\n- the new goal (which contains the spec of the data as domain of an arrow type)\n\nIf `nondep` is true and `α` is inhabited, then it will remove the dependency of `d` on\nall propositional assumptions in `xs`. For example if `ys` are propositions then\n`(h : ∀ xs ys, ∃ a:α, p a) ⊢ g` becomes `(d : ∀ xs, a) (s : ∀ xs ys, p (d xs)) ⊢ g`. ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose1","kind":"def","line":107,"name":"Mathlib.Tactic.Choose.choose1","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L107-L182"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.parseChooseArg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">parseChooseArg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Mathlib.Tactic.Choose.chooseBinder</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg\">ChooseArg</a></span></div></div>","info":{"doc":"Parse a `choose` argument from `chooseBinder` syntax. Accepts:\n- `x` - plain identifier\n- `_` - anonymous\n- `(x : T)` - identifier with type annotation\n- `(_ : T)` - anonymous with type annotation ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.parseChooseArg","kind":"def","line":87,"name":"Mathlib.Tactic.Choose.parseChooseArg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L87-L105"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.chooseBinder\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">chooseBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"A `choose` argument is either a bare identifier or a parenthesized extended binder ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.chooseBinder","kind":"def","line":83,"name":"Mathlib.Tactic.Choose.chooseBinder","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L83-L84"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.instInhabitedChooseArg.default\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">instInhabitedChooseArg</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg\">ChooseArg</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.instInhabitedChooseArg.default","kind":"def","line":81,"name":"Mathlib.Tactic.Choose.instInhabitedChooseArg.default","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L81-L81"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.instInhabitedChooseArg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">instInhabitedChooseArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg\">ChooseArg</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.instInhabitedChooseArg","kind":"instance","line":81,"name":"Mathlib.Tactic.Choose.instInhabitedChooseArg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L81-L81"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg.expectedType?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ChooseArg</span>.<span class=\"name\">expectedType?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg\">ChooseArg</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a></span></div></div>","info":{"doc":"Optional expected type annotation ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg.expectedType?","kind":"def","line":80,"name":"Mathlib.Tactic.Choose.ChooseArg.expectedType?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L80-L80"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg.name\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ChooseArg</span>.<span class=\"name\">name</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg\">ChooseArg</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>","info":{"doc":"The name to use for the introduced variable ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg.name","kind":"def","line":78,"name":"Mathlib.Tactic.Choose.ChooseArg.name","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L78-L78"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg.ref\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ChooseArg</span>.<span class=\"name\">ref</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg\">ChooseArg</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></div></div>","info":{"doc":"The syntax reference for the identifier (for hover info) ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg.ref","kind":"def","line":76,"name":"Mathlib.Tactic.Choose.ChooseArg.ref","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L76-L76"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ChooseArg</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ref</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expectedType?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg\">ChooseArg</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg.mk","kind":"ctor","line":74,"name":"Mathlib.Tactic.Choose.ChooseArg.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L74-L74"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ChooseArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Parsed information from a `choose` argument, which may include a type annotation. ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ChooseArg","kind":"structure","line":73,"name":"Mathlib.Tactic.Choose.ChooseArg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L73-L81"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.mkFreshNameFrom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">mkFreshNameFrom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">orig </span><span class=\"fn\">base</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>","info":{"doc":"`mkFreshNameFrom orig base` returns `mkFreshUserName base` if ``orig = `_``\nand `orig` otherwise. ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.mkFreshNameFrom","kind":"def","line":68,"name":"Mathlib.Tactic.Choose.mkFreshNameFrom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L68-L71"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.merge\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ElimStatus</span>.<span class=\"name\">merge</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> → <a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> → <a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a></span></div></div>","info":{"doc":"Combine two statuses, keeping a success from either side\nor merging the failures. ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.merge","kind":"def","line":61,"name":"Mathlib.Tactic.Choose.ElimStatus.merge","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L61-L66"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.failure\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ElimStatus</span>.<span class=\"name\">failure</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.failure","kind":"ctor","line":59,"name":"Mathlib.Tactic.Choose.ElimStatus.failure","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L59-L59"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.success\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ElimStatus</span>.<span class=\"name\">success</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.success","kind":"ctor","line":58,"name":"Mathlib.Tactic.Choose.ElimStatus.success","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L58-L58"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ElimStatus</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Results of searching for nonempty instances,\nto eliminate dependencies on propositions (`choose!`).\n`success` means we found at least one instance;\n`failure ts` means we didn't find instances for any `t ∈ ts`.\n(`failure []` means we didn't look for instances at all.)\n\nRationale:\n`choose!` means we are expected to succeed at least once\nin eliminating dependencies on propositions.\n","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus","kind":"inductive","line":47,"name":"Mathlib.Tactic.Choose.ElimStatus","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L47-L59"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.mk_sometimes\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">mk_sometimes</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α </span><span class=\"fn\">nonemp </span><span class=\"fn\">p</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></span></div></div>","info":{"doc":"Given `α : Sort u`, `nonemp : Nonempty α`, `p : α → Prop`, a context of free variables\n`ctx`, and a pair of an element `val : α` and `spec : p val`,\n`mk_sometimes u α nonemp p ctx (val, spec)` produces another pair `val', spec'`\nsuch that `val'` does not have any free variables from elements of `ctx` whose types are\npropositions. This is done by applying `Function.sometimes` to abstract over all the propositional\narguments. ","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.mk_sometimes","kind":"def","line":27,"name":"Mathlib.Tactic.Choose.mk_sometimes","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Choose.lean#L27-L45"}}],"imports":["Init","Batteries.Lean.Expr","Batteries.Lean.Expr","Mathlib.Logic.Function.Basic","Mathlib.Tactic.Basic"],"instances":[{"className":"Inhabited","name":"Mathlib.Tactic.Choose.instInhabitedChooseArg","typeNames":["Mathlib.Tactic.Choose.ChooseArg"]}],"name":"Mathlib.Tactic.Choose"}