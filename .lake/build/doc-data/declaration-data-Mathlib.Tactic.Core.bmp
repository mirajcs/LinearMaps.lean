{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Mathlib.getMathlibDir\"><span class=\"name\">Mathlib</span>.<span class=\"name\">getMathlibDir</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <a href=\"./Init/System/FilePath.html#System.FilePath\">System.FilePath</a></span></div></div>","info":{"doc":"Returns the mathlib root directory. ","docLink":"./Mathlib/Tactic/Core.html#Mathlib.getMathlibDir","kind":"def","line":263,"name":"Mathlib.getMathlibDir","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L263-L264"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Mathlib.getPackageDir\"><span class=\"name\">Mathlib</span>.<span class=\"name\">getPackageDir</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pkg</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <a href=\"./Init/System/FilePath.html#System.FilePath\">System.FilePath</a></span></div></div>","info":{"doc":"Returns the root directory which contains the package root file, e.g. `Mathlib.lean`. ","docLink":"./Mathlib/Tactic/Core.html#Mathlib.getPackageDir","kind":"def","line":254,"name":"Mathlib.getPackageDir","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L254-L261"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.iterateUntilFailureCount\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">iterateUntilFailureCount</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadExcept\">MonadExcept</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>","info":{"doc":"`iterateUntilFailureCount` is similar to `iterateUntilFailure` except it counts\nthe number of successful calls to `tac`. Always succeeds.\n","docLink":"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.iterateUntilFailureCount","kind":"def","line":242,"name":"Lean.Elab.Tactic.iterateUntilFailureCount","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L242-L247"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.iterateUntilFailureWithResults\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">iterateUntilFailureWithResults</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadExcept\">MonadExcept</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"`iterateUntilFailureWithResults` is a helper tactic which accumulates the list of results\nobtained from iterating `tac` until it fails. Always succeeds.\n","docLink":"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.iterateUntilFailureWithResults","kind":"opaque","line":232,"name":"Lean.Elab.Tactic.iterateUntilFailureWithResults","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L232-L240"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.iterateUntilFailure\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">iterateUntilFailure</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadExcept\">MonadExcept</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Repeats a tactic until it fails. Always succeeds. ","docLink":"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.iterateUntilFailure","kind":"opaque","line":228,"name":"Lean.Elab.Tactic.iterateUntilFailure","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L228-L230"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.iterateRange\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">iterateRange</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadExcept\">MonadExcept</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> → <a href=\"./Init/Prelude.html#Nat\">Nat</a> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span></span></div></div>","info":{"doc":"`iterateRange m n t`: Repeat the given tactic at least `m` times and\nat most `n` times or until `t` fails. Fails if `t` does not run at least `m` times.\n","docLink":"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.iterateRange","kind":"def","line":219,"name":"Lean.Elab.Tactic.iterateRange","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L219-L226"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.iterateExactly'\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">iterateExactly'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span></span></div></div>","info":{"doc":"`iterateExactly' n t` executes `t` `n` times. If any iteration fails, the whole tactic fails.\n","docLink":"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.iterateExactly'","kind":"def","line":213,"name":"Lean.Elab.Tactic.iterateExactly'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L213-L217"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.iterateAtMost\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">iterateAtMost</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadExcept\">MonadExcept</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span></span></div></div>","info":{"doc":"Repeats a tactic at most `n` times, stopping sooner if the\ntactic fails. Always succeeds. ","docLink":"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.iterateAtMost","kind":"def","line":207,"name":"Lean.Elab.Tactic.iterateAtMost","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L207-L211"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.andThenOnSubgoals\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">andThenOnSubgoals</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac1 </span><span class=\"fn\">tac2</span> : <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Simulates the `<;>` tactic combinator.\nFirst runs `tac1` and then runs `tac2` on all newly-generated subgoals.\n","docLink":"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.andThenOnSubgoals","kind":"def","line":198,"name":"Lean.Elab.Tactic.andThenOnSubgoals","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L198-L202"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.allGoals\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">allGoals</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Run a tactic on all goals, and always succeeds.\n\n(This is parallel to `Lean.Elab.Tactic.evalAllGoals` in core,\nwhich takes a `Syntax` rather than `TacticM Unit`.\nThis function could be moved to core and `evalAllGoals` refactored to use it.)\n","docLink":"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.allGoals","kind":"def","line":174,"name":"Lean.Elab.Tactic.allGoals","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L174-L196"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.getFVarIdsAt\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">getFVarIdsAt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ids</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">includeImplementationDetails</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span></div></div>","info":{"doc":"Get the array of `FVarId`s in the local context of the given `goal`.\n\nIf `ids` is specified, elaborate them in the local context of the given goal to obtain the array of\n`FVarId`s.\n\nIf `includeImplementationDetails` is `false` (the default), we filter out implementation details\n(`implDecl`s and `auxDecl`s) from the resulting list of `FVarId`s. ","docLink":"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.getFVarIdsAt","kind":"def","line":155,"name":"Lean.Elab.Tactic.getFVarIdsAt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L155-L172"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.getFVarIdAt\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">getFVarIdAt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">id</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span></div></div>","info":{"doc":"Elaborate syntax for an `FVarId` in the local context of the given goal. ","docLink":"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.getFVarIdAt","kind":"def","line":146,"name":"Lean.Elab.Tactic.getFVarIdAt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L146-L153"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.filterOutImplementationDetails\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">filterOutImplementationDetails</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lctx</span> : <a href=\"./Lean/LocalContext.html#Lean.LocalContext\">LocalContext</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvarIds</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span></div></div>","info":{"doc":"Given a local context and an array of `FVarIds` assumed to be in that local context, remove all\nimplementation details. ","docLink":"./Mathlib/Tactic/Core.html#Lean.Elab.Tactic.filterOutImplementationDetails","kind":"def","line":141,"name":"Lean.Elab.Tactic.filterOutImplementationDetails","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L141-L144"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Mathlib.Tactic.tacticRepeat1_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticRepeat1_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`repeat1 tac` applies `tac` to main goal at least once. If the application succeeds,\nthe tactic is applied recursively to the generated subgoals until it eventually fails.\n","docLink":"./Mathlib/Tactic/Core.html#Mathlib.Tactic.tacticRepeat1_","kind":"def","line":135,"name":"Mathlib.Tactic.tacticRepeat1_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L135-L135"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Mathlib.Tactic.getUsingArg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">getUsingArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></span></span></div></div>","info":{"doc":"Extract the argument from a `usingArg` syntax as a syntax term ","docLink":"./Mathlib/Tactic/Core.html#Mathlib.Tactic.getUsingArg","kind":"def","line":126,"name":"Mathlib.Tactic.getUsingArg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L126-L129"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Mathlib.Tactic.getWithArgs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">getWithArgs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span></span></div></div>","info":{"doc":"Extract the arguments from a `withArgs` syntax as an array of syntaxes ","docLink":"./Mathlib/Tactic/Core.html#Mathlib.Tactic.getWithArgs","kind":"def","line":121,"name":"Mathlib.Tactic.getWithArgs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L121-L124"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Mathlib.Tactic.getDSimpArgs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">getDSimpArgs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span></span></div></div>","info":{"doc":"Extract the arguments from a `dsimpArgs` syntax as an array of syntaxes ","docLink":"./Mathlib/Tactic/Core.html#Mathlib.Tactic.getDSimpArgs","kind":"def","line":116,"name":"Mathlib.Tactic.getDSimpArgs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L116-L119"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Mathlib.Tactic.getSimpArgs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">getSimpArgs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span></span></div></div>","info":{"doc":"Extract the arguments from a `simpArgs` syntax as an array of syntaxes ","docLink":"./Mathlib/Tactic/Core.html#Mathlib.Tactic.getSimpArgs","kind":"def","line":111,"name":"Mathlib.Tactic.getSimpArgs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L111-L114"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Mathlib.Tactic.usingArg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">usingArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Core.html#Mathlib.Tactic.usingArg","kind":"def","line":107,"name":"Mathlib.Tactic.usingArg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L107-L107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Mathlib.Tactic.withArgs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">withArgs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Core.html#Mathlib.Tactic.withArgs","kind":"def","line":106,"name":"Mathlib.Tactic.withArgs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L106-L106"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.MVarId.introsWithBinderIdents\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">introsWithBinderIdents</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ids</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">maxIntros?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></div></div>","info":{"doc":"Introduce variables, giving them names from a specified list. ","docLink":"./Mathlib/Tactic/Core.html#Lean.MVarId.introsWithBinderIdents","kind":"def","line":76,"name":"Lean.MVarId.introsWithBinderIdents","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L76-L98"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.setProtected\"><span class=\"name\">Lean</span>.<span class=\"name\">setProtected</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/Environment.html#Lean.MonadEnv\">MonadEnv</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nm</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Make `nm` protected. ","docLink":"./Mathlib/Tactic/Core.html#Lean.setProtected","kind":"def","line":72,"name":"Lean.setProtected","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L72-L74"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.toPreDefinition\"><span class=\"name\">Lean</span>.<span class=\"name\">toPreDefinition</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nm </span><span class=\"fn\">newNm</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newType </span><span class=\"fn\">newValue</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newDoc</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.Parser.Command.docComment</span>)</span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Elab/PreDefinition/Basic.html#Lean.Elab.PreDefinition\">Elab.PreDefinition</a></span></div></div>","info":{"doc":"Make a PreDefinition taking some metadata from declaration `nm`.\nYou can provide a new type, value and (optional) docstring, but the remaining information is taken\nfrom `nm`.\nCurrently only implemented for definitions and theorems. Also see docstring of `toModifiers`\n","docLink":"./Mathlib/Tactic/Core.html#Lean.toPreDefinition","kind":"def","line":49,"name":"Lean.toPreDefinition","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L49-L70"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Core.html#Lean.toModifiers\"><span class=\"name\">Lean</span>.<span class=\"name\">toModifiers</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nm</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newDoc</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.Parser.Command.docComment</span>)</span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Elab/DeclModifiers.html#Lean.Elab.Modifiers\">Elab.Modifiers</a></span></div></div>","info":{"doc":"Return the modifiers of declaration `nm` with (optional) docstring `newDoc`.\nCurrently, recursive or partial definitions are not supported, and no attributes are provided.\n","docLink":"./Mathlib/Tactic/Core.html#Lean.toModifiers","kind":"def","line":27,"name":"Lean.toModifiers","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Core.lean#L27-L47"}}],"imports":["Init","Lean.Elab.PreDefinition.Basic","Lean.Elab.Tactic.ElabTerm","Lean.Meta.Tactic.Intro","Batteries.Lean.Expr","Mathlib.Init"],"instances":[],"name":"Mathlib.Tactic.Core"}