{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.convRing!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">convRing!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The tactic `ring` evaluates expressions in *commutative* (semi)rings.\nThis is the conv tactic version, which rewrites a target which is a ring equality to `True`.\n\nSee also the `ring` tactic.\n","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.convRing!","kind":"def","line":244,"name":"Mathlib.Tactic.RingNF.convRing!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L244-L249"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">ringConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The tactic `ring` evaluates expressions in *commutative* (semi)rings.\nThis is the conv tactic version, which rewrites a target which is a ring equality to `True`.\n\nSee also the `ring` tactic.\n","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringConv","kind":"def","line":238,"name":"Mathlib.Tactic.RingNF.ringConv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L238-L243"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">tacticRing!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`ring` solves equations in *commutative* (semi)rings, allowing for variables in the\nexponent. If the goal is not appropriate for `ring` (e.g. not an equality) `ring_nf` will be\nsuggested. See also `ring1`, which fails if the goal is not an equality.\n\n* `ring!` will use a more aggressive reducibility setting to determine equality of atoms.\n\nExamples:\n```\nexample (n : ℕ) (m : ℤ) : 2^(n+1) * m = 2 * 2^n * m := by ring\nexample (a b : ℤ) (n : ℕ) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring\nexample (x y : ℕ) : x + id y = y + id x := by ring!\nexample (x : ℕ) (h : x * 2 > 5): x + x > 5 := by ring; assumption -- suggests ring_nf\n```\n","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing!","kind":"def","line":225,"name":"Mathlib.Tactic.RingNF.tacticRing!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L225-L230"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ring\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">ring</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`ring` solves equations in *commutative* (semi)rings, allowing for variables in the\nexponent. If the goal is not appropriate for `ring` (e.g. not an equality) `ring_nf` will be\nsuggested. See also `ring1`, which fails if the goal is not an equality.\n\n* `ring!` will use a more aggressive reducibility setting to determine equality of atoms.\n\nExamples:\n```\nexample (n : ℕ) (m : ℤ) : 2^(n+1) * m = 2 * 2^n * m := by ring\nexample (a b : ℤ) (n : ℕ) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring\nexample (x y : ℕ) : x + id y = y + id x := by ring!\nexample (x : ℕ) (h : x * 2 > 5): x + x > 5 := by ring; assumption -- suggests ring_nf\n```\n","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ring","kind":"def","line":219,"name":"Mathlib.Tactic.RingNF.ring","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L219-L224"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.convRing_nf!_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">convRing_nf!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`ring_nf` simplifies expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form, allowing variables in the exponents.\n\n`ring_nf` works as both a tactic and a conv tactic.\n\nSee also the `ring` tactic for solving a goal which is an equation in the language\nof commutative (semi)rings.\n\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration (see `RingNF.Config`):\n  * `red`: the reducibility setting (overridden by `!`)\n  * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf at l1 l2 ...` can be used to rewrite at the given locations.\n\nExamples:\nThis can be used non-terminally to normalize ring expressions in the goal such as\n`⊢ P (x + x + x)` ~> `⊢ P (x * 3)`, as well as being able to prove some equations that\n`ring` cannot because they involve ring reasoning inside a subterm, such as\n`sin (x + y) + sin (y + x) = 2 * sin (x + y)`.\n","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.convRing_nf!_","kind":"def","line":201,"name":"Mathlib.Tactic.RingNF.convRing_nf!_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L201-L202"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.elabRingNFConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">elabRingNFConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>","info":{"doc":"Elaborator for the `ring_nf` tactic. ","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.elabRingNFConv","kind":"def","line":191,"name":"Mathlib.Tactic.RingNF.elabRingNFConv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L191-L199"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing1_nf!_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">tacticRing1_nf!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`ring1` solves the goal when it is an equality in *commutative* (semi)rings,\nallowing variables in the exponent.\n\nThis version of `ring` fails if the target is not an equality.\n\n* `ring1!` uses a more aggressive reducibility setting to determine equality of atoms.\n\n\nExtensions:\n\n * * `ring1_nf` additionally uses `ring_nf` to simplify in atoms.\n   * `ring1_nf!` will use a more aggressive reducibility setting\n     to determine equality of atoms.","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing1_nf!_","kind":"def","line":188,"name":"Mathlib.Tactic.RingNF.tacticRing1_nf!_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L188-L189"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ring1NF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">ring1NF</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`ring1` solves the goal when it is an equality in *commutative* (semi)rings,\nallowing variables in the exponent.\n\nThis version of `ring` fails if the target is not an equality.\n\n* `ring1!` uses a more aggressive reducibility setting to determine equality of atoms.\n\n\nExtensions:\n\n * * `ring1_nf` additionally uses `ring_nf` to simplify in atoms.\n   * `ring1_nf!` will use a more aggressive reducibility setting\n     to determine equality of atoms.","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ring1NF","kind":"def","line":180,"name":"Mathlib.Tactic.RingNF.ring1NF","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L180-L185"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNFConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">ringNFConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`ring_nf` simplifies expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form, allowing variables in the exponents.\n\n`ring_nf` works as both a tactic and a conv tactic.\n\nSee also the `ring` tactic for solving a goal which is an equation in the language\nof commutative (semi)rings.\n\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration (see `RingNF.Config`):\n  * `red`: the reducibility setting (overridden by `!`)\n  * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf at l1 l2 ...` can be used to rewrite at the given locations.\n\nExamples:\nThis can be used non-terminally to normalize ring expressions in the goal such as\n`⊢ P (x + x + x)` ~> `⊢ P (x * 3)`, as well as being able to prove some equations that\n`ring` cannot because they involve ring reasoning inside a subterm, such as\n`sin (x + y) + sin (y + x) = 2 * sin (x + y)`.\n","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNFConv","kind":"def","line":171,"name":"Mathlib.Tactic.RingNF.ringNFConv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L171-L171"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing_nf!__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">tacticRing_nf!__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`ring_nf` simplifies expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form, allowing variables in the exponents.\n\n`ring_nf` works as both a tactic and a conv tactic.\n\nSee also the `ring` tactic for solving a goal which is an equation in the language\nof commutative (semi)rings.\n\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration (see `RingNF.Config`):\n  * `red`: the reducibility setting (overridden by `!`)\n  * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf at l1 l2 ...` can be used to rewrite at the given locations.\n\nExamples:\nThis can be used non-terminally to normalize ring expressions in the goal such as\n`⊢ P (x + x + x)` ~> `⊢ P (x * 3)`, as well as being able to prove some equations that\n`ring` cannot because they involve ring reasoning inside a subterm, such as\n`sin (x + y) + sin (y + x) = 2 * sin (x + y)`.\n","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing_nf!__","kind":"def","line":168,"name":"Mathlib.Tactic.RingNF.tacticRing_nf!__","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L168-L169"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">ringNF</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`ring_nf` simplifies expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form, allowing variables in the exponents.\n\n`ring_nf` works as both a tactic and a conv tactic.\n\nSee also the `ring` tactic for solving a goal which is an equation in the language\nof commutative (semi)rings.\n\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration (see `RingNF.Config`):\n  * `red`: the reducibility setting (overridden by `!`)\n  * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf at l1 l2 ...` can be used to rewrite at the given locations.\n\nExamples:\nThis can be used non-terminally to normalize ring expressions in the goal such as\n`⊢ P (x + x + x)` ~> `⊢ P (x * 3)`, as well as being able to prove some equations that\n`ring` cannot because they involve ring reasoning inside a subterm, such as\n`sin (x + y) + sin (y + x) = 2 * sin (x + y)`.\n","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNF","kind":"def","line":138,"name":"Mathlib.Tactic.RingNF.ringNF","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L138-L166"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.cleanup\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">cleanup</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"A cleanup routine, which simplifies normalized polynomials to a more human-friendly format. ","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.cleanup","kind":"def","line":116,"name":"Mathlib.Tactic.RingNF.cleanup","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L116-L130"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.rat_rawCast_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">rat_rawCast_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Rat.rawCast\">Rat.rawCast</a> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">rawCast</a></span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\"><span class=\"fn\">d</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.rat_rawCast_neg","kind":"theorem","line":113,"name":"Mathlib.Tactic.RingNF.rat_rawCast_neg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L113-L114"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nnrat_rawCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">nnrat_rawCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#NNRat.rawCast\">NNRat.rawCast</a> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\"><span class=\"fn\">d</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nnrat_rawCast","kind":"theorem","line":111,"name":"Mathlib.Tactic.RingNF.nnrat_rawCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L111-L112"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.int_rawCast_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">int_rawCast_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">rawCast</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.int_rawCast_neg","kind":"theorem","line":110,"name":"Mathlib.Tactic.RingNF.int_rawCast_neg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L110-L110"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_2\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">nat_rawCast_2</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo\">AtLeastTwo</a></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#OfNat.ofNat\">OfNat.ofNat</a> <span class=\"fn\">n</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_2","kind":"theorem","line":109,"name":"Mathlib.Tactic.RingNF.nat_rawCast_2","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L109-L109"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_1\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">nat_rawCast_1</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">1</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_1","kind":"theorem","line":108,"name":"Mathlib.Tactic.RingNF.nat_rawCast_1","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L108-L108"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_0\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">nat_rawCast_0</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_0","kind":"theorem","line":107,"name":"Mathlib.Tactic.RingNF.nat_rawCast_0","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L107-L107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.add_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">add_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">b</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.add_neg","kind":"theorem","line":106,"name":"Mathlib.Tactic.RingNF.add_neg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L106-L106"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.mul_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">mul_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Neg.neg\">-</a>(<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span>)</div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.mul_neg","kind":"theorem","line":105,"name":"Mathlib.Tactic.RingNF.mul_neg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L105-L105"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.mul_assoc_rev\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">mul_assoc_rev</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> (<span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.mul_assoc_rev","kind":"theorem","line":104,"name":"Mathlib.Tactic.RingNF.mul_assoc_rev","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L104-L104"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.add_assoc_rev\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">add_assoc_rev</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> (<span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.add_assoc_rev","kind":"theorem","line":103,"name":"Mathlib.Tactic.RingNF.add_assoc_rev","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L103-L103"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.evalExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">evalExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Evaluates an expression `e` into a normalized representation as a polynomial.\n\nThis is a variant of `Mathlib.Tactic.Ring.eval`, the main driver of the `ring` tactic.\nIt differs in\n* operating on `Expr` (input) and `Simp.Result` (output), rather than typed `Qq` versions of these;\n* throwing an error if the expression `e` is an atom for the `ring` tactic.\n","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.evalExpr","kind":"def","line":81,"name":"Mathlib.Tactic.RingNF.evalExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L81-L99"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.elabConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">elabConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Config</a></span></span></div></div>","info":{"doc":"Function elaborating `RingNF.Config`. ","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.elabConfig","kind":"def","line":78,"name":"Mathlib.Tactic.RingNF.elabConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L78-L79"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instReprConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instReprConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Config</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instReprConfig","kind":"instance","line":73,"name":"Mathlib.Tactic.RingNF.instReprConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L73-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instReprConfig.repr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instReprConfig</span>.<span class=\"name\">repr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Config</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Std.Format</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instReprConfig.repr","kind":"def","line":73,"name":"Mathlib.Tactic.RingNF.instReprConfig.repr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L73-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instBEqConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instBEqConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Config</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instBEqConfig","kind":"instance","line":73,"name":"Mathlib.Tactic.RingNF.instBEqConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L73-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instBEqConfig.beq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instBEqConfig</span>.<span class=\"name\">beq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Config</a> → <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Config</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instBEqConfig.beq","kind":"def","line":73,"name":"Mathlib.Tactic.RingNF.instBEqConfig.beq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L73-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instInhabitedConfig.default\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instInhabitedConfig</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Config</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instInhabitedConfig.default","kind":"def","line":73,"name":"Mathlib.Tactic.RingNF.instInhabitedConfig.default","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L73-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instInhabitedConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instInhabitedConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Config</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instInhabitedConfig","kind":"instance","line":73,"name":"Mathlib.Tactic.RingNF.instInhabitedConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L73-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.mode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">mode</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">RingMode</a></div></div>","info":{"doc":"The normalization style. ","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.mode","kind":"def","line":72,"name":"Mathlib.Tactic.RingNF.Config.mode","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L72-L72"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.failIfUnchanged\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">failIfUnchanged</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"if true, then fail if no progress is made ","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.failIfUnchanged","kind":"def","line":70,"name":"Mathlib.Tactic.RingNF.Config.failIfUnchanged","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L70-L70"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toConfig</span> : <a href=\"./Mathlib/Util/AtomM/Recurse.html#Mathlib.Tactic.AtomM.Recurse.Config\">AtomM.Recurse.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">failIfUnchanged</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mode</span> : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">RingMode</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Config</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.mk","kind":"ctor","line":68,"name":"Mathlib.Tactic.RingNF.Config.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L68-L68"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.toConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">toConfig</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/AtomM/Recurse.html#Mathlib.Tactic.AtomM.Recurse.Config\">AtomM.Recurse.Config</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.toConfig","kind":"def","line":68,"name":"Mathlib.Tactic.RingNF.Config.toConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L68-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_extends\">extends</span> <a href=\"./Mathlib/Util/AtomM/Recurse.html#Mathlib.Tactic.AtomM.Recurse.Config\">Mathlib.Tactic.AtomM.Recurse.Config</a><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Configuration for `ring_nf`. ","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config","kind":"structure","line":67,"name":"Mathlib.Tactic.RingNF.Config","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L67-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instReprRingMode.repr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instReprRingMode</span>.<span class=\"name\">repr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">RingMode</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Std.Format</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instReprRingMode.repr","kind":"def","line":65,"name":"Mathlib.Tactic.RingNF.instReprRingMode.repr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L65-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instReprRingMode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instReprRingMode</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">RingMode</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instReprRingMode","kind":"instance","line":65,"name":"Mathlib.Tactic.RingNF.instReprRingMode","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L65-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instBEqRingMode.beq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instBEqRingMode</span>.<span class=\"name\">beq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">RingMode</a> → <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">RingMode</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instBEqRingMode.beq","kind":"def","line":65,"name":"Mathlib.Tactic.RingNF.instBEqRingMode.beq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L65-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instBEqRingMode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instBEqRingMode</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">RingMode</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instBEqRingMode","kind":"instance","line":65,"name":"Mathlib.Tactic.RingNF.instBEqRingMode","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L65-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instInhabitedRingMode.default\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instInhabitedRingMode</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">RingMode</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instInhabitedRingMode.default","kind":"def","line":65,"name":"Mathlib.Tactic.RingNF.instInhabitedRingMode.default","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L65-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instInhabitedRingMode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instInhabitedRingMode</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">RingMode</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instInhabitedRingMode","kind":"instance","line":65,"name":"Mathlib.Tactic.RingNF.instInhabitedRingMode","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L65-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode.raw\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">RingMode</span>.<span class=\"name\">raw</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">RingMode</a></div></div>","info":{"doc":"Raw form: the representation `ring` uses internally. ","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode.raw","kind":"ctor","line":63,"name":"Mathlib.Tactic.RingNF.RingMode.raw","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L63-L64"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode.SOP\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">RingMode</span>.<span class=\"name\">SOP</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">RingMode</a></div></div>","info":{"doc":"Sum-of-products form, like `x + x * y * 2 + z ^ 2`. ","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode.SOP","kind":"ctor","line":61,"name":"Mathlib.Tactic.RingNF.RingMode.SOP","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L61-L62"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">RingMode</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The normalization style for `ring_nf`. ","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode","kind":"inductive","line":59,"name":"Mathlib.Tactic.RingNF.RingMode","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L59-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExSum.isAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">isAtom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">arg</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$arg»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$arg»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"True if this represents an atomic expression. ","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExSum.isAtom","kind":"def","line":47,"name":"Mathlib.Tactic.Ring.ExSum.isAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L47-L52"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExProd.isAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">isAtom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">arg</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$arg»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$arg»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"True if this represents an atomic expression. ","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExProd.isAtom","kind":"def","line":42,"name":"Mathlib.Tactic.Ring.ExProd.isAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L42-L45"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExBase.isAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">isAtom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">arg</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$arg»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$arg»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"True if this represents an atomic expression. ","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExBase.isAtom","kind":"def","line":37,"name":"Mathlib.Tactic.Ring.ExBase.isAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/RingNF.lean#L37-L40"}}],"imports":["Init","Mathlib.Tactic.Ring.Basic","Mathlib.Tactic.Conv","Mathlib.Util.AtLocation","Mathlib.Util.AtomM.Recurse","Mathlib.Util.Qq","Mathlib.Tactic.Ring.Basic","Mathlib.Tactic.TryThis","Mathlib.Util.AtomM.Recurse"],"instances":[{"className":"Inhabited","name":"Mathlib.Tactic.RingNF.instInhabitedRingMode","typeNames":["Mathlib.Tactic.RingNF.RingMode"]},{"className":"BEq","name":"Mathlib.Tactic.RingNF.instBEqRingMode","typeNames":["Mathlib.Tactic.RingNF.RingMode"]},{"className":"Repr","name":"Mathlib.Tactic.RingNF.instReprRingMode","typeNames":["Mathlib.Tactic.RingNF.RingMode"]},{"className":"Inhabited","name":"Mathlib.Tactic.RingNF.instInhabitedConfig","typeNames":["Mathlib.Tactic.RingNF.Config"]},{"className":"BEq","name":"Mathlib.Tactic.RingNF.instBEqConfig","typeNames":["Mathlib.Tactic.RingNF.Config"]},{"className":"Repr","name":"Mathlib.Tactic.RingNF.instReprConfig","typeNames":["Mathlib.Tactic.RingNF.Config"]}],"name":"Mathlib.Tactic.Ring.RingNF"}