{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">convAbel!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel!","kind":"def","line":542,"name":"Mathlib.Tactic.Abel.convAbel!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L542-L543"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelConv","kind":"def","line":539,"name":"Mathlib.Tactic.Abel.abelConv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L539-L540"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">tacticAbel!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel!","kind":"def","line":536,"name":"Mathlib.Tactic.Abel.tacticAbel!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L536-L536"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel_nf!_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">convAbel_nf!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel_nf!_","kind":"def","line":529,"name":"Mathlib.Tactic.Abel.convAbel_nf!_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L529-L529"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">elabAbelNFConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>","info":{"doc":"Elaborator for the `abel_nf` tactic. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConv","kind":"def","line":517,"name":"Mathlib.Tactic.Abel.elabAbelNFConv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L517-L526"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFConv","kind":"def","line":514,"name":"Mathlib.Tactic.Abel.abelNFConv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L514-L515"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel_nf!__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">tacticAbel_nf!__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel_nf!__","kind":"def","line":511,"name":"Mathlib.Tactic.Abel.tacticAbel_nf!__","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L511-L512"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNF</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNF","kind":"def","line":501,"name":"Mathlib.Tactic.Abel.abelNF","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L501-L508"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Evaluate an expression into its `abel` normal form.\n\nThis is a variant of `Mathlib.Tactic.Abel.eval`, the main driver of the `abel` tactic.\nIt differs in\n* outputting a `Simp.Result`, rather than a `NormalExpr × Expr`;\n* throwing an error if the expression `e` is an atom for the `abel` tactic.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalExpr","kind":"def","line":485,"name":"Mathlib.Tactic.Abel.evalExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L485-L497"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.cleanup\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">cleanup</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"A cleanup routine, which simplifies expressions in `abel` normal form to a more human-friendly\nformat. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.cleanup","kind":"def","line":472,"name":"Mathlib.Tactic.Abel.cleanup","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L472-L483"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">elabAbelNFConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">AbelNF.Config</a></span></span></div></div>","info":{"doc":"Function elaborating `AbelNF.Config`. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConfig","kind":"def","line":469,"name":"Mathlib.Tactic.Abel.elabAbelNFConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L469-L470"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">mode</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">AbelMode</a></div></div>","info":{"doc":"The normalization style. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mode","kind":"def","line":467,"name":"Mathlib.Tactic.Abel.AbelNF.Config.mode","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L467-L467"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toConfig</span> : <a href=\"./Mathlib/Util/AtomM/Recurse.html#Mathlib.Tactic.AtomM.Recurse.Config\">AtomM.Recurse.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mode</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">AbelMode</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Config</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mk","kind":"ctor","line":465,"name":"Mathlib.Tactic.Abel.AbelNF.Config.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L465-L465"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.toConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">toConfig</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/AtomM/Recurse.html#Mathlib.Tactic.AtomM.Recurse.Config\">AtomM.Recurse.Config</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.toConfig","kind":"def","line":465,"name":"Mathlib.Tactic.Abel.AbelNF.Config.toConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L465-L467"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_extends\">extends</span> <a href=\"./Mathlib/Util/AtomM/Recurse.html#Mathlib.Tactic.AtomM.Recurse.Config\">Mathlib.Tactic.AtomM.Recurse.Config</a><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Configuration for `abel_nf`. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config","kind":"structure","line":464,"name":"Mathlib.Tactic.Abel.AbelNF.Config","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L464-L467"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.raw\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelMode</span>.<span class=\"name\">raw</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">AbelMode</a></div></div>","info":{"doc":"Raw form: the representation `abel` uses internally. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.raw","kind":"ctor","line":461,"name":"Mathlib.Tactic.Abel.AbelMode.raw","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L461-L462"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelMode</span>.<span class=\"name\">term</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">AbelMode</a></div></div>","info":{"doc":"The default form ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.term","kind":"ctor","line":459,"name":"Mathlib.Tactic.Abel.AbelMode.term","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L459-L460"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelMode</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The normalization style for `abel_nf`. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode","kind":"inductive","line":457,"name":"Mathlib.Tactic.Abel.AbelMode","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L457-L462"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">isAtom</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"True if this represents an atomic expression. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom","kind":"def","line":452,"name":"Mathlib.Tactic.Abel.NormalExpr.isAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L452-L455"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">termg_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative group. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg_eq","kind":"theorem","line":449,"name":"Mathlib.Tactic.Abel.termg_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L449-L450"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_eq","kind":"theorem","line":448,"name":"Mathlib.Tactic.Abel.term_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L448-L448"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel1!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!","kind":"def","line":446,"name":"Mathlib.Tactic.Abel.abel1!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L446-L446"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1","kind":"def","line":428,"name":"Mathlib.Tactic.Abel.abel1","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L428-L443"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.isAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">isAtom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Determine whether `e` will be handled as an atom by the `abel` tactic. The `match` in this\nfunction should be preserved to be parallel in case-matching to that in the\n`Mathlib.Tactic.Abel.eval` metaprogram. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.isAtom","kind":"def","line":405,"name":"Mathlib.Tactic.Abel.isAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L405-L426"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">eval</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> (<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"Evaluate an expression into its `abel` normal form, by recursing into subexpressions. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval","kind":"opaque","line":359,"name":"Mathlib.Tactic.Abel.eval","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L359-L403"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalSMul'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eval</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> (<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">is_smulg</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">orig </span><span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> (<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"Normalize a term `orig` of the form `smul e₁ e₂` or `smulg e₁ e₂`.\nNormalized terms use `smul` for monoids and `smulg` for groups,\nso there are actually four cases to handle:\n* Using `smul` in a monoid just simplifies the pieces using `subst_into_smul`\n* Using `smulg` in a group just simplifies the pieces using `subst_into_smulg`\n* Using `smul a b` in a group requires converting `a` from a nat to an int and\n  then simplifying `smulg ↑a b` using `subst_into_smul_upcast`\n* Using `smulg` in a monoid is impossible (or at least out of scope),\n  because you need a group argument to write a `smulg` term ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'","kind":"def","line":329,"name":"Mathlib.Tactic.Abel.evalSMul'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L329-L357"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_negg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_negg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">ta </span><span class=\"fn\">t</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pra</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">ta</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prt</span> : <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">ta</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_negg","kind":"theorem","line":325,"name":"Mathlib.Tactic.Abel.subst_into_negg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L325-L327"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_addg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_addg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l </span><span class=\"fn\">r </span><span class=\"fn\">tl </span><span class=\"fn\">tr </span><span class=\"fn\">t</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prl</span> : <span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prr</span> : <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prt</span> : <span class=\"fn\">tl</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">tr</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_addg","kind":"theorem","line":321,"name":"Mathlib.Tactic.Abel.subst_into_addg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L321-L323"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l </span><span class=\"fn\">r </span><span class=\"fn\">tl </span><span class=\"fn\">tr </span><span class=\"fn\">t</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prl</span> : <span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prr</span> : <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prt</span> : <span class=\"fn\">tl</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">tr</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_add","kind":"theorem","line":317,"name":"Mathlib.Tactic.Abel.subst_into_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L317-L319"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_smul_upcast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tl</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">zl</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tr </span><span class=\"fn\">t</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prl₁</span> : <span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prl₂</span> : <span class=\"fn\">↑<span class=\"fn\">tl</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">zl</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prr</span> : <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prt</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">zl</span> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">smul</a> <span class=\"fn\">l</span> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast","kind":"theorem","line":312,"name":"Mathlib.Tactic.Abel.subst_into_smul_upcast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L312-L315"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tl</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tr </span><span class=\"fn\">t</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prl</span> : <span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prr</span> : <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prt</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">tl</span> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">l</span> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg","kind":"theorem","line":308,"name":"Mathlib.Tactic.Abel.subst_into_smulg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L308-L310"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tl</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tr </span><span class=\"fn\">t</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prl</span> : <span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prr</span> : <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prt</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">smul</a> <span class=\"fn\">tl</span> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">smul</a> <span class=\"fn\">l</span> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul","kind":"theorem","line":304,"name":"Mathlib.Tactic.Abel.subst_into_smul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L304-L306"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_zsmul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_zsmul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_zsmul","kind":"theorem","line":301,"name":"Mathlib.Tactic.Abel.unfold_zsmul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L301-L302"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smulg","kind":"theorem","line":298,"name":"Mathlib.Tactic.Abel.unfold_smulg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L298-L299"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">smul</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smul","kind":"theorem","line":295,"name":"Mathlib.Tactic.Abel.unfold_smul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L295-L296"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_sub\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_sub</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#SubtractionMonoid\">SubtractionMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_sub","kind":"theorem","line":292,"name":"Mathlib.Tactic.Abel.unfold_sub","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L292-L293"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalAtom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> (<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"Interpret an expression as an atom for `abel`'s normal form. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom","kind":"def","line":283,"name":"Mathlib.Tactic.Abel.evalAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L283-L290"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pfg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atom_pfg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">x'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">1</span> <span class=\"fn\">x'</span> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pfg","kind":"theorem","line":280,"name":"Mathlib.Tactic.Abel.term_atom_pfg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L280-L281"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atom_pf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">x'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">1</span> <span class=\"fn\">x'</span> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pf","kind":"theorem","line":278,"name":"Mathlib.Tactic.Abel.term_atom_pf","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L278-L279"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atomg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atomg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">1</span> <span class=\"fn\">x</span> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atomg","kind":"theorem","line":277,"name":"Mathlib.Tactic.Abel.term_atomg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L277-L277"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">1</span> <span class=\"fn\">x</span> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom","kind":"theorem","line":276,"name":"Mathlib.Tactic.Abel.term_atom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L276-L276"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalSMul</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> (<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Auxiliary function for `evalSMul'`.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul","kind":"def","line":265,"name":"Mathlib.Tactic.Abel.evalSMul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L265-L274"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c </span><span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n'</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">c</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">c</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smulg","kind":"theorem","line":260,"name":"Mathlib.Tactic.Abel.term_smulg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L260-L263"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c </span><span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">smul</a> <span class=\"fn\">c</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">smul</a> <span class=\"fn\">c</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smul","kind":"theorem","line":255,"name":"Mathlib.Tactic.Abel.term_smul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L255-L258"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">c</span> <span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smulg","kind":"theorem","line":252,"name":"Mathlib.Tactic.Abel.zero_smulg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L252-L253"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">smul</a> <span class=\"fn\">c</span> <span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smul","kind":"theorem","line":249,"name":"Mathlib.Tactic.Abel.zero_smul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L249-L250"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"A synonym for `•`, used internally in `abel`. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg","kind":"def","line":246,"name":"Mathlib.Tactic.Abel.smulg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L246-L247"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"A synonym for `•`, used internally in `abel`. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul","kind":"def","line":244,"name":"Mathlib.Tactic.Abel.smul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L244-L245"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalNeg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalNeg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> (<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Interpret a negated expression in `abel`'s normal form.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalNeg","kind":"def","line":231,"name":"Mathlib.Tactic.Abel.evalNeg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L231-L242"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n'</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_neg","kind":"theorem","line":227,"name":"Mathlib.Tactic.Abel.term_neg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L227-L229"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAdd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalAdd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> → <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> (<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Interpret the sum of two expressions in `abel`'s normal form.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAdd","kind":"opaque","line":199,"name":"Mathlib.Tactic.Abel.evalAdd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L199-L225"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">0</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_termg","kind":"theorem","line":196,"name":"Mathlib.Tactic.Abel.zero_termg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L196-L197"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">0</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_term","kind":"theorem","line":193,"name":"Mathlib.Tactic.Abel.zero_term","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L193-L194"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n₁</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a₁</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n₂</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n'</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\">n₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">n₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n₁</span> <span class=\"fn\">x</span> <span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n₂</span> <span class=\"fn\">x</span> <span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_termg","kind":"theorem","line":187,"name":"Mathlib.Tactic.Abel.term_add_termg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L187-L191"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n₁</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a₁</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\">n₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">n₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n₁</span> <span class=\"fn\">x</span> <span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n₂</span> <span class=\"fn\">x</span> <span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_term","kind":"theorem","line":183,"name":"Mathlib.Tactic.Abel.term_add_term","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L183-L185"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_constg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_constg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a </span><span class=\"fn\">k </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_constg","kind":"theorem","line":179,"name":"Mathlib.Tactic.Abel.term_add_constg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L179-L181"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_const\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_const</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a </span><span class=\"fn\">k </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_const","kind":"theorem","line":175,"name":"Mathlib.Tactic.Abel.term_add_const","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L175-L177"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">const_add_termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_termg","kind":"theorem","line":171,"name":"Mathlib.Tactic.Abel.const_add_termg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L171-L173"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">const_add_term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_term","kind":"theorem","line":167,"name":"Mathlib.Tactic.Abel.const_add_term","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L167-L169"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">zero'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a></span></div></div>","info":{"doc":"Construct the normal form representing zero. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'","kind":"def","line":162,"name":"Mathlib.Tactic.Abel.NormalExpr.zero'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L162-L163"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">term'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a></span></div></div>","info":{"doc":"Construct the normal form representing a single term. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'","kind":"def","line":158,"name":"Mathlib.Tactic.Abel.NormalExpr.term'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L158-L160"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">instCoeNormalExprExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr","kind":"instance","line":156,"name":"Mathlib.Tactic.Abel.instCoeNormalExprExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L156-L156"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">e</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Extract the expression from a normal form. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e","kind":"def","line":151,"name":"Mathlib.Tactic.Abel.NormalExpr.e","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L151-L154"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">instInhabitedNormalExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr","kind":"instance","line":149,"name":"Mathlib.Tactic.Abel.instInhabitedNormalExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L149-L149"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr.default\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">instInhabitedNormalExpr</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr.default","kind":"def","line":149,"name":"Mathlib.Tactic.Abel.instInhabitedNormalExpr.default","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L149-L149"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">nterm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm","kind":"ctor","line":148,"name":"Mathlib.Tactic.Abel.NormalExpr.nterm","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L148-L148"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">zero</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero","kind":"ctor","line":147,"name":"Mathlib.Tactic.Abel.NormalExpr.zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L147-L147"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A normal form for `abel`.\nExpressions are represented as a list of terms of the form `e = n • x`,\nwhere `n : ℤ` and `x` is an arbitrary element of the additive commutative monoid or group.\nWe explicitly track the `Expr` forms of `e` and `n`, even though they could be reconstructed,\nfor efficiency. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr","kind":"inductive","line":141,"name":"Mathlib.Tactic.Abel.NormalExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L141-L149"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.intToExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">intToExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Interpret an integer as a coefficient to a term. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.intToExpr","kind":"def","line":137,"name":"Mathlib.Tactic.Abel.intToExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L137-L139"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">mkTerm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">x </span><span class=\"fn\">a</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Evaluate a term with coefficient `n`, atom `x` and successor terms `a`. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm","kind":"def","line":134,"name":"Mathlib.Tactic.Abel.mkTerm","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L134-L135"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative group. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg","kind":"def","line":131,"name":"Mathlib.Tactic.Abel.termg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L131-L132"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative monoid. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term","kind":"def","line":129,"name":"Mathlib.Tactic.Abel.term","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L129-L130"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">iapp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Apply the function `n : ∀ {α} [AddComm{Monoid,Group} α]` to the given list of arguments.\n\nWill use the `AddComm{Monoid,Group}` instance that has been cached in the context.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp","kind":"def","line":121,"name":"Mathlib.Tactic.Abel.iapp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L121-L127"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">addG</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>","info":{"doc":"Add the letter \"g\" to the end of the name, e.g. turning `term` into `termg`.\n\nThis is used to choose between declarations taking `AddCommMonoid` and those\ntaking `AddCommGroup` instances.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG","kind":"def","line":112,"name":"Mathlib.Tactic.Abel.addG","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L112-L119"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mkApp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">mkApp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">inst</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Apply the function `n : ∀ {α} [inst α], _` to the implicit parameters in the\ncontext, and the given list of arguments.\n\nCompared to `context.app`, this takes the name of the typeclass, rather than an\ninferred typeclass instance.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mkApp","kind":"def","line":103,"name":"Mathlib.Tactic.Abel.Context.mkApp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L103-L110"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">app</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Apply the function `n : ∀ {α} [inst : AddWhatever α], _` to the\nimplicit parameters in the context, and the given list of arguments. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app","kind":"def","line":98,"name":"Mathlib.Tactic.Abel.Context.app","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L98-L101"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">M</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The monad for `Abel` contains, in addition to the `AtomM` state,\nsome information about the current type we are working over, so that we can consistently\nuse group lemmas or monoid lemmas as appropriate. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M","kind":"def","line":93,"name":"Mathlib.Tactic.Abel.M","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L93-L96"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkContext\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">mkContext</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a></span></div></div>","info":{"doc":"Populate a `context` object for evaluating `e`. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkContext","kind":"def","line":81,"name":"Mathlib.Tactic.Abel.mkContext","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L81-L91"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.inst\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">inst</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>","info":{"doc":"The `AddCommGroup α` or `AddCommMonoid α` expression. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.inst","kind":"def","line":79,"name":"Mathlib.Tactic.Abel.Context.inst","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L79-L79"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.isGroup\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">isGroup</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Specify whether we are in an additive commutative group or an additive commutative monoid. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.isGroup","kind":"def","line":77,"name":"Mathlib.Tactic.Abel.Context.isGroup","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L77-L77"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α0\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">α0</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>","info":{"doc":"The expression representing `0 : α`. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α0","kind":"def","line":75,"name":"Mathlib.Tactic.Abel.Context.α0","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L75-L75"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.univ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">univ</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a></div></div>","info":{"doc":"The universe level for `α`. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.univ","kind":"def","line":73,"name":"Mathlib.Tactic.Abel.Context.univ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L73-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">α</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>","info":{"doc":"The type of the ambient additive commutative group or monoid. ","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α","kind":"def","line":71,"name":"Mathlib.Tactic.Abel.Context.α","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L71-L71"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">univ</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α0</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">isGroup</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mk","kind":"ctor","line":69,"name":"Mathlib.Tactic.Abel.Context.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L69-L69"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The `Context` for a call to `abel`.\n\nStores a few options for this call, and caches some common subexpressions\nsuch as typeclass instances and `0 : α`.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context","kind":"structure","line":64,"name":"Mathlib.Tactic.Abel.Context","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L64-L79"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel","kind":"def","line":31,"name":"Mathlib.Tactic.Abel.abel","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Abel.lean#L31-L62"}}],"imports":["Init","Mathlib.Util.AtomM.Recurse","Mathlib.Tactic.NormNum.Basic","Mathlib.Tactic.TryThis","Mathlib.Util.AtomM.Recurse"],"instances":[{"className":"Inhabited","name":"Mathlib.Tactic.Abel.instInhabitedNormalExpr","typeNames":["Mathlib.Tactic.Abel.NormalExpr"]},{"className":"Coe","name":"Mathlib.Tactic.Abel.instCoeNormalExprExpr","typeNames":["Mathlib.Tactic.Abel.NormalExpr","Lean.Expr"]}],"name":"Mathlib.Tactic.Abel"}