{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Subsingleton.html#Mathlib.Tactic.elabSubsingletonInsts\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabSubsingletonInsts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instTerms?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.AbstractMVarsResult\">Lean.Meta.AbstractMVarsResult</a>))</span></span></div></div>","info":{"doc":"Elaborates the terms like how `Lean.Elab.Tactic.addSimpTheorem` does,\nabstracting their metavariables.\n","docLink":"./Mathlib/Tactic/Subsingleton.html#Mathlib.Tactic.elabSubsingletonInsts","kind":"def","line":144,"name":"Mathlib.Tactic.elabSubsingletonInsts","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Subsingleton.lean#L144-L182"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Subsingleton.html#Mathlib.Tactic.subsingletonStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">subsingletonStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The `subsingleton` tactic tries to prove a goal of the form `x = y` or `x ≍ y`\nusing the fact that the types involved are *subsingletons*\n(a type with exactly zero or one terms).\nTo a first approximation, it does `apply Subsingleton.elim`.\nAs a nicety, `subsingleton` first runs the `intros` tactic.\n\n- If the goal is an equality, it either closes the goal or fails.\n- `subsingleton [inst1, inst2, ...]` can be used to add additional `Subsingleton` instances\n  to the local context. This can be more flexible than\n  `have := inst1; have := inst2; ...; subsingleton` since the tactic does not require that\n  all placeholders be solved for.\n\nTechniques the `subsingleton` tactic can apply:\n- proof irrelevance\n- heterogeneous proof irrelevance (via `proof_irrel_heq`)\n- using `Subsingleton` (via `Subsingleton.elim`)\n- proving `BEq` instances are equal if they are both lawful (via `lawful_beq_subsingleton`)\n\n### Properties\n\nThe tactic is careful not to accidentally specialize `Sort _` to `Prop`,\navoiding the following surprising behavior of `apply Subsingleton.elim`:\n```lean\nexample (α : Sort _) (x y : α) : x = y := by apply Subsingleton.elim\n```\nThe reason this `example` goes through is that\nit applies the `∀ (p : Prop), Subsingleton p` instance,\nspecializing the universe level metavariable in `Sort _` to `0`.\n","docLink":"./Mathlib/Tactic/Subsingleton.html#Mathlib.Tactic.subsingletonStx","kind":"def","line":110,"name":"Mathlib.Tactic.subsingletonStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Subsingleton.lean#L110-L140"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Subsingleton.html#Lean.MVarId.subsingleton\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">subsingleton</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">insts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Term</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.AbstractMVarsResult\">Meta.AbstractMVarsResult</a>)</span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Closes the goal `g` whose target is an `Eq` or `HEq` by appealing to the fact that the types\nare subsingletons.\nFails if it cannot find a way to do this.\n\nHas support for showing `BEq` instances are equal if they have `LawfulBEq` instances.\n","docLink":"./Mathlib/Tactic/Subsingleton.html#Lean.MVarId.subsingleton","kind":"def","line":60,"name":"Lean.MVarId.subsingleton","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Subsingleton.lean#L60-L106"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Subsingleton.html#Lean.Meta.synthSubsingletonInst\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">synthSubsingletonInst</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ty</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">insts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Term</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.AbstractMVarsResult\">AbstractMVarsResult</a>)</span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Synthesizes a `Subsingleton ty` instance with the additional local instances made available. ","docLink":"./Mathlib/Tactic/Subsingleton.html#Lean.Meta.synthSubsingletonInst","kind":"def","line":29,"name":"Lean.Meta.synthSubsingletonInst","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Subsingleton.lean#L29-L58"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Subsingleton.html#Lean.Meta.mkSubsingleton\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkSubsingleton</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ty</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Returns the expression `Subsingleton ty`. ","docLink":"./Mathlib/Tactic/Subsingleton.html#Lean.Meta.mkSubsingleton","kind":"def","line":24,"name":"Lean.Meta.mkSubsingleton","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Subsingleton.lean#L24-L27"}}],"imports":["Init","Mathlib.Logic.Basic","Mathlib.Tactic.Basic"],"instances":[],"name":"Mathlib.Tactic.Subsingleton"}