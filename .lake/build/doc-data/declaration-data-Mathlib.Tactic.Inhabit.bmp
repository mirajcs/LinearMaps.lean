{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.evalInhabit\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalInhabit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h_name</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Ident\">Ident</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">term</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>","info":{"doc":"`evalInhabit` takes in the MVarId of the main goal, runs the core portion of the inhabit tactic,\nand returns the resulting MVarId ","docLink":"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.evalInhabit","kind":"def","line":38,"name":"Lean.Elab.Tactic.evalInhabit","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Inhabit.lean#L38-L55"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.inhabit\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">inhabit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`inhabit α` tries to derive a `Nonempty α` instance and\nthen uses it to make an `Inhabited α` instance.\nIf the target is a `Prop`, this is done constructively. Otherwise, it uses `Classical.choice`.\n","docLink":"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.inhabit","kind":"def","line":31,"name":"Lean.Elab.Tactic.inhabit","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Inhabit.lean#L31-L36"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.nonempty_prop_to_inhabited\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">nonempty_prop_to_inhabited</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α_nonempty</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Derives `Inhabited α` from `Nonempty α` without `Classical.choice`\nassuming `α` is of type `Prop`. ","docLink":"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.nonempty_prop_to_inhabited","kind":"def","line":26,"name":"Lean.Elab.Tactic.nonempty_prop_to_inhabited","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Inhabit.lean#L26-L29"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.nonempty_to_inhabited\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">nonempty_to_inhabited</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"Derives `Inhabited α` from `Nonempty α` with `Classical.choice`. ","docLink":"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.nonempty_to_inhabited","kind":"def","line":22,"name":"Lean.Elab.Tactic.nonempty_to_inhabited","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Inhabit.lean#L22-L24"}}],"imports":["Init","Lean.Elab.Tactic.ElabTerm","Mathlib.Tactic.TypeStar"],"instances":[],"name":"Mathlib.Tactic.Inhabit"}