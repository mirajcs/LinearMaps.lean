{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parFirst\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TacticM</span>.<span class=\"name\">parFirst</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cancel</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Runs a list of TacticM computations in parallel and returns the first successful result\n(by completion order, not list order).\n\nIf `cancel := true` (the default), cancels all remaining tasks after the first success.\n","docLink":"./Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parFirst","kind":"def","line":649,"name":"Lean.Elab.Tactic.TacticM.parFirst","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L649-L663"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.par'\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TacticM</span>.<span class=\"name\">par'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span>)</span></span></div></div>","info":{"doc":"Runs a list of TacticM computations in parallel and collects results in the original order,\ndiscarding state information.\n\nUnlike `par`, this doesn't return state information from tasks.\n\nThe final TacticM state is restored to the initial state (before tasks ran).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.par'","kind":"def","line":628,"name":"Lean.Elab.Tactic.TacticM.par'","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L628-L647"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.par\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TacticM</span>.<span class=\"name\">par</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Tactic.SavedState\">SavedState</a>))</span>)</span></span></div></div>","info":{"doc":"Runs a list of TacticM computations in parallel and collects results in the original order,\nincluding the saved state after each task completes.\n\nUnlike `parIter`, this waits for all tasks to complete and returns results\nin the same order as the input list, not in completion order.\n\nResults are wrapped in `Except Exception (α × Tactic.SavedState)` so that errors in individual\ntasks don't stop the collection - you can observe all results including which tasks failed.\n\nThe final TacticM state is restored to the initial state (before tasks ran).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.par","kind":"def","line":602,"name":"Lean.Elab.Tactic.TacticM.par","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L602-L626"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parIterGreedy\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TacticM</span>.<span class=\"name\">parIterGreedy</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">(<a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span>)</span></span></div></div>","info":{"doc":"Runs a list of TacticM computations in parallel (without cancellation hook).\n\nReturns an iterator that yields results in completion order, wrapped in `Except Exception α`.\n","docLink":"./Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parIterGreedy","kind":"def","line":594,"name":"Lean.Elab.Tactic.TacticM.parIterGreedy","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L594-L600"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parIterGreedyWithCancel\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TacticM</span>.<span class=\"name\">parIterGreedyWithCancel</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> (<span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span></span>)</span></div></div>","info":{"doc":"Runs a list of TacticM computations in parallel and returns:\n* a combined cancellation hook for all tasks, and\n* an iterator that yields results in completion order (greedily).\n\nThe iterator runs in TacticM, and as it yields each result, it updates the TacticM state\nto reflect the state when that particular task completed. This means the state is\nthreaded through the iteration in task completion order.\n\nResults are wrapped in `Except Exception α` so that errors in individual tasks don't stop\nthe iteration - you can observe all results including which tasks failed.\n\nThe iterator will terminate after all jobs complete (assuming they all do complete).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parIterGreedyWithCancel","kind":"def","line":568,"name":"Lean.Elab.Tactic.TacticM.parIterGreedyWithCancel","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L568-L592"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parIter\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TacticM</span>.<span class=\"name\">parIter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">(<a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span>)</span></span></div></div>","info":{"doc":"Runs a list of TacticM computations in parallel (without cancellation hook).\n\nReturns an iterator that yields results in original order, wrapped in `Except Exception α`.\n","docLink":"./Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parIter","kind":"def","line":560,"name":"Lean.Elab.Tactic.TacticM.parIter","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L560-L566"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parIterWithCancel\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TacticM</span>.<span class=\"name\">parIterWithCancel</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> (<span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span></span>)</span></div></div>","info":{"doc":"Runs a list of TacticM computations in parallel and returns:\n* a combined cancellation hook for all tasks, and\n* an iterator that yields results in original order.\n\nThe iterator runs in TacticM, and as it yields each result, it updates the TacticM state\nto reflect the state when that particular task completed. This means the state is\nthreaded through the iteration in the order of the original list.\n\nResults are wrapped in `Except Exception α` so that errors in individual tasks don't stop\nthe iteration - you can observe all results including which tasks failed.\n\nThe iterator will terminate after all jobs complete (assuming they all do complete).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parIterWithCancel","kind":"def","line":534,"name":"Lean.Elab.Tactic.TacticM.parIterWithCancel","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L534-L558"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parFirst\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">TermElabM</span>.<span class=\"name\">parFirst</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cancel</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Runs a list of TermElabM computations in parallel and returns the first successful result\n(by completion order, not list order).\n\nIf `cancel := true` (the default), cancels all remaining tasks after the first success.\n","docLink":"./Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parFirst","kind":"def","line":512,"name":"Lean.Elab.Term.TermElabM.parFirst","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L512-L526"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.par'\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">TermElabM</span>.<span class=\"name\">par'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span>)</span></span></div></div>","info":{"doc":"Runs a list of TermElabM computations in parallel and collects results in the original order,\ndiscarding state information.\n\nUnlike `par`, this doesn't return state information from tasks.\n\nThe final TermElabM state is restored to the initial state (before tasks ran).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.par'","kind":"def","line":491,"name":"Lean.Elab.Term.TermElabM.par'","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L491-L510"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.par\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">TermElabM</span>.<span class=\"name\">par</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.SavedState\">SavedState</a>))</span>)</span></span></div></div>","info":{"doc":"Runs a list of TermElabM computations in parallel and collects results in the original order,\nincluding the saved state after each task completes.\n\nUnlike `parIter`, this waits for all tasks to complete and returns results\nin the same order as the input list, not in completion order.\n\nResults are wrapped in `Except Exception (α × Term.SavedState)` so that errors in individual\ntasks don't stop the collection - you can observe all results including which tasks failed.\n\nThe final TermElabM state is restored to the initial state (before tasks ran).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.par","kind":"def","line":465,"name":"Lean.Elab.Term.TermElabM.par","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L465-L489"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parIterGreedy\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">TermElabM</span>.<span class=\"name\">parIterGreedy</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span>)</span></span></div></div>","info":{"doc":"Runs a list of TermElabM computations in parallel (without cancellation hook).\n\nReturns an iterator that yields results in completion order, wrapped in `Except Exception α`.\n","docLink":"./Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parIterGreedy","kind":"def","line":457,"name":"Lean.Elab.Term.TermElabM.parIterGreedy","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L457-L463"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parIterGreedyWithCancel\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">TermElabM</span>.<span class=\"name\">parIterGreedyWithCancel</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> (<span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span></span>)</span></div></div>","info":{"doc":"Runs a list of TermElabM computations in parallel and returns:\n* a combined cancellation hook for all tasks, and\n* an iterator that yields results in completion order (greedily).\n\nThe iterator runs in TermElabM, and as it yields each result, it updates the TermElabM state\nto reflect the state when that particular task completed. This means the state is\nthreaded through the iteration in task completion order.\n\nResults are wrapped in `Except Exception α` so that errors in individual tasks don't stop\nthe iteration - you can observe all results including which tasks failed.\n\nThe iterator will terminate after all jobs complete (assuming they all do complete).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parIterGreedyWithCancel","kind":"def","line":431,"name":"Lean.Elab.Term.TermElabM.parIterGreedyWithCancel","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L431-L455"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parIter\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">TermElabM</span>.<span class=\"name\">parIter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span>)</span></span></div></div>","info":{"doc":"Runs a list of TermElabM computations in parallel (without cancellation hook).\n\nReturns an iterator that yields results in original order, wrapped in `Except Exception α`.\n","docLink":"./Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parIter","kind":"def","line":423,"name":"Lean.Elab.Term.TermElabM.parIter","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L423-L429"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parIterWithCancel\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">TermElabM</span>.<span class=\"name\">parIterWithCancel</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> (<span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span></span>)</span></div></div>","info":{"doc":"Runs a list of TermElabM computations in parallel and returns:\n* a combined cancellation hook for all tasks, and\n* an iterator that yields results in original order.\n\nThe iterator runs in TermElabM, and as it yields each result, it updates the TermElabM state\nto reflect the state when that particular task completed. This means the state is\nthreaded through the iteration in the order of the original list.\n\nResults are wrapped in `Except Exception α` so that errors in individual tasks don't stop\nthe iteration - you can observe all results including which tasks failed.\n\nThe iterator will terminate after all jobs complete (assuming they all do complete).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parIterWithCancel","kind":"def","line":397,"name":"Lean.Elab.Term.TermElabM.parIterWithCancel","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L397-L421"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Meta.MetaM.parFirst\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MetaM</span>.<span class=\"name\">parFirst</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cancel</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Runs a list of MetaM computations in parallel and returns the first successful result\n(by completion order, not list order).\n\nIf `cancel := true` (the default), cancels all remaining tasks after the first success.\n","docLink":"./Lean/Elab/Parallel.html#Lean.Meta.MetaM.parFirst","kind":"def","line":375,"name":"Lean.Meta.MetaM.parFirst","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L375-L389"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIterGreedy\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MetaM</span>.<span class=\"name\">parIterGreedy</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span>)</span></span></div></div>","info":{"doc":"Runs a list of MetaM computations in parallel (without cancellation hook).\n\nReturns an iterator that yields results in completion order, wrapped in `Except Exception α`.\n","docLink":"./Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIterGreedy","kind":"def","line":367,"name":"Lean.Meta.MetaM.parIterGreedy","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L367-L373"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIterGreedyWithCancel\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MetaM</span>.<span class=\"name\">parIterGreedyWithCancel</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span></span>)</span></div></div>","info":{"doc":"Runs a list of MetaM computations in parallel and returns:\n* a combined cancellation hook for all tasks, and\n* an iterator that yields results in completion order (greedily).\n\nThe iterator runs in MetaM, and as it yields each result, it updates the MetaM state\nto reflect the state when that particular task completed. This means the state is\nthreaded through the iteration in task completion order.\n\nResults are wrapped in `Except Exception α` so that errors in individual tasks don't stop\nthe iteration - you can observe all results including which tasks failed.\n\nThe iterator will terminate after all jobs complete (assuming they all do complete).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIterGreedyWithCancel","kind":"def","line":341,"name":"Lean.Meta.MetaM.parIterGreedyWithCancel","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L341-L365"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIter\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MetaM</span>.<span class=\"name\">parIter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span>)</span></span></div></div>","info":{"doc":"Runs a list of MetaM computations in parallel (without cancellation hook).\n\nReturns an iterator that yields results in original order, wrapped in `Except Exception α`.\n","docLink":"./Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIter","kind":"def","line":333,"name":"Lean.Meta.MetaM.parIter","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L333-L339"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIterWithCancel\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MetaM</span>.<span class=\"name\">parIterWithCancel</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span></span>)</span></div></div>","info":{"doc":"Runs a list of MetaM computations in parallel and returns:\n* a combined cancellation hook for all tasks, and\n* an iterator that yields results in original order.\n\nThe iterator runs in MetaM, and as it yields each result, it updates the MetaM state\nto reflect the state when that particular task completed. This means the state is\nthreaded through the iteration in the order of the original list.\n\nResults are wrapped in `Except Exception α` so that errors in individual tasks don't stop\nthe iteration - you can observe all results including which tasks failed.\n\nThe iterator will terminate after all jobs complete (assuming they all do complete).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIterWithCancel","kind":"def","line":307,"name":"Lean.Meta.MetaM.parIterWithCancel","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L307-L331"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Meta.MetaM.par'\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MetaM</span>.<span class=\"name\">par'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span>)</span></span></div></div>","info":{"doc":"Runs a list of MetaM computations in parallel and collects results in the original order,\ndiscarding state information.\n\nUnlike `par`, this doesn't return state information from tasks.\n\nThe final MetaM state is restored to the initial state (before tasks ran).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Meta.MetaM.par'","kind":"def","line":286,"name":"Lean.Meta.MetaM.par'","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L286-L305"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Meta.MetaM.par\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">MetaM</span>.<span class=\"name\">par</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.SavedState\">SavedState</a>))</span>)</span></span></div></div>","info":{"doc":"Runs a list of MetaM computations in parallel and collects results in the original order,\nincluding the saved state after each task completes.\n\nUnlike `parIter`, this waits for all tasks to complete and returns results\nin the same order as the input list, not in completion order.\n\nResults are wrapped in `Except Exception (α × Meta.SavedState)` so that errors in individual\ntasks don't stop the collection - you can observe all results including which tasks failed.\n\nThe final MetaM state is restored to the initial state (before tasks ran).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Meta.MetaM.par","kind":"def","line":262,"name":"Lean.Meta.MetaM.par","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L262-L284"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Core.CoreM.parFirst\"><span class=\"name\">Lean</span>.<span class=\"name\">Core</span>.<span class=\"name\">CoreM</span>.<span class=\"name\">parFirst</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cancel</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Runs a list of CoreM computations in parallel and returns the first successful result\n(by completion order, not list order).\n\nIf `cancel := true` (the default), cancels all remaining tasks after the first success.\n","docLink":"./Lean/Elab/Parallel.html#Lean.Core.CoreM.parFirst","kind":"def","line":240,"name":"Lean.Core.CoreM.parFirst","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L240-L254"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Core.CoreM.par'\"><span class=\"name\">Lean</span>.<span class=\"name\">Core</span>.<span class=\"name\">CoreM</span>.<span class=\"name\">par'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span>)</span></span></div></div>","info":{"doc":"Runs a list of CoreM computations in parallel and collects results in the original order,\ndiscarding state information.\n\nUnlike `par`, this doesn't return state information from tasks.\n\nThe final CoreM state is restored to the initial state (before tasks ran).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Core.CoreM.par'","kind":"def","line":219,"name":"Lean.Core.CoreM.par'","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L219-L238"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Core.CoreM.par\"><span class=\"name\">Lean</span>.<span class=\"name\">Core</span>.<span class=\"name\">CoreM</span>.<span class=\"name\">par</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/CoreM.html#Lean.Core.SavedState\">SavedState</a>))</span>)</span></span></div></div>","info":{"doc":"Runs a list of CoreM computations in parallel and collects results in the original order,\nincluding the saved state after each task completes.\n\nUnlike `parIter`, this waits for all tasks to complete and returns results\nin the same order as the input list, not in completion order.\n\nResults are wrapped in `Except Exception (α × Core.SavedState)` so that errors in individual\ntasks don't stop the collection - you can observe all results including which tasks failed.\n\nThe final CoreM state is restored to the initial state (before tasks ran).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Core.CoreM.par","kind":"def","line":195,"name":"Lean.Core.CoreM.par","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L195-L217"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterGreedy\"><span class=\"name\">Lean</span>.<span class=\"name\">Core</span>.<span class=\"name\">CoreM</span>.<span class=\"name\">parIterGreedy</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">(<a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span>)</span></span></div></div>","info":{"doc":"Runs a list of CoreM computations in parallel (without cancellation hook).\n\nReturns an iterator that yields results in completion order, wrapped in `Except Exception α`.\n","docLink":"./Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterGreedy","kind":"def","line":187,"name":"Lean.Core.CoreM.parIterGreedy","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L187-L193"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterGreedyWithCancel\"><span class=\"name\">Lean</span>.<span class=\"name\">Core</span>.<span class=\"name\">CoreM</span>.<span class=\"name\">parIterGreedyWithCancel</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> (<span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span></span>)</span></div></div>","info":{"doc":"Runs a list of CoreM computations in parallel and returns:\n* a combined cancellation hook for all tasks, and\n* an iterator that yields results in completion order (greedily).\n\nThe iterator runs in CoreM, and as it yields each result, it updates the CoreM state\nto reflect the state when that particular task completed. This means the state is\nthreaded through the iteration in task completion order.\n\nResults are wrapped in `Except Exception α` so that errors in individual tasks don't stop\nthe iteration - you can observe all results including which tasks failed.\n\nThe iterator will terminate after all jobs complete (assuming they all do complete).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterGreedyWithCancel","kind":"def","line":161,"name":"Lean.Core.CoreM.parIterGreedyWithCancel","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L161-L185"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Core.CoreM.parIter\"><span class=\"name\">Lean</span>.<span class=\"name\">Core</span>.<span class=\"name\">CoreM</span>.<span class=\"name\">parIter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">(<a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span>)</span></span></div></div>","info":{"doc":"Runs a list of CoreM computations in parallel (without cancellation hook).\n\nReturns an iterator that yields results in original order, wrapped in `Except Exception α`.\n","docLink":"./Lean/Elab/Parallel.html#Lean.Core.CoreM.parIter","kind":"def","line":153,"name":"Lean.Core.CoreM.parIter","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L153-L159"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterWithCancel\"><span class=\"name\">Lean</span>.<span class=\"name\">Core</span>.<span class=\"name\">CoreM</span>.<span class=\"name\">parIterWithCancel</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">jobs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> (<span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterators.IterM\">Std.IterM</a> <a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Exception</a> <span class=\"fn\">α</span>)</span></span>)</span></div></div>","info":{"doc":"Runs a list of CoreM computations in parallel and returns:\n* a combined cancellation hook for all tasks, and\n* an iterator that yields results in original order.\n\nThe iterator runs in CoreM, and as it yields each result, it updates the CoreM state\nto reflect the state when that particular task completed. This means the state is\nthreaded through the iteration in the order of the original list.\n\nResults are wrapped in `Except Exception α` so that errors in individual tasks don't stop\nthe iteration - you can observe all results including which tasks failed.\n\nThe iterator will terminate after all jobs complete (assuming they all do complete).\n","docLink":"./Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterWithCancel","kind":"def","line":128,"name":"Lean.Core.CoreM.parIterWithCancel","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L128-L151"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Parallel.html#Std.Iterators.TaskIterator\"><span class=\"name\">Std</span>.<span class=\"name\">Iterators</span>.<span class=\"name\">TaskIterator</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> w</div></div>","info":{"doc":"Internal state for an iterator over tasks.\nMaintains the list of tasks that haven't completed yet.\n","docLink":"./Lean/Elab/Parallel.html#Std.Iterators.TaskIterator","kind":"structure","line":68,"name":"Std.Iterators.TaskIterator","sourceLink":"https://github.com/leanprover/lean4/blob/db93fe1608548721853390a10cd40580fe7d22ae/src/Lean/Elab/Parallel.lean#L68-L73"}}],"imports":["Lean.Elab.Task","Init.System.IO"],"instances":[],"name":"Lean.Elab.Parallel"}