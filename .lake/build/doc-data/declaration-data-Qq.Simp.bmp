{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.Simproc.ofQ\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">Simproc</span>.<span class=\"name\">ofQ</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proc</span> : <a href=\"./Qq/Simp.html#Lean.Meta.Simp.SimprocQ\">SimprocQ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Simproc</a></div></div>","info":{"doc":"Build a simproc with Qq-enabled typechecking of inputs and outputs.\n\nThis calls `inferTypeQ` on the expression and passes the arguments to `proc`. ","docLink":"./Qq/Simp.html#Lean.Meta.Simp.Simproc.ofQ","kind":"def","line":55,"name":"Lean.Meta.Simp.Simproc.ofQ","sourceLink":"https://github.com/leanprover-community/quote4/blob/bd58c9efe2086d56ca361807014141a860ddbf8c/Qq/Simp.lean#L55-L60"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.SimprocQ\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">SimprocQ</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A copy of `Lean.Meta.Simproc` with explicit types.\n\nSee `Simproc.ofQ` to construct terms of this type. ","docLink":"./Qq/Simp.html#Lean.Meta.Simp.SimprocQ","kind":"def","line":50,"name":"Lean.Meta.Simp.SimprocQ","sourceLink":"https://github.com/leanprover-community/quote4/blob/bd58c9efe2086d56ca361807014141a860ddbf8c/Qq/Simp.lean#L50-L53"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.StepQ.continue\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">StepQ</span>.<span class=\"name\">continue</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Qq/Simp.html#Lean.Meta.Simp.ResultQ\">ResultQ</a> <span class=\"fn\">e</span>)</span></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Qq/Simp.html#Lean.Meta.Simp.StepQ\">StepQ</a> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"For `pre` procedures, continue transformation by visiting subexpressions, and then\nexecuting `post` procedures.\n\nFor `post` procedures, this is equivalent to returning `visit`.\n","docLink":"./Qq/Simp.html#Lean.Meta.Simp.StepQ.continue","kind":"def","line":47,"name":"Lean.Meta.Simp.StepQ.continue","sourceLink":"https://github.com/leanprover-community/quote4/blob/bd58c9efe2086d56ca361807014141a860ddbf8c/Qq/Simp.lean#L47-L48"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.StepQ.visit\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">StepQ</span>.<span class=\"name\">visit</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Qq/Simp.html#Lean.Meta.Simp.ResultQ\">ResultQ</a> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Qq/Simp.html#Lean.Meta.Simp.StepQ\">StepQ</a> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"For `pre` procedures, the resulting expression is passed to `pre` again.\n\nFor `post` procedures, the resulting expression is passed to `pre` again IF\n`Simp.Config.singlePass := false` and resulting expression is not equal to initial expression.\n","docLink":"./Qq/Simp.html#Lean.Meta.Simp.StepQ.visit","kind":"def","line":45,"name":"Lean.Meta.Simp.StepQ.visit","sourceLink":"https://github.com/leanprover-community/quote4/blob/bd58c9efe2086d56ca361807014141a860ddbf8c/Qq/Simp.lean#L45-L46"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.StepQ.done\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">StepQ</span>.<span class=\"name\">done</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Qq/Simp.html#Lean.Meta.Simp.ResultQ\">ResultQ</a> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Qq/Simp.html#Lean.Meta.Simp.StepQ\">StepQ</a> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"For `pre` procedures, it returns the result without visiting any subexpressions.\n\nFor `post` procedures, it returns the result.\n","docLink":"./Qq/Simp.html#Lean.Meta.Simp.StepQ.done","kind":"def","line":43,"name":"Lean.Meta.Simp.StepQ.done","sourceLink":"https://github.com/leanprover-community/quote4/blob/bd58c9efe2086d56ca361807014141a860ddbf8c/Qq/Simp.lean#L43-L44"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.StepQ\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">StepQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A copy of `Meta.Simp.Step` with explicit types. ","docLink":"./Qq/Simp.html#Lean.Meta.Simp.StepQ","kind":"def","line":40,"name":"Lean.Meta.Simp.StepQ","sourceLink":"https://github.com/leanprover-community/quote4/blob/bd58c9efe2086d56ca361807014141a860ddbf8c/Qq/Simp.lean#L40-L41"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.ResultQ.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">ResultQ</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$expr»</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cache</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Qq/Simp.html#Lean.Meta.Simp.ResultQ\">ResultQ</a> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"A copy of `Meta.Simp.Result.mk` with explicit types. ","docLink":"./Qq/Simp.html#Lean.Meta.Simp.ResultQ.mk","kind":"def","line":33,"name":"Lean.Meta.Simp.ResultQ.mk","sourceLink":"https://github.com/leanprover-community/quote4/blob/bd58c9efe2086d56ca361807014141a860ddbf8c/Qq/Simp.lean#L33-L38"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.ResultQ\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">ResultQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A copy of `Meta.Simp.Result` with explicit types. ","docLink":"./Qq/Simp.html#Lean.Meta.Simp.ResultQ","kind":"def","line":30,"name":"Lean.Meta.Simp.ResultQ","sourceLink":"https://github.com/leanprover-community/quote4/blob/bd58c9efe2086d56ca361807014141a860ddbf8c/Qq/Simp.lean#L30-L31"}}],"imports":["Init","Qq.MetaM"],"instances":[],"name":"Qq.Simp"}