{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.ignorevariable?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Command</span>.<span class=\"name\">Variable</span>.<span class=\"name\">ignorevariable?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Linter/UnusedVariables.html#Lean.Linter.IgnoreFunction\">Lean.Linter.IgnoreFunction</a></div></div>","info":{"doc":"Hint for the unused variables linter. Copies the one for `variable`. ","docLink":"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.ignorevariable?","kind":"def","line":309,"name":"Mathlib.Command.Variable.ignorevariable?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Variable.lean#L309-L313"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.elabVariables\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Command</span>.<span class=\"name\">Variable</span>.<span class=\"name\">elabVariables</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElab\">Lean.Elab.Command.CommandElab</a></div></div>","info":{"doc":"The `variable?` command has the same syntax as `variable`, but it will auto-insert\nmissing instance arguments wherever they are needed.\nIt does not add variables that can already be deduced from others in the current context.\nBy default the command checks that variables aren't implied by earlier ones, but it does *not*\ncheck that earlier variables aren't implied by later ones.\nUnlike `variable`, the `variable?` command does not support changing variable binder types.\n\nThe `variable?` command will give a suggestion to replace itself with a command of the form\n`variable? ...binders... => ...binders...`.  The binders after the `=>` are the completed\nlist of binders. When this `=>` clause is present, the command verifies that the expanded\nbinders match the post-`=>` binders.  The purpose of this is to help keep code that uses\n`variable?` resilient against changes to the typeclass hierarchy, at least in the sense\nthat this additional information can be used to debug issues that might arise.\nOne can also replace `variable? ...binders... =>` with `variable`.\n\nThe core algorithm is to try elaborating binders one at a time, and whenever there is a\ntypeclass instance inference failure, it synthesizes binder syntax for it and adds it to\nthe list of binders and tries again, recursively. There are no guarantees that this\nprocess gives the \"correct\" list of binders.\n\nStructures tagged with the `variable_alias` attribute can serve as aliases for a collection\nof typeclasses. For example, given\n```lean\n@[variable_alias]\nstructure VectorSpace (k V : Type*) [Field k] [AddCommGroup V] [Module k V]\n```\nthen `variable? [VectorSpace k V]` is\nequivalent to `variable {k V : Type*} [Field k] [AddCommGroup V] [Module k V]`, assuming\nthat there are no pre-existing instances on `k` and `V`.\nNote that this is not a simple replacement: it only adds instances not inferable\nfrom others in the current scope.\n\nA word of warning: the core algorithm depends on pretty printing, so if terms that appear\nin binders do not round trip, this algorithm can fail. That said, it has some support\nfor quantified binders such as `[∀ i, F i]`. ","docLink":"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.elabVariables","kind":"def","line":246,"name":"Mathlib.Command.Variable.elabVariables","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Variable.lean#L246-L307"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.cleanBinders\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Command</span>.<span class=\"name\">Variable</span>.<span class=\"name\">cleanBinders</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">binders</span> : <a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">Lean.TSyntaxArray</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinder</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">Lean.TSyntaxArray</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinder</span></div></div>","info":{"doc":"Strip off whitespace and comments. ","docLink":"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.cleanBinders","kind":"def","line":238,"name":"Mathlib.Command.Variable.cleanBinders","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Variable.lean#L238-L244"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.completeBinders\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Command</span>.<span class=\"name\">Variable</span>.<span class=\"name\">completeBinders</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">maxSteps</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">checkRedundant</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">binders</span> : <a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">Lean.TSyntaxArray</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinder</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">Lean.TSyntaxArray</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinder</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.completeBinders","kind":"def","line":233,"name":"Mathlib.Command.Variable.completeBinders","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Variable.lean#L233-L236"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.completeBinders'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Command</span>.<span class=\"name\">Variable</span>.<span class=\"name\">completeBinders'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">maxSteps </span><span class=\"fn\">gas</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">checkRedundant</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">binders</span> : <a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">Lean.TSyntaxArray</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinder</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toOmit</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">Lean.TSyntaxArray</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinder</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></div></div>","info":{"doc":"Tries elaborating binders, inserting new binders whenever typeclass inference fails.\n`i` is the index of the next binder that needs to be checked.\n\nThe `toOmit` array keeps track of which binders should be removed at the end,\nin particular the `variable_alias` binders and any redundant binders. ","docLink":"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.completeBinders'","kind":"opaque","line":155,"name":"Mathlib.Command.Variable.completeBinders'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Variable.lean#L155-L231"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.getSubproblem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Command</span>.<span class=\"name\">Variable</span>.<span class=\"name\">getSubproblem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">binder</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinder</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ty</span> : <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinder</span>))</span></span></div></div>","info":{"doc":"Try elaborating `ty`. Returns `none` if it doesn't need any additional typeclasses,\nor it returns a new binder that needs to come first. Does not add info unless it throws\nan exception. ","docLink":"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.getSubproblem","kind":"def","line":123,"name":"Mathlib.Command.Variable.getSubproblem","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Variable.lean#L123-L153"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.pendingActionableSynthMVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Command</span>.<span class=\"name\">Variable</span>.<span class=\"name\">pendingActionableSynthMVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">binder</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinder</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>","info":{"doc":"Find a synthetic typeclass metavariable with no expr metavariables in its type. ","docLink":"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.pendingActionableSynthMVar","kind":"def","line":107,"name":"Mathlib.Command.Variable.pendingActionableSynthMVar","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Variable.lean#L107-L121"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.variableAliasAttr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Command</span>.<span class=\"name\">Variable</span>.<span class=\"name\">variableAliasAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Attributes.html#Lean.TagAttribute\">Lean.TagAttribute</a></div></div>","info":{"doc":"Attribute to record aliases for the `variable?` command. Aliases are structures that have no\nfields, and additional typeclasses are recorded as *arguments* to the structure.\n\nExample:\n```\n@[variable_alias]\nstructure VectorSpace (k V : Type*)\n  [Field k] [AddCommGroup V] [Module k V]\n```\nThen `variable? [VectorSpace k V]` ensures that these three typeclasses are present in\nthe current scope. Notice that it's looking at the arguments to the `VectorSpace` type\nconstructor. You should not have any fields in `variable_alias` structures.\n\nNotice that `VectorSpace` is not a class; the `variable?` command allows non-classes with the\n`variable_alias` attribute to use instance binders.\n","docLink":"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.variableAliasAttr","kind":"opaque","line":87,"name":"Mathlib.Command.Variable.variableAliasAttr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Variable.lean#L87-L105"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.variable?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Command</span>.<span class=\"name\">Variable</span>.<span class=\"name\">variable?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The `variable?` command has the same syntax as `variable`, but it will auto-insert\nmissing instance arguments wherever they are needed.\nIt does not add variables that can already be deduced from others in the current context.\nBy default the command checks that variables aren't implied by earlier ones, but it does *not*\ncheck that earlier variables aren't implied by later ones.\nUnlike `variable`, the `variable?` command does not support changing variable binder types.\n\nThe `variable?` command will give a suggestion to replace itself with a command of the form\n`variable? ...binders... => ...binders...`.  The binders after the `=>` are the completed\nlist of binders. When this `=>` clause is present, the command verifies that the expanded\nbinders match the post-`=>` binders.  The purpose of this is to help keep code that uses\n`variable?` resilient against changes to the typeclass hierarchy, at least in the sense\nthat this additional information can be used to debug issues that might arise.\nOne can also replace `variable? ...binders... =>` with `variable`.\n\nThe core algorithm is to try elaborating binders one at a time, and whenever there is a\ntypeclass instance inference failure, it synthesizes binder syntax for it and adds it to\nthe list of binders and tries again, recursively. There are no guarantees that this\nprocess gives the \"correct\" list of binders.\n\nStructures tagged with the `variable_alias` attribute can serve as aliases for a collection\nof typeclasses. For example, given\n```lean\n@[variable_alias]\nstructure VectorSpace (k V : Type*) [Field k] [AddCommGroup V] [Module k V]\n```\nthen `variable? [VectorSpace k V]` is\nequivalent to `variable {k V : Type*} [Field k] [AddCommGroup V] [Module k V]`, assuming\nthat there are no pre-existing instances on `k` and `V`.\nNote that this is not a simple replacement: it only adds instances not inferable\nfrom others in the current scope.\n\nA word of warning: the core algorithm depends on pretty printing, so if terms that appear\nin binders do not round trip, this algorithm can fail. That said, it has some support\nfor quantified binders such as `[∀ i, F i]`. ","docLink":"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.variable?","kind":"def","line":49,"name":"Mathlib.Command.Variable.variable?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Variable.lean#L49-L85"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.bracketedBinderType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Command</span>.<span class=\"name\">Variable</span>.<span class=\"name\">bracketedBinderType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a></span></span></div></div>","info":{"doc":"Get the type out of a bracketed binder. ","docLink":"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.bracketedBinderType","kind":"def","line":41,"name":"Mathlib.Command.Variable.bracketedBinderType","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Variable.lean#L41-L47"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.variable?.checkRedundant\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Command</span>.<span class=\"name\">Variable</span>.<span class=\"name\">variable?</span>.<span class=\"name\">checkRedundant</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.variable?.checkRedundant","kind":"opaque","line":37,"name":"Mathlib.Command.Variable.variable?.checkRedundant","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Variable.lean#L37-L39"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.variable?.maxSteps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Command</span>.<span class=\"name\">Variable</span>.<span class=\"name\">variable?</span>.<span class=\"name\">maxSteps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Variable.html#Mathlib.Command.Variable.variable?.maxSteps","kind":"opaque","line":32,"name":"Mathlib.Command.Variable.variable?.maxSteps","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Variable.lean#L32-L35"}}],"imports":["Init","Mathlib.Init","Lean.Meta.Tactic.TryThis","Lean.Linter.UnusedVariables"],"instances":[],"name":"Mathlib.Tactic.Variable"}