{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">constructorM</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"* `constructorm p_1, ..., p_n` applies the `constructor` tactic to the main goal\n  if `type` matches one of the given patterns.\n* `constructorm* p` is a more efficient and compact version of `· repeat constructorm p`.\n  It is more efficient because the pattern is compiled once.\n\nExample: The following tactic proves any theorem like `True ∧ (True ∨ True)` consisting of\nand/or/true:\n```\nconstructorm* _ ∨ _, _ ∧ _, True\n```\n","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorM","kind":"def","line":169,"name":"Mathlib.Tactic.constructorM","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CasesM.lean#L169-L183"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorMatching\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">constructorMatching</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matcher</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recursive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">throwOnNoMatch</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>","info":{"doc":"Core tactic for `constructorm`. Calls `constructor` on all subgoals for which\n`matcher ldecl.type` returns true.\n* `recursive`: if true, it calls itself repeatedly on the resulting subgoals\n* `throwOnNoMatch`: if true, throws an error if no match is found\n","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorMatching","kind":"def","line":139,"name":"Mathlib.Tactic.constructorMatching","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CasesM.lean#L139-L167"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesType!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">casesType!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"* `cases_type I` applies the `cases` tactic to a hypothesis `h : (I ...)`\n* `cases_type I_1 ... I_n` applies the `cases` tactic to a hypothesis\n  `h : (I_1 ...)` or ... or `h : (I_n ...)`\n* `cases_type* I` is shorthand for `· repeat cases_type I`\n* `cases_type! I` only applies `cases` if the number of resulting subgoals is <= 1.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current goal.\n```\ncases_type* Or And\n```\n","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesType!","kind":"def","line":135,"name":"Mathlib.Tactic.casesType!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CasesM.lean#L135-L137"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">casesType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"* `cases_type I` applies the `cases` tactic to a hypothesis `h : (I ...)`\n* `cases_type I_1 ... I_n` applies the `cases` tactic to a hypothesis\n  `h : (I_1 ...)` or ... or `h : (I_n ...)`\n* `cases_type* I` is shorthand for `· repeat cases_type I`\n* `cases_type! I` only applies `cases` if the number of resulting subgoals is <= 1.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current goal.\n```\ncases_type* Or And\n```\n","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesType","kind":"def","line":120,"name":"Mathlib.Tactic.casesType","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CasesM.lean#L120-L133"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabCasesType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabCasesType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heads</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Ident\">Lean.Ident</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recursive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">allowSplit</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Common implementation of `cases_type` and `cases_type!`. ","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabCasesType","kind":"def","line":114,"name":"Mathlib.Tactic.elabCasesType","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CasesM.lean#L114-L118"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesm!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">casesm!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"* `casesm p` applies the `cases` tactic to a hypothesis `h : type`\n  if `type` matches the pattern `p`.\n* `casesm p_1, ..., p_n` applies the `cases` tactic to a hypothesis `h : type`\n  if `type` matches one of the given patterns.\n* `casesm* p` is a more efficient and compact version of `· repeat casesm p`.\n  It is more efficient because the pattern is compiled once.\n* `casesm! p` only applies `cases` if the number of resulting subgoals is <= 1.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current context.\n```\ncasesm* _ ∨ _, _ ∧ _\n```\n","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesm!","kind":"def","line":110,"name":"Mathlib.Tactic.casesm!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CasesM.lean#L110-L112"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">casesM</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"* `casesm p` applies the `cases` tactic to a hypothesis `h : type`\n  if `type` matches the pattern `p`.\n* `casesm p_1, ..., p_n` applies the `cases` tactic to a hypothesis `h : type`\n  if `type` matches one of the given patterns.\n* `casesm* p` is a more efficient and compact version of `· repeat casesm p`.\n  It is more efficient because the pattern is compiled once.\n* `casesm! p` only applies `cases` if the number of resulting subgoals is <= 1.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current context.\n```\ncasesm* _ ∨ _, _ ∧ _\n```\n","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesM","kind":"def","line":93,"name":"Mathlib.Tactic.casesM","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CasesM.lean#L93-L108"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabCasesM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabCasesM</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pats</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recursive </span><span class=\"fn\">allowSplit</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Common implementation of `casesm` and `casesm!`. ","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabCasesM","kind":"def","line":88,"name":"Mathlib.Tactic.elabCasesM","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CasesM.lean#L88-L91"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.matchPatterns\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">matchPatterns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pats</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.AbstractMVarsResult\">Lean.Meta.AbstractMVarsResult</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Returns true if any of the patterns match the expression. ","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.matchPatterns","kind":"def","line":83,"name":"Mathlib.Tactic.matchPatterns","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CasesM.lean#L83-L86"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabPatterns\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabPatterns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pats</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.AbstractMVarsResult\">Lean.Meta.AbstractMVarsResult</a>)</span></span></div></div>","info":{"doc":"Elaborate a list of terms with holes into a list of patterns. ","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabPatterns","kind":"def","line":76,"name":"Mathlib.Tactic.elabPatterns","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CasesM.lean#L76-L81"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesType\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">casesType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heads</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recursive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">allowSplit</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesType","kind":"def","line":65,"name":"Lean.MVarId.casesType","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CasesM.lean#L65-L69"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesMatching\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">casesMatching</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matcher</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recursive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">allowSplit </span><span class=\"fn\">throwOnNoMatch</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>","info":{"doc":"Core tactic for `casesm` and `cases_type`. Calls `cases` on all fvars in `g` for which\n`matcher ldecl.type` returns true.\n* `recursive`: if true, it calls itself repeatedly on the resulting subgoals\n* `allowSplit`: if false, it will skip any hypotheses where `cases` returns more than one subgoal.\n* `throwOnNoMatch`: if true, then throws an error if no match is found\n","docLink":"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesMatching","kind":"def","line":21,"name":"Lean.MVarId.casesMatching","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CasesM.lean#L21-L63"}}],"imports":["Init","Mathlib.Init","Lean.Elab.Tactic.Conv.Pattern"],"instances":[],"name":"Mathlib.Tactic.CasesM"}