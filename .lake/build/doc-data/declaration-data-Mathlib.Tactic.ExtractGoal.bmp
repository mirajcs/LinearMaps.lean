{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ExtractGoal.html#Mathlib.Tactic.ExtractGoal.goalSignature\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ExtractGoal</span>.<span class=\"name\">goalSignature</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></div></div>","info":{"doc":"Format a goal into a type signature for a declaration named `name`.\n\nExample output: `myTheorem (a b : Nat) : a + b = b + a`.\n\nThe return values are:\n* A formatted piece of `MessageData`, like `m!\"myTheorem (a b : Nat) : a + b = b + a\"`.\n* The full type of the declaration, like `∀ a b, a + b = b + a`.\n* The imports needed to state this declaration, as an array of module names.\n* A boolean indicating whether the original goal type had top-level foralls.\n","docLink":"./Mathlib/Tactic/ExtractGoal.html#Mathlib.Tactic.ExtractGoal.goalSignature","kind":"def","line":139,"name":"Mathlib.Tactic.ExtractGoal.goalSignature","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ExtractGoal.lean#L139-L192"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ExtractGoal.html#Mathlib.Tactic.ExtractGoal.extractGoal\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ExtractGoal</span>.<span class=\"name\">extractGoal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"- `extract_goal` formats the current goal as a stand-alone theorem or definition after\n  cleaning up the local context of irrelevant variables.\n  A variable is *relevant* if (1) it occurs in the target type, (2) there is a relevant variable\n  that depends on it, or (3) the type of the variable is a proposition that depends on a\n  relevant variable.\n\n  If the target is `False`, then for convenience `extract_goal` includes all variables.\n- `extract_goal *` formats the current goal without cleaning up the local context.\n- `extract_goal a b c ...` formats the current goal after removing everything that the given\n  variables `a`, `b`, `c`, ... do not depend on.\n- `extract_goal ... using name` uses the name `name` for the theorem or definition rather than\n  the autogenerated name.\n\nThe tactic tries to produce an output that can be copy-pasted and just work,\nbut its success depends on whether the expressions are amenable\nto being unambiguously pretty printed.\n\nThe tactic responds to pretty printing options.\nFor example, `set_option pp.all true in extract_goal` gives the `pp.all` form.\n","docLink":"./Mathlib/Tactic/ExtractGoal.html#Mathlib.Tactic.ExtractGoal.extractGoal","kind":"def","line":116,"name":"Mathlib.Tactic.ExtractGoal.extractGoal","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ExtractGoal.lean#L116-L137"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ExtractGoal.html#Mathlib.Tactic.ExtractGoal.config\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ExtractGoal</span>.<span class=\"name\">config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Configuration for `extract_goal` for which variables from the context to include. ","docLink":"./Mathlib/Tactic/ExtractGoal.html#Mathlib.Tactic.ExtractGoal.config","kind":"def","line":113,"name":"Mathlib.Tactic.ExtractGoal.config","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ExtractGoal.lean#L113-L114"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ExtractGoal.html#Mathlib.Tactic.ExtractGoal.star\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ExtractGoal</span>.<span class=\"name\">star</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Have `extract_goal` extract the full local context. ","docLink":"./Mathlib/Tactic/ExtractGoal.html#Mathlib.Tactic.ExtractGoal.star","kind":"def","line":110,"name":"Mathlib.Tactic.ExtractGoal.star","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ExtractGoal.lean#L110-L111"}}],"imports":["Init","Lean.Elab.Term","Lean.Elab.Tactic.ElabTerm","Lean.Meta.Tactic.Cleanup","Lean.PrettyPrinter","Batteries.Lean.Meta.Inaccessible","Lean.Elab.Command","Mathlib.Tactic.MinImports"],"instances":[],"name":"Mathlib.Tactic.ExtractGoal"}