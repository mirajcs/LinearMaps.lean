{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ByContra.html#Mathlib.Tactic.ByContra.byContra!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ByContra</span>.<span class=\"name\">byContra!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"If the target of the main goal is a proposition `p`,\n`by_contra!` reduces the goal to proving `False` using the additional hypothesis `this : ¬ p`.\n`by_contra! h` can be used to name the hypothesis `h : ¬ p`.\nThe hypothesis `¬ p` will be normalized using `push_neg`.\nFor instance, `¬ a < b` will be changed to `b ≤ a`.\n`by_contra!` can be used with `rcases` patterns.\nFor instance, `by_contra! rfl` on `⊢ s.Nonempty` will substitute the equality `s = ∅`,\nand `by_contra! ⟨hp, hq⟩` on `⊢ ¬ p ∨ ¬ q` will introduce `hp : p` and `hq : q`.\n`by_contra! h : q` will normalize negations in `¬ p`, normalize negations in `q`,\nand then check that the two normalized forms are equal.\nThe resulting hypothesis is the pre-normalized form, `q`.\nIf the name `h` is not explicitly provided, then `this` will be used as name.\nThis tactic uses classical reasoning.\nIt is a variant on the tactic `by_contra`.\nExamples:\n```lean\nexample : 1 < 2 := by\n  by_contra! h\n  -- h : 2 ≤ 1 ⊢ False\n\nexample : 1 < 2 := by\n  by_contra! h : ¬ 1 < 2\n  -- h : ¬ 1 < 2 ⊢ False\n```\n","docLink":"./Mathlib/Tactic/ByContra.html#Mathlib.Tactic.ByContra.byContra!","kind":"def","line":22,"name":"Mathlib.Tactic.ByContra.byContra!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ByContra.lean#L22-L49"}}],"imports":["Init","Batteries.Tactic.Init","Mathlib.Tactic.Push"],"instances":[],"name":"Mathlib.Tactic.ByContra"}