{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.congr!\"><span class=\"name\">Congr!</span>.<span class=\"name\">congr!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Equates pieces of the left-hand side of a goal to corresponding pieces of the right-hand side by\nrecursively applying congruence lemmas. For example, with `⊢ f as = g bs` we could get\ntwo goals `⊢ f = g` and `⊢ as = bs`.\n\nSyntax:\n```\ncongr!\ncongr! n\ncongr! with x y z\ncongr! n with x y z\n```\nHere, `n` is a natural number and `x`, `y`, `z` are `rintro` patterns (like `h`, `rfl`, `⟨x, y⟩`,\n`_`, `-`, `(h | h)`, etc.).\n\nThe `congr!` tactic is similar to `congr` but is more insistent in trying to equate left-hand sides\nto right-hand sides of goals. Here is a list of things it can try:\n\n- If `R` in `⊢ R x y` is a reflexive relation, it will convert the goal to `⊢ x = y` if possible.\n  The list of reflexive relations is maintained using the `@[refl]` attribute.\n  As a special case, `⊢ p ↔ q` is converted to `⊢ p = q` during congruence processing and then\n  returned to `⊢ p ↔ q` form at the end.\n\n- If there is a user congruence lemma associated to the goal (for instance, a `@[congr]`-tagged\n  lemma applying to `⊢ List.map f xs = List.map g ys`), then it will use that.\n\n- It uses a congruence lemma generator at least as capable as the one used by `congr` and `simp`.\n  If there is a subexpression that can be rewritten by `simp`, then `congr!` should be able\n  to generate an equality for it.\n\n- It can do congruences of pi types using lemmas like `implies_congr` and `pi_congr`.\n\n- Before applying congruences, it will run the `intros` tactic automatically.\n  The introduced variables can be given names using a `with` clause.\n  This helps when congruence lemmas provide additional assumptions in hypotheses.\n\n- When there is an equality between functions, so long as at least one is obviously a lambda, we\n  apply `funext` or `Function.hfunext`, which allows for congruence of lambda bodies.\n\n- It can try to close goals using a few strategies, including checking\n  definitional equality, trying to apply `Subsingleton.elim` or `proof_irrel_heq`, and using the\n  `assumption` tactic.\n\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr!` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr!` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr! 2` produces the intended `⊢ x + y = y + x`.\n\nThe `congr!` tactic also takes a configuration option, for example\n```lean\ncongr! (transparency := .default) 2\n```\nThis overrides the default, which is to apply congruence lemmas at reducible transparency.\n\nThe `congr!` tactic is aggressive with equating two sides of everything. There is a predefined\nconfiguration that uses a different strategy:\nTry\n```lean\ncongr! (config := .unfoldSameFun)\n```\nThis only allows congruences between functions applications of definitionally equal functions,\nand it applies congruence lemmas at default transparency (rather than just reducible).\nThis is somewhat like `congr`.\n\nSee `Congr!.Config` for all options.\n","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.congr!","kind":"def","line":669,"name":"Congr!.congr!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L669-L737"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.elabConfig\"><span class=\"name\">Congr!</span>.<span class=\"name\">elabConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.elabConfig","kind":"def","line":667,"name":"Congr!.elabConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L667-L667"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrN!\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">congrN!</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">depth?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">config</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Congr!.Config</a> := <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.mk\">{</a> <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.mk\">}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">patterns</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`rcasesPat</span>)</span> := <a href=\"./Init/Prelude.html#List.nil\">[</a><a href=\"./Init/Prelude.html#List.nil\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>","info":{"doc":"A more insistent version of `Lean.MVarId.congrN`.\nSee the documentation on the `congr!` syntax.\n\nThe `depth?` argument controls the depth of the recursion. If `none`, then it uses a reasonably\nlarge bound that is linear in the expression depth. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrN!","kind":"def","line":628,"name":"Lean.MVarId.congrN!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L628-L663"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.postCongr!\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">postCongr!</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">config</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Congr!.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>","info":{"doc":"A pass to clean up after `Lean.MVarId.preCongr!` and `Lean.MVarId.congrCore!`. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.postCongr!","kind":"def","line":613,"name":"Lean.MVarId.postCongr!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L613-L626"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrCore!\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">congrCore!</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">config</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Congr!.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrCore!","kind":"def","line":591,"name":"Lean.MVarId.congrCore!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L591-L611"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.preCongr!\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">preCongr!</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tryClose</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>","info":{"doc":"Convert a goal into an `Eq` goal if possible (since we have a better shot at those).\nAlso, if `tryClose := true`, then try to close the goal using an assumption, `Subsingleton.Elim`,\nor definitional equality. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.preCongr!","kind":"def","line":571,"name":"Lean.MVarId.preCongr!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L571-L589"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.introsClean\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">introsClean</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CongrExclamation.html#CongrMetaM\">CongrMetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>","info":{"doc":"Does `Lean.MVarId.intros` but then cleans up the introduced hypotheses, removing anything\nthat is trivial. If there are any patterns in the current `CongrMetaM` state then instead\nof `Lean.MVarId.intros` it does `Lean.Elab..Tactic.RCases.rintro`.\n\nCleaning up includes:\n- deleting hypotheses of the form `x ≍ x`, `x = x`, and `x ↔ x`.\n- deleting Prop hypotheses that are already in the local context.\n- converting `x ≍ y` to `x = y` if possible.\n- converting `x = y` to `x ↔ y` if possible.\n","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.introsClean","kind":"def","line":512,"name":"Lean.MVarId.introsClean","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L512-L569"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#CongrMetaM.nextPattern\"><span class=\"name\">CongrMetaM</span>.<span class=\"name\">nextPattern</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CongrExclamation.html#CongrMetaM\">CongrMetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span>))</span></span></div></div>","info":{"doc":"Pop the next pattern from the current state. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#CongrMetaM.nextPattern","kind":"def","line":494,"name":"CongrMetaM.nextPattern","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L494-L500"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#CongrMetaM\"><span class=\"name\">CongrMetaM</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/CongrExclamation.html#CongrMetaM","kind":"def","line":492,"name":"CongrMetaM","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L492-L492"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#CongrState.patterns\"><span class=\"name\">CongrState</span>.<span class=\"name\">patterns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#CongrState\">CongrState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span>)</span></div></div>","info":{"doc":"Patterns to use when doing intro. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#CongrState.patterns","kind":"def","line":490,"name":"CongrState.patterns","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L490-L490"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#CongrState.goals\"><span class=\"name\">CongrState</span>.<span class=\"name\">goals</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#CongrState\">CongrState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span></div></div>","info":{"doc":"Accumulated goals that `congr!` could not handle. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#CongrState.goals","kind":"def","line":488,"name":"CongrState.goals","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L488-L488"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#CongrState.mk\"><span class=\"name\">CongrState</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goals</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">patterns</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CongrExclamation.html#CongrState\">CongrState</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/CongrExclamation.html#CongrState.mk","kind":"ctor","line":486,"name":"CongrState.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L486-L486"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#CongrState\"><span class=\"name\">CongrState</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/CongrExclamation.html#CongrState","kind":"structure","line":486,"name":"CongrState","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L486-L490"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrPasses!\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">congrPasses!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Init/Prelude.html#String\">String</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Congr!.Config</a> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span>)</span></span></span>)</span>)</span></div></div>","info":{"doc":"A list of all the congruence strategies used by `Lean.MVarId.congrCore!`.\n","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrPasses!","kind":"def","line":463,"name":"Lean.MVarId.congrPasses!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L463-L484"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.beqInst?\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">beqInst?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span>)</span></span></div></div>","info":{"doc":"Tries to apply `lawful_beq_subsingleton` to prove that two `BEq` instances are equal\nby synthesizing `LawfulBEq` instances for both.\n","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.beqInst?","kind":"def","line":456,"name":"Lean.MVarId.beqInst?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L456-L461"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.subsingletonHelim?\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">subsingletonHelim?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span>)</span></span></div></div>","info":{"doc":"Try to apply `Subsingleton.helim` if the goal is a `HEq`. Tries synthesizing a `Subsingleton`\ninstance for both the LHS and the RHS.\n\nIf successful, this reduces proving `@HEq α x β y` to proving `α = β`.\n","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.subsingletonHelim?","kind":"def","line":433,"name":"Lean.MVarId.subsingletonHelim?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L433-L454"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrImplies?'\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">congrImplies?'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span>)</span></span></div></div>","info":{"doc":"A version of `Lean.MVarId.congrImplies?` that uses `implies_congr'`\ninstead of `implies_congr`. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrImplies?'","kind":"def","line":425,"name":"Lean.MVarId.congrImplies?'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L425-L431"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.obviousHfunext?\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">obviousHfunext?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span>)</span></span></div></div>","info":{"doc":"Try to apply `Function.hfunext`, returning the new goals if it succeeds.\nLike `Lean.MVarId.obviousFunext?`, we only do so if at least one side of the `HEq` is a lambda.\nThis prevents unfolding of things like `Set`.\n\nNeed to have `Mathlib/Logic/Function/Basic.lean` imported for this to succeed.\n","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.obviousHfunext?","kind":"def","line":404,"name":"Lean.MVarId.obviousHfunext?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L404-L415"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.obviousFunext?\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">obviousFunext?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span>)</span></span></div></div>","info":{"doc":"Try to apply `funext`, but only if it is an equality of two functions where at least one is\na lambda expression.\n\nOne thing this check prevents is accidentally applying `funext` to a set equality, but also when\ndoing congruence we don't want to apply `funext` unnecessarily.\n","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.obviousFunext?","kind":"def","line":391,"name":"Lean.MVarId.obviousFunext?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L391-L402"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrPi?\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">congrPi?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span>)</span></span></div></div>","info":{"doc":"Try to apply `pi_congr`. This is similar to `Lean.MVar.congrImplies?`.\n","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrPi?","kind":"def","line":385,"name":"Lean.MVarId.congrPi?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L385-L389"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.userCongr?\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">userCongr?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">config</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Congr!.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span>)</span></span></div></div>","info":{"doc":"Try applying user-provided congruence lemmas. If any are applicable,\nreturns a list of new goals.\n\nTries a congruence lemma associated to the LHS and then, if that failed, the RHS.\n","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.userCongr?","kind":"def","line":349,"name":"Lean.MVarId.userCongr?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L349-L383"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrSimp?\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">congrSimp?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">config</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Congr!.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span>)</span></span></div></div>","info":{"doc":"Like `Lean.MVarId.congr?` but instead of using only the congruence lemma associated to the LHS,\nit tries the RHS too, in the order specified by `config.preferLHS`.\n\nIt uses `Lean.Meta.mkCongrSimp?` to generate a congruence lemma, like in the `congr` tactic.\n\nApplies the congruence generated congruence lemmas according to `config`.\n","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrSimp?","kind":"def","line":308,"name":"Lean.MVarId.congrSimp?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L308-L347"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.smartHCongr?\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">smartHCongr?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">config</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Congr!.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span>)</span></span></div></div>","info":{"doc":"This is like `Lean.MVarId.hcongr?` but (1) looks at both sides when generating the congruence lemma\nand (2) inserts additional hypotheses from equalities from previous arguments.\n\nIt uses `Lean.Meta.mkRichHCongr` to generate the congruence lemmas.\n\nIf the goal is an `Eq`, it uses `eq_of_heq` first.\n\nAs a backup strategy, it uses the LHS/RHS method like in `Lean.MVarId.congrSimp?`\n(where `Congr!.Config.preferLHS` determines which side to try first). This uses a particular side\nof the target, generates the congruence lemma, then tries applying it. This can make progress\nwith higher transparency settings. To help the unifier, in this mode it assumes both sides have the\nexact same function.\n","docLink":"./Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.smartHCongr?","kind":"def","line":192,"name":"Lean.MVarId.smartHCongr?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L192-L306"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.plausiblyEqualTypes\"><span class=\"name\">Congr!</span>.<span class=\"name\">plausiblyEqualTypes</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ty1 </span><span class=\"fn\">ty2</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">maxDepth</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a> := <span class=\"fn\">5</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Returns whether or not it's reasonable to consider an equality between types `ty1` and `ty2`.\nThe heuristic is the following:\n\n- If `ty1` and `ty2` are in `Prop`, then yes.\n- If in whnf both `ty1` and `ty2` have the same head and if (recursively) it's reasonable to\n  consider an equality between corresponding type arguments, then yes.\n- Otherwise, no.\n\nThis helps keep congr from going too far and generating hypotheses like `ℝ = ℤ`.\n\nTo keep things from going out of control, there is a `maxDepth`. Additionally, if we do the check\nwith `maxDepth = 0` then the heuristic answers \"no\". ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.plausiblyEqualTypes","kind":"def","line":158,"name":"Congr!.plausiblyEqualTypes","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L158-L190"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.maxArgsFor\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">maxArgsFor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">config</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numArgs</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"According to the configuration, how many of the arguments in `numArgs` should be considered. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.maxArgsFor","kind":"def","line":133,"name":"Congr!.Config.maxArgsFor","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L133-L135"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.numArgsOk\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">numArgsOk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">config</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numArgs</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Whether the given number of arguments is allowed to be considered. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.numArgsOk","kind":"def","line":129,"name":"Congr!.Config.numArgsOk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L129-L131"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.unfoldSameFun\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">unfoldSameFun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a></div></div>","info":{"doc":"A configuration option that makes `congr!` do the sorts of aggressive unfoldings that `congr`\ndoes while also similarly preventing `congr!` from considering partial applications or congruences\nbetween different functions being applied. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.unfoldSameFun","kind":"def","line":120,"name":"Congr!.Config.unfoldSameFun","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L120-L127"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.beqEq\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">beqEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Whether to use a special congruence lemma for `BEq` instances.\nThis synthesizes `LawfulBEq` instances to discharge equalities of `BEq` instances. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.beqEq","kind":"def","line":118,"name":"Congr!.Config.beqEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L118-L118"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.useCongrSimp\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">useCongrSimp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Whether to use the congruence generator that is used by `simp` and `congr`. This generator\nis more strict, and it does not respect all configuration settings. It does respect\n`preferLHS`, `partialApp` and `maxArgs` and transparency settings. It acts as if `sameFun := true`\nand it ignores `typeEqs`. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.useCongrSimp","kind":"def","line":115,"name":"Congr!.Config.useCongrSimp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L115-L115"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.etaExpand\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">etaExpand</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"As a last pass, perform eta expansion of both sides of an equality. For example,\nthis transforms a bare `HAdd.hAdd` into `fun x y => x + y`. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.etaExpand","kind":"def","line":110,"name":"Congr!.Config.etaExpand","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L110-L110"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.typeEqs\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">typeEqs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"For type arguments that are implicit or have forward dependencies, whether or not `congr!`\nshould generate equalities even if the types do not look plausibly equal.\n\nWe have a heuristic in the main congruence generator that types\n`α` and `β` are *plausibly equal* according to the following algorithm:\n\n- If the types are both propositions, they are plausibly equal (`Iff`s are plausible).\n- If the types are from different universes, they are not plausibly equal.\n- Suppose in whnf we have `α = f a₁ ... aₘ` and `β = g b₁ ... bₘ`. If `f` is not definitionally\n  equal to `g` or `m ≠ n`, then `α` and `β` are not plausibly equal.\n- If there is some `i` such that `aᵢ` and `bᵢ` are not plausibly equal, then `α` and `β` are\n  not plausibly equal.\n- Otherwise, `α` and `β` are plausibly equal.\n\nThe purpose of this is to prevent considering equalities like `ℕ = ℤ` while allowing equalities\nsuch as `Fin n = Fin m` or `Subtype p = Subtype q` (so long as these are subtypes of the\nsame type).\n\nThe way this is implemented is that when the congruence generator is comparing arguments when\nlooking at an equality of function applications, it marks a function parameter as \"fixed\" if the\nprovided arguments are types that are not plausibly equal. The effect of this is that congruence\nsucceeds only if those arguments are defeq at `transparency` transparency. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.typeEqs","kind":"def","line":107,"name":"Congr!.Config.typeEqs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L107-L107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.maxArgs\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">maxArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>","info":{"doc":"The maximum number of arguments to consider when doing congruence of function applications.\nFor example, with `f a b c = g w x y z`, setting `maxArgs := some 2` means it will only consider\neither `f a b = g w x y` and `c = z` or `f a = g w x`, `b = y`, and `c = z`. Setting\n`maxArgs := none` (the default) means no limit.\n\nWhen the functions are dependent, `maxArgs` can prevent congruence from working at all.\nIn `Fintype.card α = Fintype.card β`, one needs to have `maxArgs` at `2` or higher since\nthere is a `Fintype` instance argument that depends on the first.\n\nWhen there aren't such dependency issues, setting `maxArgs := some 1` causes `congr!` to\ndo congruence on a single argument at a time. This can be used in conjunction with the\niteration limit to control exactly how many arguments are to be processed by congruence. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.maxArgs","kind":"def","line":84,"name":"Congr!.Config.maxArgs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L84-L84"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.sameFun\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">sameFun</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Whether to require that both sides of an equality be applications of defeq functions.\nThat is, if true, `f a = g x` is only considered if `f` and `g` are defeq (making it be similar\nto the `congr` tactic). ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.sameFun","kind":"def","line":71,"name":"Congr!.Config.sameFun","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L71-L71"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.partialApp\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">partialApp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Allow both sides to be partial applications.\nWhen false, given an equality `f a b = g x y z` this means we never consider\nproving `f a = g x y`.\n\nIn this case, we might still consider `f = g x` if a pass generates a congruence lemma using the\nleft-hand side. Use `sameFun := true` to ensure both sides are applications\nof the same function (making it be similar to the `congr` tactic). ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.partialApp","kind":"def","line":67,"name":"Congr!.Config.partialApp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L67-L67"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.preferLHS\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">preferLHS</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"For passes that synthesize a congruence lemma using one side of the equality,\nwe run the pass both for the left-hand side and the right-hand side. If `preferLHS` is `true`\nthen we start with the left-hand side.\n\nThis can be used to control which side's definitions are expanded when applying the\ncongruence lemma (if `preferLHS = true` then the RHS can be expanded). ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.preferLHS","kind":"def","line":59,"name":"Congr!.Config.preferLHS","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L59-L59"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.preTransparency\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">preTransparency</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a></div></div>","info":{"doc":"The transparency level to use when trying to close goals before applying congruence lemmas.\nThis includes trying to prove the goal by `rfl` and using the `assumption` tactic.\nBy default this is `.reducible`, which prevents unfolding of most definitions. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.preTransparency","kind":"def","line":52,"name":"Congr!.Config.preTransparency","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L52-L52"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.transparency\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">transparency</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a></div></div>","info":{"doc":"The transparency level to use when applying a congruence theorem.\nBy default this is `.reducible`, which prevents unfolding of most definitions. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.transparency","kind":"def","line":48,"name":"Congr!.Config.transparency","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L48-L48"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.closePost\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">closePost</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"If `closePost := true`, then try to close goals that remain after no more congruence\nlemmas can be applied, using the same tactics as `closePre`. These tactics are applied\nwith current tactic transparency level. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.closePost","kind":"def","line":45,"name":"Congr!.Config.closePost","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L45-L45"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.closePre\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">closePre</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"If `closePre := true`, then try to close goals before applying congruence lemmas\nusing tactics such as `rfl` and `assumption`. These tactics are applied with the\ntransparency level specified by `preTransparency`, which is `.reducible` by default. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.closePre","kind":"def","line":41,"name":"Congr!.Config.closePre","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L41-L41"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.mk\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">closePre </span><span class=\"fn\">closePost</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">transparency </span><span class=\"fn\">preTransparency</span> : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">preferLHS </span><span class=\"fn\">partialApp </span><span class=\"fn\">sameFun</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">maxArgs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">typeEqs </span><span class=\"fn\">etaExpand </span><span class=\"fn\">useCongrSimp </span><span class=\"fn\">beqEq</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Config</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config.mk","kind":"ctor","line":37,"name":"Congr!.Config.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L37-L37"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\"><span class=\"name\">Congr!</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The configuration for the `congr!` tactic. ","docLink":"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config","kind":"structure","line":36,"name":"Congr!.Config","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/CongrExclamation.lean#L36-L118"}}],"imports":["Init","Lean.Elab.Tactic.Config","Lean.Elab.Tactic.RCases","Lean.Meta.Tactic.Assumption","Lean.Meta.Tactic.Rfl","Mathlib.Lean.Meta.CongrTheorems","Mathlib.Logic.Basic","Mathlib.Lean.Meta.CongrTheorems"],"instances":[],"name":"Mathlib.Tactic.CongrExclamation"}