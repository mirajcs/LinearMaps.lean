{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FinCases.html#Lean.Elab.Tactic.finCases\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">finCases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`fin_cases h` performs case analysis on a hypothesis of the form\n`h : A`, where `[Fintype A]` is available, or\n`h : a ∈ A`, where `A : Finset X`, `A : Multiset X` or `A : List X`.\n\nAs an example, in\n```\nexample (f : ℕ → Prop) (p : Fin 3) (h0 : f 0) (h1 : f 1) (h2 : f 2) : f p.val := by\n  fin_cases p; simp\n  all_goals assumption\n```\nafter `fin_cases p; simp`, there are three goals, `f 0`, `f 1`, and `f 2`.\n","docLink":"./Mathlib/Tactic/FinCases.html#Lean.Elab.Tactic.finCases","kind":"def","line":78,"name":"Lean.Elab.Tactic.finCases","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FinCases.lean#L78-L91"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FinCases.html#Lean.Elab.Tactic.finCasesAt\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">finCasesAt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyp</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>","info":{"doc":"Implementation of the `fin_cases` tactic. ","docLink":"./Mathlib/Tactic/FinCases.html#Lean.Elab.Tactic.finCasesAt","kind":"opaque","line":64,"name":"Lean.Elab.Tactic.finCasesAt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FinCases.lean#L64-L76"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FinCases.html#Lean.Elab.Tactic.unfoldCases\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldCases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">userNamePre</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a> := <a href=\"./Init/Prelude.html#Lean.Name.anonymous\">Name.anonymous</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">counter</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a> := <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>","info":{"doc":"Recursively runs the `cases` tactic on a hypothesis `h`.\nAs long as two goals are produced, `cases` is called recursively on the second goal,\nand we return a list of the first goals which appeared.\n\nThis is useful for hypotheses of the form `h : a ∈ [l₁, l₂, ...]`,\nwhich will be transformed into a sequence of goals with hypotheses `h : a = l₁`, `h : a = l₂`,\nand so on.\nCases are named according to the order in which they are generated as tracked by `counter`\nand prefixed with `userNamePre`.\n","docLink":"./Mathlib/Tactic/FinCases.html#Lean.Elab.Tactic.unfoldCases","kind":"opaque","line":43,"name":"Lean.Elab.Tactic.unfoldCases","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FinCases.lean#L43-L62"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FinCases.html#Lean.Elab.Tactic.getMemType\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">getMemType</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/Exception.html#Lean.MonadError\">MonadError</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>","info":{"doc":"If `e` is of the form `x ∈ (A : List α)`, `x ∈ (A : Finset α)`, or `x ∈ (A : Multiset α)`,\nreturn `some α`, otherwise `none`. ","docLink":"./Mathlib/Tactic/FinCases.html#Lean.Elab.Tactic.getMemType","kind":"def","line":30,"name":"Lean.Elab.Tactic.getMemType","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FinCases.lean#L30-L41"}}],"imports":["Init","Mathlib.Tactic.Core","Mathlib.Lean.Expr.Basic","Mathlib.Data.Finset.Attr","Mathlib.Data.Fintype.Defs","Mathlib.Tactic.ToDual"],"instances":[],"name":"Mathlib.Tactic.FinCases"}