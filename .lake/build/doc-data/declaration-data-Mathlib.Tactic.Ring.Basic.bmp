{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.tacticRing1!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">tacticRing1!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`ring1` solves the goal when it is an equality in *commutative* (semi)rings,\nallowing variables in the exponent.\n\nThis version of `ring` fails if the target is not an equality.\n\n* `ring1!` uses a more aggressive reducibility setting to determine equality of atoms.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.tacticRing1!","kind":"def","line":1439,"name":"Mathlib.Tactic.Ring.tacticRing1!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1439-L1439"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ring1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`ring1` solves the goal when it is an equality in *commutative* (semi)rings,\nallowing variables in the exponent.\n\nThis version of `ring` fails if the target is not an equality.\n\n* `ring1!` uses a more aggressive reducibility setting to determine equality of atoms.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1","kind":"def","line":1428,"name":"Mathlib.Tactic.Ring.ring1","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1428-L1437"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq.ringCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">proveEq</span>.<span class=\"name\">ringCore</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">Q(<span class=\"fn\">«$e₁»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$e₂»</span>)</span></span></div></div>","info":{"doc":"The core of `proveEq` takes expressions `e₁ e₂ : α` where `α` is a `CommSemiring`,\nand returns a proof that they are equal (or fails). ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq.ringCore","kind":"def","line":1416,"name":"Mathlib.Tactic.Ring.proveEq.ringCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1416-L1426"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">proveEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Frontend of `ring1`: attempt to close a goal `g`, assuming it is an equation of semirings. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq","kind":"def","line":1387,"name":"Mathlib.Tactic.Ring.proveEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1387-L1426"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ringCleanupRef\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ringCleanupRef</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <span class=\"fn\">(<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>","info":{"doc":"This is a routine which is used to clean up the unsolved subgoal\nof a failed `ring1` application. It is overridden in `Mathlib/Tactic/Ring/RingNF.lean`\nto apply the `ring_nf` simp set to the goal.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ringCleanupRef","kind":"opaque","line":1380,"name":"Mathlib.Tactic.Ring.ringCleanupRef","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1380-L1385"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.of_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">of_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.of_eq","kind":"theorem","line":1378,"name":"Mathlib.Tactic.Ring.of_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1378-L1378"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.of_lift\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">of_lift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">inst</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a' </span><span class=\"fn\">b'</span> : <span class=\"fn\">β</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">h1</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal\">CSLiftVal</a> <span class=\"fn\">a</span> <span class=\"fn\">a'</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">h2</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal\">CSLiftVal</a> <span class=\"fn\">b</span> <span class=\"fn\">b'</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.of_lift","kind":"theorem","line":1372,"name":"Mathlib.Tactic.Ring.of_lift","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1372-L1374"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCSLiftValLift\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">instCSLiftValLift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal\">CSLiftVal</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift\">CSLift.lift</a> <span class=\"fn\">a</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCSLiftValLift","kind":"instance","line":1370,"name":"Mathlib.Tactic.Ring.instCSLiftValLift","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1370-L1370"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal.eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">CSLiftVal</span>.<span class=\"name\">eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal\">CSLiftVal</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift\">CSLift.lift</a> <span class=\"fn\">a</span></span></div></div>","info":{"doc":"The output value `b` is equal to the lift of `a`. This can be supplied by the default\ninstance which sets `b := lift a`, but `ring` will treat this as an atom so it is more useful\nwhen there are other instances which distribute addition or multiplication. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal.eq","kind":"theorem","line":1368,"name":"Mathlib.Tactic.Ring.CSLiftVal.eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1368-L1368"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">CSLiftVal</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift\">CSLift.lift</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal\">CSLiftVal</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal.mk","kind":"ctor","line":1364,"name":"Mathlib.Tactic.Ring.CSLiftVal.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1364-L1364"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">CSLiftVal</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"`CSLiftVal a b` means that `b = lift a`. This is used by `ring` to construct an expression `b`\nfrom the input expression `a`, and then run the usual ring algorithm on `b`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal","kind":"class","line":1362,"name":"Mathlib.Tactic.Ring.CSLiftVal","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1362-L1368"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.inj\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">CSLift</span>.<span class=\"name\">inj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.Injective\">Function.Injective</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift\">lift</a></span></div></div>","info":{"doc":"`lift` is an injective function ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.inj","kind":"theorem","line":1360,"name":"Mathlib.Tactic.Ring.CSLift.inj","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1360-L1360"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">CSLift</span>.<span class=\"name\">lift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span></div></div>","info":{"doc":"`lift` is the \"canonical injection\" from `α` to `β` ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift","kind":"def","line":1358,"name":"Mathlib.Tactic.Ring.CSLift.lift","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1358-L1358"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">CSLift</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lift</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inj</span> : <span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">lift</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.mk","kind":"ctor","line":1356,"name":"Mathlib.Tactic.Ring.CSLift.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1356-L1356"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">CSLift</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">β</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"`CSLift α β` is a typeclass used by `ring` for lifting operations from `α`\n(which is not a commutative semiring) into a commutative semiring `β` by using an injective map\n`lift : α → β`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift","kind":"class","line":1353,"name":"Mathlib.Tactic.Ring.CSLift","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1353-L1360"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <span class=\"fn\">sα</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">e</span>)</span></span></div></div>","info":{"doc":"Evaluates expression `e` of type `α` into a normalized representation as a polynomial.\nThis is the main driver of `ring`, which calls out to `evalAdd`, `evalMul` etc.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval","kind":"opaque","line":1278,"name":"Mathlib.Tactic.Ring.eval","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1278-L1349"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.isAtomOrDerivable\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">isAtomOrDerivable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <span class=\"fn\">sα</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">e</span>)</span>)</span>)</span></span></div></div>","info":{"doc":"Checks whether `e` would be processed by `eval` as a ring expression,\nor otherwise if it is an atom or something simplifiable via `norm_num`.\n\nWe use this in `ring_nf` to avoid rewriting atoms unnecessarily.\n\nReturns:\n* `none` if `eval` would process `e` as an algebraic ring expression\n* `some none` if `eval` would treat `e` as an atom.\n* `some (some r)` if `eval` would not process `e` as an algebraic ring expression,\n  but `NormNum.derive` can nevertheless simplify `e`, with result `r`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.isAtomOrDerivable","kind":"def","line":1249,"name":"Mathlib.Tactic.Ring.isAtomOrDerivable","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1249-L1276"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.int\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Cache</span>.<span class=\"name\">int</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℤ\">sℤ</a></span></div></div>","info":{"doc":"A precomputed `Cache` for `ℤ`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.int","kind":"def","line":1245,"name":"Mathlib.Tactic.Ring.Cache.int","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1245-L1247"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.nat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Cache</span>.<span class=\"name\">nat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a></span></div></div>","info":{"doc":"A precomputed `Cache` for `ℕ`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.nat","kind":"def","line":1242,"name":"Mathlib.Tactic.Ring.Cache.nat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1242-L1243"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.div_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">div_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#Semifield\">Semifield</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a' </span><span class=\"fn\">b </span><span class=\"fn\">b' </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.div_congr","kind":"theorem","line":1239,"name":"Mathlib.Tactic.Ring.div_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1239-L1240"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">inv_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#Semifield\">Semifield</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a' </span><span class=\"fn\">b</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">a'</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> → <span class=\"fn\">a</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_congr","kind":"theorem","line":1236,"name":"Mathlib.Tactic.Ring.inv_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1236-L1237"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sub_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">sub_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a' </span><span class=\"fn\">b </span><span class=\"fn\">b' </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sub_congr","kind":"theorem","line":1233,"name":"Mathlib.Tactic.Ring.sub_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1233-L1234"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">neg_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a' </span><span class=\"fn\">b</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> → <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_congr","kind":"theorem","line":1230,"name":"Mathlib.Tactic.Ring.neg_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1230-L1231"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a' </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b </span><span class=\"fn\">b'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_congr","kind":"theorem","line":1227,"name":"Mathlib.Tactic.Ring.pow_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1227-L1228"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zsmul_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">zsmul_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b </span><span class=\"fn\">b' </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zsmul_congr","kind":"theorem","line":1222,"name":"Mathlib.Tactic.Ring.zsmul_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1222-L1225"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.nsmul_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">nsmul_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b </span><span class=\"fn\">b' </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.nsmul_congr","kind":"theorem","line":1218,"name":"Mathlib.Tactic.Ring.nsmul_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1218-L1220"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a' </span><span class=\"fn\">b </span><span class=\"fn\">b' </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_congr","kind":"theorem","line":1215,"name":"Mathlib.Tactic.Ring.mul_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1215-L1216"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a' </span><span class=\"fn\">b </span><span class=\"fn\">b' </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_congr","kind":"theorem","line":1212,"name":"Mathlib.Tactic.Ring.add_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1212-L1213"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalDiv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalDiv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#Semifield\">Semifield</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">czα</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharZero/Defs.html#CharZero\">CharZero</a> <span class=\"fn\">«$α»</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Divides two polynomials `va, vb` to get a normalized result polynomial.\n\n* `a / b = a * b⁻¹`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalDiv","kind":"def","line":1201,"name":"Mathlib.Tactic.Ring.evalDiv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1201-L1210"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.div_pf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">div_pf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#Semifield\">Semifield</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c </span><span class=\"fn\">d</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">b</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.div_pf","kind":"theorem","line":1197,"name":"Mathlib.Tactic.Ring.div_pf","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1197-L1199"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalInv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">evalInv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">dsα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#Semifield\">Semifield</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">czα</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharZero/Defs.html#CharZero\">CharZero</a> <span class=\"fn\">«$α»</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a>)</span>)</span></span></div></div>","info":{"doc":"Inverts a polynomial `va` to get a normalized result polynomial.\n\n* `0⁻¹ = 0`\n* `a⁻¹ = (a⁻¹)` if `a` is a nontrivial sum\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalInv","kind":"def","line":1179,"name":"Mathlib.Tactic.Ring.ExSum.evalInv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1179-L1193"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalInv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">evalInv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">dsα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#Semifield\">Semifield</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">czα</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharZero/Defs.html#CharZero\">CharZero</a> <span class=\"fn\">«$α»</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a>)</span>)</span></span></div></div>","info":{"doc":"Inverts a polynomial `va` to get a normalized result polynomial.\n\n* `c⁻¹ = (c⁻¹)` if `c` is a constant\n* `(a ^ b * c)⁻¹ = a⁻¹ ^ b * c⁻¹`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalInv","kind":"def","line":1153,"name":"Mathlib.Tactic.Ring.ExProd.evalInv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1153-L1177"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalInvAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalInvAtom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">dsα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#Semifield\">Semifield</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a>)</span>)</span></span></div></div>","info":{"doc":"Applies `⁻¹` to a polynomial to get an atom. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalInvAtom","kind":"def","line":1148,"name":"Mathlib.Tactic.Ring.evalInvAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1148-L1151"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">inv_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b₁ </span><span class=\"fn\">b₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₂</span> → <span class=\"fn\">↑(<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_add","kind":"theorem","line":1140,"name":"Mathlib.Tactic.Ring.inv_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1140-L1142"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_single\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">inv_single</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#Semifield\">Semifield</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> → (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span>)<a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_single","kind":"theorem","line":1138,"name":"Mathlib.Tactic.Ring.inv_single","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1138-L1139"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">inv_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#Semifield\">Semifield</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_zero","kind":"theorem","line":1136,"name":"Mathlib.Tactic.Ring.inv_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1136-L1136"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">inv_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#Semifield\">Semifield</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₃ </span><span class=\"fn\">b₁ </span><span class=\"fn\">b₃ </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a₁</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> → <span class=\"fn\"><span class=\"fn\">a₃</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₃</span> → <span class=\"fn\"><span class=\"fn\">b₃</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> (<span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → (<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₃</span>)<a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_mul","kind":"theorem","line":1131,"name":"Mathlib.Tactic.Ring.inv_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1131-L1134"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalAtom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">e</span>)</span></span></div></div>","info":{"doc":"Evaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAtom","kind":"def","line":1114,"name":"Mathlib.Tactic.Ring.evalAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1114-L1129"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.atom_pf'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">atom_pf'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.atom_pf'","kind":"theorem","line":1111,"name":"Mathlib.Tactic.Ring.atom_pf'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1111-L1112"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.atom_pf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">atom_pf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.atom_pf","kind":"theorem","line":1110,"name":"Mathlib.Tactic.Ring.atom_pf","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1110-L1110"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.toProd_pf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">toProd_pf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.toProd_pf","kind":"theorem","line":1108,"name":"Mathlib.Tactic.Ring.toProd_pf","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1108-L1109"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Meta.NormNum.Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">e</span>)</span></span></span></div></div>","info":{"doc":"Converts a proof by `norm_num` that `e` is a numeral, into a normalization as a monomial:\n\n* `e = 0` if `norm_num` returns `IsNat e 0`\n* `e = Nat.rawCast n + 0` if `norm_num` returns `IsNat e n`\n* `e = Int.rawCast n + 0` if `norm_num` returns `IsInt e n`\n* `e = NNRat.rawCast n d + 0` if `norm_num` returns `IsNNRat e n d`\n* `e = Rat.rawCast n d + 0` if `norm_num` returns `IsRat e n d`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalCast","kind":"def","line":1080,"name":"Mathlib.Tactic.Ring.evalCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1080-L1106"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_rat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">cast_rat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">Meta.NormNum.IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Rat.rawCast\">Rat.rawCast</a> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_rat","kind":"theorem","line":1076,"name":"Mathlib.Tactic.Ring.cast_rat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1076-L1078"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_nnrat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">cast_nnrat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">Meta.NormNum.IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#NNRat.rawCast\">NNRat.rawCast</a> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_nnrat","kind":"theorem","line":1072,"name":"Mathlib.Tactic.Ring.cast_nnrat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1072-L1074"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">cast_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">Meta.NormNum.IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">rawCast</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_neg","kind":"theorem","line":1068,"name":"Mathlib.Tactic.Ring.cast_neg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1068-L1070"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">cast_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Meta.NormNum.IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">0</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_zero","kind":"theorem","line":1065,"name":"Mathlib.Tactic.Ring.cast_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1065-L1066"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_pos\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">cast_pos</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Meta.NormNum.IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_pos","kind":"theorem","line":1062,"name":"Mathlib.Tactic.Ring.cast_pos","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1062-L1063"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mkCache\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mkCache</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <span class=\"fn\">sα</span>)</span></span></div></div>","info":{"doc":"Create a new cache for `α` by doing the necessary instance searches. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mkCache","kind":"def","line":1055,"name":"Mathlib.Tactic.Ring.mkCache","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1055-L1060"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.czα\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Cache</span>.<span class=\"name\">czα</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <span class=\"fn\">sα</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharZero/Defs.html#CharZero\">CharZero</a> <span class=\"fn\">«$α»</span></span>)</span></span></div></div>","info":{"doc":"A characteristic zero ring instance on `α`, if available. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.czα","kind":"def","line":1053,"name":"Mathlib.Tactic.Ring.Cache.czα","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1053-L1053"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.dsα\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Cache</span>.<span class=\"name\">dsα</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <span class=\"fn\">sα</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#Semifield\">Semifield</a> <span class=\"fn\">«$α»</span></span>)</span></span></div></div>","info":{"doc":"A division semiring instance on `α`, if available. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.dsα","kind":"def","line":1051,"name":"Mathlib.Tactic.Ring.Cache.dsα","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1051-L1051"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.rα\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Cache</span>.<span class=\"name\">rα</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <span class=\"fn\">sα</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">«$α»</span></span>)</span></span></div></div>","info":{"doc":"A ring instance on `α`, if available. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.rα","kind":"def","line":1049,"name":"Mathlib.Tactic.Ring.Cache.rα","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1049-L1049"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Cache</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">«$α»</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">dsα</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#Semifield\">Semifield</a> <span class=\"fn\">«$α»</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">czα</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharZero/Defs.html#CharZero\">CharZero</a> <span class=\"fn\">«$α»</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <span class=\"fn\">sα</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.mk","kind":"ctor","line":1047,"name":"Mathlib.Tactic.Ring.Cache.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1047-L1047"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Cache</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"This cache contains data required by the `ring` tactic during execution. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache","kind":"structure","line":1046,"name":"Mathlib.Tactic.Ring.Cache","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1046-L1053"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalPow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Exponentiates two polynomials `va, vb`.\n\n* `a ^ 0 = 1`\n* `a ^ (b₁ + b₂) = a ^ b₁ * a ^ b₂`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow","kind":"def","line":1031,"name":"Mathlib.Tactic.Ring.evalPow","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1031-L1044"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">c₁ </span><span class=\"fn\">c₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b₁ </span><span class=\"fn\">b₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">d</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₁</span> → <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₂</span> → <span class=\"fn\"><span class=\"fn\">c₁</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> (<span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_add","kind":"theorem","line":1027,"name":"Mathlib.Tactic.Ring.pow_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1027-L1029"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_zero","kind":"theorem","line":1025,"name":"Mathlib.Tactic.Ring.pow_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L1025-L1025"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow₁\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalPow₁</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Exponentiates a polynomial `va` by a monomial `vb`, including several special cases.\n\n* `a ^ 1 = a`\n* `0 ^ e = 0` if `0 < e`\n* `(a + 0) ^ b = a ^ b` computed using `evalPowProd`\n* `a ^ b = (a ^ b') ^ k` if `b = b' * k` and `k > 1`\n\nOtherwise `a ^ b` is just encoded as `a ^ b * 1 + 0` using `evalPowAtom`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow₁","kind":"opaque","line":995,"name":"Mathlib.Tactic.Ring.evalPow₁","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L995-L1023"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_nat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_nat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b </span><span class=\"fn\">c </span><span class=\"fn\">k</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">d </span><span class=\"fn\">e</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">k</span> → <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span> → <span class=\"fn\"><span class=\"fn\">d</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">e</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">e</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_nat","kind":"theorem","line":991,"name":"Mathlib.Tactic.Ring.pow_nat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L991-L993"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.single_pow\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">single_pow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span>) <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.single_pow","kind":"theorem","line":988,"name":"Mathlib.Tactic.Ring.single_pow","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L988-L989"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zero_pow\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">zero_pow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span> → <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zero_pow","kind":"theorem","line":986,"name":"Mathlib.Tactic.Ring.zero_pow","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L986-L986"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_one_cast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_one_cast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_one_cast","kind":"theorem","line":984,"name":"Mathlib.Tactic.Ring.pow_one_cast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L984-L984"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.extractCoeff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">extractCoeff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff\">ExtractCoeff</a> <span class=\"fn\">a</span></span></div></div>","info":{"doc":"Given a monomial expression `va`, splits off the leading coefficient `k` and the remainder\n`e'`, stored in the `ExtractCoeff` structure.\n\n* `c = 1 * c` (if `c` is a constant)\n* `a * b = (a * b') * k` if `b = b' * k`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.extractCoeff","kind":"def","line":967,"name":"Mathlib.Tactic.Ring.extractCoeff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L967-L982"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.coeff_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">coeff_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₃ </span><span class=\"fn\">c₂ </span><span class=\"fn\">k</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁ </span><span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a₃</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">k</span> → <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₃</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">k</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.coeff_mul","kind":"theorem","line":963,"name":"Mathlib.Tactic.Ring.coeff_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L963-L965"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.coeff_one\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">coeff_one</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">k</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">k</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.coeff_one","kind":"theorem","line":961,"name":"Mathlib.Tactic.Ring.coeff_one","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L961-L961"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.p\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExtractCoeff</span>.<span class=\"name\">p</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff\">ExtractCoeff</a> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">unknown_1</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">unknown_2</span>)</span></div></div>","info":{"doc":"The proof that `e` splits into the coefficient `k` and the monic monomial `e'`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.p","kind":"def","line":959,"name":"Mathlib.Tactic.Ring.ExtractCoeff.p","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L959-L959"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.ve'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExtractCoeff</span>.<span class=\"name\">ve'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff\">ExtractCoeff</a> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'\">e'</a></span></span></div></div>","info":{"doc":"`e'` is a monomial. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.ve'","kind":"def","line":957,"name":"Mathlib.Tactic.Ring.ExtractCoeff.ve'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L957-L957"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExtractCoeff</span>.<span class=\"name\">e'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff\">ExtractCoeff</a> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></div></div>","info":{"doc":"The result of extracting the coefficient is a monic monomial. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'","kind":"def","line":955,"name":"Mathlib.Tactic.Ring.ExtractCoeff.e'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L955-L955"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExtractCoeff</span>.<span class=\"name\">k</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff\">ExtractCoeff</a> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></div></div>","info":{"doc":"A raw natural number literal. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k","kind":"def","line":953,"name":"Mathlib.Tactic.Ring.ExtractCoeff.k","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L953-L953"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExtractCoeff</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k </span><span class=\"fn\">e'</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ve'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">e'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$e'»</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">«$k»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff\">ExtractCoeff</a> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.mk","kind":"ctor","line":951,"name":"Mathlib.Tactic.Ring.ExtractCoeff.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L951-L951"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExtractCoeff</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The result of `extractCoeff` is a numeral and a proof that the original expression\nfactors by this numeral.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff","kind":"structure","line":947,"name":"Mathlib.Tactic.Ring.ExtractCoeff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L947-L959"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalPowProd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"There are several special cases when exponentiating monomials:\n\n* `1 ^ n = 1`\n* `x ^ y = (x ^ y)` when `x` and `y` are constants\n* `(a * b) ^ e = a ^ e * b ^ e`\n\nIn all other cases we use `evalPowProdAtom`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProd","kind":"def","line":914,"name":"Mathlib.Tactic.Ring.evalPowProd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L914-L945"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pow\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_pow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₂ </span><span class=\"fn\">c₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">ea₁ </span><span class=\"fn\">b </span><span class=\"fn\">c₁</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">xa₁</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">ea₁</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₁</span> → <span class=\"fn\"><span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₂</span> → (<span class=\"fn\">xa₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">ea₁</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₂</span>) <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">xa₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">c₁</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c₂</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pow","kind":"theorem","line":904,"name":"Mathlib.Tactic.Ring.mul_pow","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L904-L906"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.one_pow\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">one_pow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.one_pow","kind":"theorem","line":902,"name":"Mathlib.Tactic.Ring.one_pow","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L902-L902"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalPowNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$n»</span>)</span>)</span></span></div></div>","info":{"doc":"The main case of exponentiation of ring expressions is when `va` is a polynomial and `n` is a\nnonzero literal expression, like `(x + y)^5`. In this case we work out the polynomial completely\ninto a sum of monomials.\n\n* `x ^ 1 = x`\n* `x ^ (2*n) = x ^ n * x ^ n`\n* `x ^ (2*n+1) = x ^ n * x ^ n * x`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowNat","kind":"opaque","line":872,"name":"Mathlib.Tactic.Ring.evalPowNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L872-L900"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_bit1\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_bit1</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">k</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">d</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Nat.mul\">Nat.mul</a> <span class=\"fn\">2</span> <span class=\"fn\">k</span>)</span>.<a href=\"./Init/Prelude.html#Nat.add\">add</a></span> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_bit1","kind":"theorem","line":868,"name":"Mathlib.Tactic.Ring.pow_bit1","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L868-L870"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_bit0\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_bit0</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">k</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat.mul\">Nat.mul</a> <span class=\"fn\">2</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_bit0","kind":"theorem","line":864,"name":"Mathlib.Tactic.Ring.pow_bit0","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L864-L866"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_one\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">1</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_one","kind":"theorem","line":862,"name":"Mathlib.Tactic.Ring.pow_one","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L862-L862"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalPos\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">evalPos</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">«$a»</span>)</span></span></div></div>","info":{"doc":"Attempts to prove that a polynomial expression in `ℕ` is positive.\n\n* `0 < 0` fails\n* `0 < a + b` if `0 < a` or `0 < b`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalPos","kind":"opaque","line":847,"name":"Mathlib.Tactic.Ring.ExSum.evalPos","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L847-L858"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalPos\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">evalPos</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">«$a»</span>)</span></span></div></div>","info":{"doc":"Attempts to prove that a monomial expression in `ℕ` is positive.\n\n* `0 < c` (where `c` is a numeral) is true by the normalization invariant (`c` is not zero)\n* `0 < x ^ e * b` if `0 < x` and `0 < b`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalPos","kind":"opaque","line":829,"name":"Mathlib.Tactic.Ring.ExProd.evalPos","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L829-L845"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalPos\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">evalPos</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">«$a»</span>)</span></span></div></div>","info":{"doc":"Attempts to prove that a polynomial expression in `ℕ` is positive.\n\n* Atoms are not (necessarily) positive\n* Sums defer to `ExSum.evalPos`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalPos","kind":"opaque","line":819,"name":"Mathlib.Tactic.Ring.ExBase.evalPos","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L819-L827"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pos_right\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pos_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a₂</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pos_right","kind":"theorem","line":814,"name":"Mathlib.Tactic.Ring.add_pos_right","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L814-L815"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pos_left\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pos_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a₁</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pos_left","kind":"theorem","line":811,"name":"Mathlib.Tactic.Ring.add_pos_left","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L811-L812"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_exp_pos\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_exp_pos</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a₁</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a₂</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₂</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_exp_pos","kind":"theorem","line":808,"name":"Mathlib.Tactic.Ring.mul_exp_pos","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L808-L809"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.const_pos\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">const_pos</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat.ble\">Nat.ble</a> <span class=\"fn\">1</span> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.const_pos","kind":"theorem","line":806,"name":"Mathlib.Tactic.Ring.const_pos","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L806-L806"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalPowAtom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$b»</span>)</span></span></div></div>","info":{"doc":"The fallback case for exponentiating polynomials is to use `ExBase.toProd` to just build an\nexponent expression.\n\n* `x ^ e = x ^ e * 1 + 0`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowAtom","kind":"def","line":796,"name":"Mathlib.Tactic.Ring.evalPowAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L796-L804"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_atom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_atom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_atom","kind":"theorem","line":794,"name":"Mathlib.Tactic.Ring.pow_atom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L794-L794"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProdAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalPowProdAtom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$b»</span>)</span></span></div></div>","info":{"doc":"The fallback case for exponentiating polynomials is to use `ExBase.toProd` to just build an\nexponent expression. (This has a slightly different normalization than `evalPowAtom` because\nthe input types are different.)\n\n* `x ^ e = (x + 0) ^ e * 1`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProdAtom","kind":"def","line":783,"name":"Mathlib.Tactic.Ring.evalPowProdAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L783-L792"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_prod_atom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_prod_atom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span>) <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_prod_atom","kind":"theorem","line":781,"name":"Mathlib.Tactic.Ring.pow_prod_atom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L781-L781"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalSub\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalSub</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Subtracts two polynomials `va, vb` to get a normalized result polynomial.\n\n* `a - b = a + -b`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalSub","kind":"def","line":767,"name":"Mathlib.Tactic.Ring.evalSub","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L767-L777"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sub_pf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">sub_pf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c </span><span class=\"fn\">d</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sub_pf","kind":"theorem","line":764,"name":"Mathlib.Tactic.Ring.sub_pf","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L764-L765"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNeg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalNeg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">«$a»</span>)</span>)</span></span></div></div>","info":{"doc":"Negates a polynomial `va` to get another polynomial.\n\n* `-0 = 0` (for `c` coefficient)\n* `-(a₁ + a₂) = -a₁ + -a₂`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNeg","kind":"def","line":747,"name":"Mathlib.Tactic.Ring.evalNeg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L747-L760"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">neg_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂ </span><span class=\"fn\">b₁ </span><span class=\"fn\">b₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₂</span> → <a href=\"./Init/Prelude.html#Neg.neg\">-</a>(<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_add","kind":"theorem","line":743,"name":"Mathlib.Tactic.Ring.neg_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L743-L745"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">neg_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">-<span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_zero","kind":"theorem","line":741,"name":"Mathlib.Tactic.Ring.neg_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L741-L741"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNegProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalNegProd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">«$a»</span>)</span>)</span></span></div></div>","info":{"doc":"Negates a monomial `va` to get another monomial.\n\n* `-c = (-c)` (for `c` coefficient)\n* `-(a₁ * a₂) = a₁ * -a₂`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNegProd","kind":"def","line":719,"name":"Mathlib.Tactic.Ring.evalNegProd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L719-L739"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">neg_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₃ </span><span class=\"fn\">b</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a₃</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> → <a href=\"./Init/Prelude.html#Neg.neg\">-</a>(<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₃</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_mul","kind":"theorem","line":716,"name":"Mathlib.Tactic.Ring.neg_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L716-L717"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_one_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">neg_one_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">1</span>)</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">rawCast</a></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> → <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_one_mul","kind":"theorem","line":713,"name":"Mathlib.Tactic.Ring.neg_one_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L713-L714"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalZSMul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalZSMul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℤ\">sℤ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Constructs the scalar multiplication `n • a`, where both `n : ℤ` and `a : α` are normalized\npolynomial expressions.\n\n* `a • b = a * b` if `α = ℤ`\n* `a • b = a' * b` otherwise, where `a'` is `↑a` with the coercion pushed as deep as possible.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalZSMul","kind":"def","line":691,"name":"Mathlib.Tactic.Ring.evalZSMul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L691-L709"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_eq_intCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">smul_eq_intCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a' </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_eq_intCast","kind":"theorem","line":687,"name":"Mathlib.Tactic.Ring.smul_eq_intCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L687-L689"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_int\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">smul_int</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_int","kind":"theorem","line":685,"name":"Mathlib.Tactic.Ring.smul_int","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L685-L685"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalIntCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">evalIntCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℤ\">sℤ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">↑<span class=\"fn\">«$a»</span></span>)</span>)</span></span></div></div>","info":{"doc":"Applies `Int.cast` to an int polynomial to produce a polynomial in `α`.\n\n* `↑0 = 0`\n* `↑(a + b) = ↑a + ↑b`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalIntCast","kind":"opaque","line":666,"name":"Mathlib.Tactic.Ring.ExSum.evalIntCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L666-L681"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalIntCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">evalIntCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℤ\">sℤ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">↑<span class=\"fn\">«$a»</span></span>)</span>)</span></span></div></div>","info":{"doc":"Applies `Int.cast` to an int monomial to produce a monomial in `α`.\n\n* `↑c = c` if `c` is a numeric literal\n* `↑(a ^ n * b) = ↑a ^ n * ↑b`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalIntCast","kind":"opaque","line":646,"name":"Mathlib.Tactic.Ring.ExProd.evalIntCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L646-L664"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalIntCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">evalIntCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℤ\">sℤ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">↑<span class=\"fn\">«$a»</span></span>)</span>)</span></span></div></div>","info":{"doc":"Applies `Int.cast` to an int polynomial to produce a polynomial in `α`.\n\n* An atom `e` causes `↑e` to be allocated as a new atom.\n* A sum delegates to `ExSum.evalIntCast`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalIntCast","kind":"opaque","line":630,"name":"Mathlib.Tactic.Ring.ExBase.evalIntCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L630-L643"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">intCast_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b₁ </span><span class=\"fn\">b₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₂</span> → <span class=\"fn\">↑(<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_add","kind":"theorem","line":624,"name":"Mathlib.Tactic.Ring.intCast_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L624-L626"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">intCast_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_zero","kind":"theorem","line":622,"name":"Mathlib.Tactic.Ring.intCast_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L622-L622"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">intCast_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b₁ </span><span class=\"fn\">b₃</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₃</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₃</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₃</span> → <span class=\"fn\">↑(<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₃</span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₃</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_mul","kind":"theorem","line":618,"name":"Mathlib.Tactic.Ring.intCast_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L618-L620"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_negOfNat_Int\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">intCast_negOfNat_Int</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">rawCast</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">rawCast</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_negOfNat_Int","kind":"theorem","line":615,"name":"Mathlib.Tactic.Ring.intCast_negOfNat_Int","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L615-L616"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_int\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">natCast_int</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_int","kind":"theorem","line":613,"name":"Mathlib.Tactic.Ring.natCast_int","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L613-L613"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNSMul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalNSMul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Constructs the scalar multiplication `n • a`, where both `n : ℕ` and `a : α` are normalized\npolynomial expressions.\n\n* `a • b = a * b` if `α = ℕ`\n* `a • b = ↑a * b` otherwise\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNSMul","kind":"def","line":592,"name":"Mathlib.Tactic.Ring.evalNSMul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L592-L609"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_eq_cast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">smul_eq_cast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a' </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_eq_cast","kind":"theorem","line":589,"name":"Mathlib.Tactic.Ring.smul_eq_cast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L589-L590"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_nat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">smul_nat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_nat","kind":"theorem","line":587,"name":"Mathlib.Tactic.Ring.smul_nat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L587-L587"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalNatCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">evalNatCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">↑<span class=\"fn\">«$a»</span></span>)</span>)</span></span></div></div>","info":{"doc":"Applies `Nat.cast` to a nat polynomial to produce a polynomial in `α`.\n\n* `↑0 = 0`\n* `↑(a + b) = ↑a + ↑b`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalNatCast","kind":"opaque","line":572,"name":"Mathlib.Tactic.Ring.ExSum.evalNatCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L572-L583"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalNatCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">evalNatCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">↑<span class=\"fn\">«$a»</span></span>)</span>)</span></span></div></div>","info":{"doc":"Applies `Nat.cast` to a nat monomial to produce a monomial in `α`.\n\n* `↑c = c` if `c` is a numeric literal\n* `↑(a ^ n * b) = ↑a ^ n * ↑b`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalNatCast","kind":"opaque","line":556,"name":"Mathlib.Tactic.Ring.ExProd.evalNatCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L556-L570"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalNatCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">evalNatCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">↑<span class=\"fn\">«$a»</span></span>)</span>)</span></span></div></div>","info":{"doc":"Applies `Nat.cast` to a nat polynomial to produce a polynomial in `α`.\n\n* An atom `e` causes `↑e` to be allocated as a new atom.\n* A sum delegates to `ExSum.evalNatCast`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalNatCast","kind":"opaque","line":542,"name":"Mathlib.Tactic.Ring.ExBase.evalNatCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L542-L554"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">natCast_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b₁ </span><span class=\"fn\">b₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₂</span> → <span class=\"fn\">↑(<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_add","kind":"theorem","line":536,"name":"Mathlib.Tactic.Ring.natCast_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L536-L538"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">natCast_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_zero","kind":"theorem","line":534,"name":"Mathlib.Tactic.Ring.natCast_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L534-L534"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">natCast_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b₁ </span><span class=\"fn\">b₃</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₃</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₃</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₃</span> → <span class=\"fn\">↑(<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₃</span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₃</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_mul","kind":"theorem","line":530,"name":"Mathlib.Tactic.Ring.natCast_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L530-L532"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_nat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">natCast_nat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_nat","kind":"theorem","line":528,"name":"Mathlib.Tactic.Ring.natCast_nat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L528-L528"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalMul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Multiplies two polynomials `va, vb` together to get a normalized result polynomial.\n\n* `0 * b = 0`\n* `(a₁ + a₂) * b = (a₁ * b) + (a₂ * b)`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul","kind":"def","line":511,"name":"Mathlib.Tactic.Ring.evalMul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L511-L524"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂ </span><span class=\"fn\">b </span><span class=\"fn\">c₁ </span><span class=\"fn\">c₂ </span><span class=\"fn\">d</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₁</span> → <span class=\"fn\"><span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₂</span> → <span class=\"fn\"><span class=\"fn\">c₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span> → (<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span>) <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_mul","kind":"theorem","line":508,"name":"Mathlib.Tactic.Ring.add_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L508-L509"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zero_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">zero_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zero_mul","kind":"theorem","line":506,"name":"Mathlib.Tactic.Ring.zero_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L506-L506"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul₁\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalMul₁</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Multiplies a monomial `va` to a polynomial `vb` to get a normalized result polynomial.\n\n* `a * 0 = 0`\n* `a * (b₁ + b₂) = (a * b₁) + (a * b₂)`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul₁","kind":"def","line":491,"name":"Mathlib.Tactic.Ring.evalMul₁","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L491-L504"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b₁ </span><span class=\"fn\">b₂ </span><span class=\"fn\">c₁ </span><span class=\"fn\">c₂ </span><span class=\"fn\">d</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₁</span> → <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₂</span> → <span class=\"fn\"><span class=\"fn\">c₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> (<span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_add","kind":"theorem","line":487,"name":"Mathlib.Tactic.Ring.mul_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L487-L489"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_zero","kind":"theorem","line":485,"name":"Mathlib.Tactic.Ring.mul_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L485-L485"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMulProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalMulProd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n  (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMulProd","kind":"opaque","line":438,"name":"Mathlib.Tactic.Ring.evalMulProd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L438-L483"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pp_pf_overlap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_pp_pf_overlap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₂ </span><span class=\"fn\">b₂ </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">ea </span><span class=\"fn\">eb </span><span class=\"fn\">e</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">ea</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">eb</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">e</span> → <span class=\"fn\"><span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">ea</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> (<span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">eb</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₂</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">e</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pp_pf_overlap","kind":"theorem","line":434,"name":"Mathlib.Tactic.Ring.mul_pp_pf_overlap","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L434-L436"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pf_right\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_pf_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b₃ </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b₁</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₃</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> (<span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₃</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pf_right","kind":"theorem","line":430,"name":"Mathlib.Tactic.Ring.mul_pf_right","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L430-L432"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pf_left\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_pf_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₃ </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a₃</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₃</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pf_left","kind":"theorem","line":426,"name":"Mathlib.Tactic.Ring.mul_pf_left","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L426-L428"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_one\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_one","kind":"theorem","line":424,"name":"Mathlib.Tactic.Ring.mul_one","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L424-L424"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.one_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">one_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.one_mul","kind":"theorem","line":422,"name":"Mathlib.Tactic.Ring.one_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L422-L422"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAdd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalAdd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Adds two polynomials `va, vb` together to get a normalized result polynomial.\n\n* `0 + b = b`\n* `a + 0 = a`\n* `a * x + a * y = a * (x + y)` (for `x`, `y` coefficients; uses `evalAddOverlap`)\n* `(a₁ + a₂) + (b₁ + b₂) = a₁ + (a₂ + (b₁ + b₂))` (if `a₁.lt b₁`)\n* `(a₁ + a₂) + (b₁ + b₂) = b₁ + ((a₁ + a₂) + b₂)` (if not `a₁.lt b₁`)\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAdd","kind":"opaque","line":389,"name":"Mathlib.Tactic.Ring.evalAdd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L389-L418"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_gt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pf_add_gt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b₂ </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b₁</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> (<span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_gt","kind":"theorem","line":386,"name":"Mathlib.Tactic.Ring.add_pf_add_gt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L386-L387"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_lt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pf_add_lt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₂ </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_lt","kind":"theorem","line":384,"name":"Mathlib.Tactic.Ring.add_pf_add_lt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L384-L384"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_overlap_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pf_add_overlap_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂ </span><span class=\"fn\">b₁ </span><span class=\"fn\">b₂ </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Meta.NormNum.IsNat</a> (<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₁</span>) <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₄</span> : <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> (<span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_overlap_zero","kind":"theorem","line":380,"name":"Mathlib.Tactic.Ring.add_pf_add_overlap_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L380-L382"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_overlap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pf_add_overlap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂ </span><span class=\"fn\">b₁ </span><span class=\"fn\">b₂ </span><span class=\"fn\">c₁ </span><span class=\"fn\">c₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₁</span> → <span class=\"fn\"><span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₂</span> → <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> (<span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c₂</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_overlap","kind":"theorem","line":376,"name":"Mathlib.Tactic.Ring.add_pf_add_overlap","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L376-L378"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pf_add_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_zero","kind":"theorem","line":374,"name":"Mathlib.Tactic.Ring.add_pf_add_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L374-L374"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_zero_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pf_zero_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_zero_add","kind":"theorem","line":372,"name":"Mathlib.Tactic.Ring.add_pf_zero_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L372-L372"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAddOverlap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalAddOverlap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/Option.html#OptionT\">OptionT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap\">Overlap</a> <span class=\"fn\">sα</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Given monomials `va, vb`, attempts to add them together to get another monomial.\nIf the monomials are not compatible, returns `none`.\nFor example, `xy + 2xy = 3xy` is a `.nonzero` overlap, while `xy + xz` returns `none`\nand `xy + -xy = 0` is a `.zero` overlap.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAddOverlap","kind":"def","line":344,"name":"Mathlib.Tactic.Ring.evalAddOverlap","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L344-L370"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_overlap_pf_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_overlap_pf_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Meta.NormNum.IsNat</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b</span>) <span class=\"fn\">0</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Meta.NormNum.IsNat</a> (<span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">e</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">e</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span>) <span class=\"fn\">0</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_overlap_pf_zero","kind":"theorem","line":335,"name":"Mathlib.Tactic.Ring.add_overlap_pf_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L335-L337"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_overlap_pf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_overlap_pf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pq_pf</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">e</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">e</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">e</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_overlap_pf","kind":"theorem","line":332,"name":"Mathlib.Tactic.Ring.add_overlap_pf","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L332-L333"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap.nonzero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Overlap</span>.<span class=\"name\">nonzero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap\">Overlap</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></span></div></div>","info":{"doc":"The expression `e` (the sum of monomials) is equal to another monomial\n(with nonzero leading coefficient). ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap.nonzero","kind":"ctor","line":324,"name":"Mathlib.Tactic.Ring.Overlap.nonzero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L324-L326"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap.zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Overlap</span>.<span class=\"name\">zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Meta.NormNum.IsNat</a> <span class=\"fn\">«$e»</span> <span class=\"fn\">0</span></span>)</span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap\">Overlap</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></span></div></div>","info":{"doc":"The expression `e` (the sum of monomials) is equal to `0`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap.zero","kind":"ctor","line":322,"name":"Mathlib.Tactic.Ring.Overlap.zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L322-L323"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Overlap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Two monomials are said to \"overlap\" if they differ by a constant factor, in which case the\nconstants just add. When this happens, the constant may be either zero (if the monomials cancel)\nor nonzero (if they add up); the zero case is handled specially.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap","kind":"inductive","line":316,"name":"Mathlib.Tactic.Ring.Overlap","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L316-L326"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.coeff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">coeff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span> → <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a></span></div></div>","info":{"doc":"Get the leading coefficient of an `ExProd`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.coeff","kind":"def","line":310,"name":"Mathlib.Tactic.Ring.ExProd.coeff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L310-L313"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.toSum\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">toSum</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">v</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span>)</span></span></div></div>","info":{"doc":"Embed `ExProd` in `ExSum` by adding 0. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.toSum","kind":"def","line":306,"name":"Mathlib.Tactic.Ring.ExProd.toSum","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L306-L308"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.toProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">toProd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$b»</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span>)</span></span></div></div>","info":{"doc":"Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.toProd","kind":"def","line":301,"name":"Mathlib.Tactic.Ring.ExBase.toProd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L301-L304"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNegNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">mkNegNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">«$α»</span></span>)</span> → <span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>) → <span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>) → <span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>) → <span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></span></span></span></span></span></div></div>","info":{"doc":"Constructs the expression corresponding to `.const q h` for `q = -(n / d)`\nand `h` a proof that `(d : α) ≠ 0`.\n(The `.const` constructor does not check that the expression is correct.)\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNegNNRat","kind":"def","line":290,"name":"Mathlib.Tactic.Ring.ExProd.mkNegNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L290-L297"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">mkNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">«$α»</span></span>)</span> → <span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>) → <span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>) → <span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>) → <span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></span></span></span></span></span></div></div>","info":{"doc":"Constructs the expression corresponding to `.const q h` for `q = n / d`\nand `h` a proof that `(d : α) ≠ 0`.\n(The `.const` constructor does not check that the expression is correct.)\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNNRat","kind":"def","line":281,"name":"Mathlib.Tactic.Ring.ExProd.mkNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L281-L288"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNegNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">mkNegNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span> → <span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>) → <span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></span></span></span></div></div>","info":{"doc":"Constructs the expression corresponding to `.const (-n)`.\n(The `.const` constructor does not check that the expression is correct.)\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNegNat","kind":"def","line":273,"name":"Mathlib.Tactic.Ring.ExProd.mkNegNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L273-L279"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">mkNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></span></div></div>","info":{"doc":"Constructs the expression corresponding to `.const n`.\n(The `.const` constructor does not check that the expression is correct.)\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNat","kind":"def","line":265,"name":"Mathlib.Tactic.Ring.ExProd.mkNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L265-L271"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">instInhabitedResultOfSigmaQuoted</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">E</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">((<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><span class=\"fn\">E</span> <span class=\"fn\">e</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">E</span> <span class=\"fn\">e</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted","kind":"instance","line":258,"name":"Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L258-L260"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.proof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Result</span>.<span class=\"name\">proof</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">E</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">E</span> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">unknown_1</span>)</span></div></div>","info":{"doc":"A proof that the original expression is equal to the normalized result. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.proof","kind":"def","line":256,"name":"Mathlib.Tactic.Ring.Result.proof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L256-L256"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.val\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Result</span>.<span class=\"name\">val</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">E</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">E</span> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">E</span> <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.expr\">expr</a></span></span></div></div>","info":{"doc":"The data associated to the normalization. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.val","kind":"def","line":254,"name":"Mathlib.Tactic.Ring.Result.val","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L254-L254"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.expr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Result</span>.<span class=\"name\">expr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">E</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">E</span> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span></div></div>","info":{"doc":"The normalized result. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.expr","kind":"def","line":252,"name":"Mathlib.Tactic.Ring.Result.expr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L252-L252"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Result</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">E</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">val</span> : <span class=\"fn\"><span class=\"fn\">E</span> <span class=\"fn\">expr</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$expr»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">E</span> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk","kind":"ctor","line":250,"name":"Mathlib.Tactic.Ring.Result.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L250-L250"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Result</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">E</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span> → <a href=\"./foundational_types.html\">Type</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The result of evaluating an (unnormalized) expression `e` into the type family `E`\n(one of `ExSum`, `ExProd`, `ExBase`) is a (normalized) element `e'`\nand a representation `E e'` for it, and a proof of `e = e'`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result","kind":"structure","line":245,"name":"Mathlib.Tactic.Ring.Result","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L245-L256"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.cast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">cast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sβ</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$β»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$β»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sβ</span> <span class=\"fn\">a</span></span></span></span></div></div>","info":{"doc":"Converts `ExSum sα` to `ExSum sβ`, assuming `sα` and `sβ` are defeq. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.cast","kind":"def","line":236,"name":"Mathlib.Tactic.Ring.ExSum.cast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L236-L241"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.cast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">cast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sβ</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$β»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$β»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sβ</span> <span class=\"fn\">a</span></span></span></span></div></div>","info":{"doc":"Converts `ExProd sα` to `ExProd sβ`, assuming `sα` and `sβ` are defeq. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.cast","kind":"def","line":229,"name":"Mathlib.Tactic.Ring.ExProd.cast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L229-L234"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.cast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">cast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sβ</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$β»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$β»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sβ</span> <span class=\"fn\">a</span></span></span></span></div></div>","info":{"doc":"Converts `ExBase sα` to `ExBase sβ`, assuming `sα` and `sβ` are defeq. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.cast","kind":"def","line":222,"name":"Mathlib.Tactic.Ring.ExBase.cast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L222-L227"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">instInhabitedSigmaQuotedExProd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">((<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd","kind":"instance","line":218,"name":"Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L218-L218"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">instInhabitedSigmaQuotedExSum</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">((<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum","kind":"instance","line":217,"name":"Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L217-L217"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">instInhabitedSigmaQuotedExBase</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">((<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase","kind":"instance","line":216,"name":"Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L216-L216"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.cmp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">cmp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <a href=\"./Init/Data/Ord/Basic.html#Ordering\">Ordering</a></span></span></div></div>","info":{"doc":"A total order on normalized expressions.\nThis is not an `Ord` instance because it is heterogeneous.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.cmp","kind":"def","line":204,"name":"Mathlib.Tactic.Ring.ExSum.cmp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L204-L211"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.cmp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">cmp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <a href=\"./Init/Data/Ord/Basic.html#Ordering\">Ordering</a></span></span></div></div>","info":{"doc":"A total order on normalized expressions.\nThis is not an `Ord` instance because it is heterogeneous.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.cmp","kind":"def","line":195,"name":"Mathlib.Tactic.Ring.ExProd.cmp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L195-L202"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.cmp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">cmp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <a href=\"./Init/Data/Ord/Basic.html#Ordering\">Ordering</a></span></span></div></div>","info":{"doc":"A total order on normalized expressions.\nThis is not an `Ord` instance because it is heterogeneous.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.cmp","kind":"def","line":183,"name":"Mathlib.Tactic.Ring.ExBase.cmp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L183-L193"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span></div></div>","info":{"doc":"Equality test for expressions. This is not a `BEq` instance because it is heterogeneous. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.eq","kind":"def","line":173,"name":"Mathlib.Tactic.Ring.ExSum.eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L173-L179"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span></div></div>","info":{"doc":"Equality test for expressions. This is not a `BEq` instance because it is heterogeneous. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.eq","kind":"def","line":165,"name":"Mathlib.Tactic.Ring.ExProd.eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L165-L171"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span></div></div>","info":{"doc":"Equality test for expressions. This is not a `BEq` instance because it is heterogeneous. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.eq","kind":"def","line":157,"name":"Mathlib.Tactic.Ring.ExBase.eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L157-L163"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">«$b»</span>)</span></span></span></span></div></div>","info":{"doc":"A sum `a + b` is a polynomial if `a` is a monomial and `b` is another polynomial. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.add","kind":"ctor","line":150,"name":"Mathlib.Tactic.Ring.ExSum.add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L150-L152"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">q(<span class=\"fn\">0</span>)</span></span></div></div>","info":{"doc":"Zero is a polynomial. `e` is the expression `0`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero","kind":"ctor","line":148,"name":"Mathlib.Tactic.Ring.ExSum.zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L148-L149"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span> → <span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) → <a href=\"./foundational_types.html\">Type</a></span></span></div></div>","info":{"doc":"A polynomial expression, which is a sum of monomials. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum","kind":"inductive","line":146,"name":"Mathlib.Tactic.Ring.ExSum","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L146-L152"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">x</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">q(<span class=\"fn\">«$x»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">«$b»</span>)</span></span></span></span></span></div></div>","info":{"doc":"A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\nand `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\na polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mul","kind":"ctor","line":140,"name":"Mathlib.Tactic.Ring.ExProd.mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L140-L144"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">const</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">value</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyp</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\nIf `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const","kind":"ctor","line":137,"name":"Mathlib.Tactic.Ring.ExProd.const","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L137-L139"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span> → <span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) → <a href=\"./foundational_types.html\">Type</a></span></span></div></div>","info":{"doc":"A monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd","kind":"inductive","line":132,"name":"Mathlib.Tactic.Ring.ExProd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L132-L144"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.sum\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">sum</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></span></div></div>","info":{"doc":"A sum of monomials. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.sum","kind":"ctor","line":129,"name":"Mathlib.Tactic.Ring.ExBase.sum","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L129-L130"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.atom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">atom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">id</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"An atomic expression `e` with id `id`.\n\nAtomic expressions are those which `ring` cannot parse any further.\nFor instance, `a + (a % b)` has `a` and `(a % b)` as atoms.\nThe `ring1` tactic does not normalize the subexpressions in atoms, but `ring_nf` does.\n\nAtoms in fact represent equivalence classes of expressions, modulo definitional equality.\nThe field `index : ℕ` should be a unique number for each class,\nwhile `value : expr` contains a representative of this class.\nThe function `resolve_atom` determines the appropriate atom for a given expression.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.atom","kind":"ctor","line":116,"name":"Mathlib.Tactic.Ring.ExBase.atom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L116-L128"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span> → <span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) → <a href=\"./foundational_types.html\">Type</a></span></span></div></div>","info":{"doc":"The base `e` of a normalized exponent expression. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase","kind":"inductive","line":114,"name":"Mathlib.Tactic.Ring.ExBase","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L114-L130"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℤ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">sℤ</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></div></div>","info":{"doc":"A typed expression of type `CommSemiring ℤ` used when we are working on\nring subexpressions of type `ℤ`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℤ","kind":"def","line":106,"name":"Mathlib.Tactic.Ring.sℤ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L106-L110"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">sℕ</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></div></div>","info":{"doc":"A typed expression of type `CommSemiring ℕ` used when we are working on\nring subexpressions of type `ℕ`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ","kind":"def","line":100,"name":"Mathlib.Tactic.Ring.sℕ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L100-L104"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">instCommSemiringInt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span></div></div>","info":{"doc":"A shortcut instance for `CommSemiring ℤ` used by ring. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringInt","kind":"def","line":97,"name":"Mathlib.Tactic.Ring.instCommSemiringInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L97-L98"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">instCommSemiringNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>","info":{"doc":"A shortcut instance for `CommSemiring ℕ` used by ring. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringNat","kind":"def","line":94,"name":"Mathlib.Tactic.Ring.instCommSemiringNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Basic.lean#L94-L95"}}],"imports":["Init","Mathlib.Util.AtomM","Mathlib.Algebra.Order.Ring.Unbundled.Rat","Mathlib.Tactic.NormNum.Inv","Mathlib.Tactic.NormNum.Pow","Mathlib.Tactic.NormNum.Result"],"instances":[{"className":"Inhabited","name":"Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase","typeNames":["Sigma"]},{"className":"Inhabited","name":"Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum","typeNames":["Sigma"]},{"className":"Inhabited","name":"Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd","typeNames":["Sigma"]},{"className":"Inhabited","name":"Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted","typeNames":["Mathlib.Tactic.Ring.Result"]},{"className":"Mathlib.Tactic.Ring.CSLiftVal","name":"Mathlib.Tactic.Ring.instCSLiftValLift","typeNames":["Mathlib.Tactic.Ring.CSLift.lift"]}],"name":"Mathlib.Tactic.Ring.Basic"}