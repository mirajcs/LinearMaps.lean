{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.«tacticRel[_]»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">«tacticRel[_]»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The `rel` tactic applies \"generalized congruence\" rules to solve a relational goal by\n\"substitution\".  For example,\n```\nexample {a b x c d : ℝ} (h1 : a ≤ b) (h2 : c ≤ d) :\n    x ^ 2 * a + c ≤ x ^ 2 * b + d := by\n  rel [h1, h2]\n```\nIn this example we \"substitute\" the hypotheses `a ≤ b` and `c ≤ d` into the LHS `x ^ 2 * a + c` of\nthe goal and obtain the RHS `x ^ 2 * b + d`, thus proving the goal.\n\nThe \"generalized congruence\" rules used are the library lemmas which have been tagged with the\nattribute `@[gcongr]`.  For example, the first example constructs the proof term\n```\nadd_le_add (mul_le_mul_of_nonneg_left h1 (pow_bit0_nonneg x 1)) h2\n```\nusing the generalized congruence lemmas `add_le_add` and `mul_le_mul_of_nonneg_left`.  If there are\nno applicable generalized congruence lemmas, the tactic fails.\n\nThe tactic attempts to discharge side goals to these \"generalized congruence\" lemmas (such as the\nside goal `0 ≤ x ^ 2` in the above application of `mul_le_mul_of_nonneg_left`) using the tactic\n`gcongr_discharger`, which wraps `positivity` but can also be extended. If the side goals cannot\nbe discharged in this way, the tactic fails. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.«tacticRel[_]»","kind":"def","line":698,"name":"Mathlib.Tactic.GCongr.«tacticRel[_]»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L698-L720"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.tacticGcongr___With___\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">tacticGcongr___With___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The `gcongr` tactic applies \"generalized congruence\" rules, reducing a relational goal\nbetween an LHS and RHS.  For example,\n```\nexample {a b x c d : ℝ} (h1 : a + 1 ≤ b + 1) (h2 : c + 2 ≤ d + 2) :\n    x ^ 2 * a + c ≤ x ^ 2 * b + d := by\n  gcongr\n  · linarith\n  · linarith\n```\nThis example has the goal of proving the relation `≤` between an LHS and RHS both of the pattern\n```\nx ^ 2 * ?_ + ?_\n```\n(with inputs `a`, `c` on the left and `b`, `d` on the right); after the use of\n`gcongr`, we have the simpler goals `a ≤ b` and `c ≤ d`.\n\nA depth limit or a pattern can be provided explicitly;\nthis is useful if a non-maximal match is desired:\n```\nexample {a b c d x : ℝ} (h : a + c + 1 ≤ b + d + 1) :\n    x ^ 2 * (a + c) + 5 ≤ x ^ 2 * (b + d) + 5 := by\n  gcongr x ^ 2 * ?_ + 5 -- or `gcongr 2`\n  linarith\n```\n\nThe \"generalized congruence\" rules are the library lemmas which have been tagged with the\nattribute `@[gcongr]`.  For example, the first example constructs the proof term\n```\nadd_le_add (mul_le_mul_of_nonneg_left ?_ (Even.pow_nonneg (even_two_mul 1) x)) ?_\n```\nusing the generalized congruence lemmas `add_le_add` and `mul_le_mul_of_nonneg_left`.\n\nThe tactic attempts to discharge side goals to these \"generalized congruence\" lemmas (such as the\nside goal `0 ≤ x ^ 2` in the above application of `mul_le_mul_of_nonneg_left`) using the tactic\n`gcongr_discharger`, which wraps `positivity` but can also be extended. Side goals not discharged\nin this way are left for the user.\n\n`gcongr` will descend into binders (for example sums or suprema). To name the bound variables,\nuse `with`:\n```\nexample {f g : ℕ → ℝ≥0∞} (h : ∀ n, f n ≤ g n) : ⨆ n, f n ≤ ⨆ n, g n := by\n  gcongr with i\n  exact h i\n```\n","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.tacticGcongr___With___","kind":"def","line":620,"name":"Mathlib.Tactic.GCongr.tacticGcongr___With___","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L620-L696"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">gcongr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mdataLhs?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">names</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">depth</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a> := <span class=\"fn\">1000000</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mainGoalDischarger</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span> := <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrForwardDischarger\">Mathlib.Tactic.GCongr.gcongrForwardDischarger</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sideGoalDischarger</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span> := <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrDischarger\">Mathlib.Tactic.GCongr.gcongrDischarger</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span>)</span></div></div>","info":{"doc":"The core of the `gcongr` tactic.  Parse a goal into the form `(f _ ... _) ∼ (f _ ... _)`,\nlook up any relevant `@[gcongr]` lemmas, try to apply them, recursively run the tactic itself on\n\"main\" goals which are generated, and run the discharger on side goals which are generated. If there\nis a user-provided template, first check that the template asks us to descend this far into the\nmatch. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr","kind":"opaque","line":506,"name":"Lean.MVarId.gcongr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L506-L618"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.applyWithArity\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">applyWithArity</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">arity</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Init/Meta/Defs.html#Lean.Meta.ApplyConfig\">Meta.ApplyConfig</a> := <a href=\"./Init/Meta/Defs.html#Lean.Meta.ApplyConfig.mk\">{</a> <a href=\"./Init/Meta/Defs.html#Lean.Meta.ApplyConfig.mk\">}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">term?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Message.html#Lean.MessageData\">MessageData</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>","info":{"doc":"`Lean.MVarId.applyWithArity` is a copy of `Lean.MVarId.apply`, where the arity of the\napplied function is given explicitly instead of being inferred.\n\nTODO: make `Lean.MVarId.apply` take a configuration argument to do this itself\n","docLink":"./Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.applyWithArity","kind":"def","line":470,"name":"Lean.MVarId.applyWithArity","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L470-L504"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.relImpRelLemma\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">relImpRelLemma</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">arity</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a></span></div></div>","info":{"doc":"Construct a `GCongrLemma` for `gcongr` goals of the form `a ≺ b → c ≺ d`.\nThis will be tried if there is no other available `@[gcongr]` lemma.\nFor example, the relation `a ≡ b [ZMOD n]` has an instance of `IsTrans`, so a congruence of the form\n`a ≡ b [ZMOD n] → c ≡ d [ZMOD n]` can be solved with `rel_imp_rel`, `rel_trans` or `rel_trans'`.\n","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.relImpRelLemma","kind":"def","line":454,"name":"Mathlib.Tactic.GCongr.relImpRelLemma","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L454-L466"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.rel_imp_rel\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">rel_imp_rel</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">r</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/Unbundled.html#IsTrans\">IsTrans</a> <span class=\"fn\">α</span> <span class=\"fn\">r</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c </span><span class=\"fn\">d</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\"><span class=\"fn\">r</span> <span class=\"fn\">c</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><span class=\"fn\">r</span> <span class=\"fn\">b</span> <span class=\"fn\">d</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">r</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> → <span class=\"fn\"><span class=\"fn\">r</span> <span class=\"fn\">c</span> <span class=\"fn\">d</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.rel_imp_rel","kind":"theorem","line":451,"name":"Mathlib.Tactic.GCongr.rel_imp_rel","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L451-L452"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.elabCHoleExpand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">elabCHoleExpand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElab\">Lean.Elab.Term.TermElab</a></div></div>","info":{"doc":"(Internal for `gcongr`)\nElaborates to an expression satisfying `hasHoleAnnotation`. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.elabCHoleExpand","kind":"def","line":436,"name":"Mathlib.Tactic.GCongr.elabCHoleExpand","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L436-L440"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrHoleExpand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">gcongrHoleExpand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"(Internal for `gcongr`)\nElaborates to an expression satisfying `hasHoleAnnotation`. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrHoleExpand","kind":"def","line":432,"name":"Mathlib.Tactic.GCongr.gcongrHoleExpand","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L432-L434"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.containsHoleAnnotation\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">containsHoleAnnotation</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Determine whether `e` contains a `gcongrHole` mdata annotation in any subexpression.\nThis tells `gcongr` whether to continue applying `gcongr` lemmas. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.containsHoleAnnotation","kind":"def","line":427,"name":"Mathlib.Tactic.GCongr.containsHoleAnnotation","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L427-L430"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.hasHoleAnnotation\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">hasHoleAnnotation</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Check whether `e` has a `gcongrHole` mdata annotation. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.hasHoleAnnotation","kind":"def","line":423,"name":"Mathlib.Tactic.GCongr.hasHoleAnnotation","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L423-L425"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.mkHoleAnnotation\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">mkHoleAnnotation</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>","info":{"doc":"Annotate `e` with a `gcongrHole` mdata annotation. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.mkHoleAnnotation","kind":"def","line":419,"name":"Mathlib.Tactic.GCongr.mkHoleAnnotation","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L419-L421"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrForwardDischarger\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">gcongrForwardDischarger</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"This is used as the default main-goal discharger,\nconsisting of running `Lean.MVarId.gcongrForward` (trying a term together with limited\nforward-reasoning on that term) on each nontrivial hypothesis.\n","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrForwardDischarger","kind":"def","line":405,"name":"Mathlib.Tactic.GCongr.gcongrForwardDischarger","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L405-L417"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongrForward\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">gcongrForward</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Attempt to resolve an (implicitly) relational goal by one of a provided list of hypotheses,\neither with such a hypothesis directly or by a limited palette of relational forward-reasoning from\nthese hypotheses. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongrForward","kind":"def","line":387,"name":"Lean.MVarId.gcongrForward","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L387-L403"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.exact\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">exact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/GCongr/ForwardAttr.html#Mathlib.Tactic.GCongr.ForwardExt\">ForwardExt</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.exact","kind":"def","line":384,"name":"Mathlib.Tactic.GCongr.exact","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L384-L385"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.symmExact\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">symmExact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/GCongr/ForwardAttr.html#Mathlib.Tactic.GCongr.ForwardExt\">ForwardExt</a></div></div>","info":{"doc":"See if the term is `a ∼ b` with `∼` symmetric and the goal is `b ∼ a`. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.symmExact","kind":"def","line":380,"name":"Mathlib.Tactic.GCongr.symmExact","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L380-L382"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.exactRefl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">exactRefl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/GCongr/ForwardAttr.html#Mathlib.Tactic.GCongr.ForwardExt\">ForwardExt</a></div></div>","info":{"doc":"See if the term is `a = b` and the goal is `a ∼ b` or `b ∼ a`, with `∼` reflexive. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.exactRefl","kind":"def","line":373,"name":"Mathlib.Tactic.GCongr.exactRefl","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L373-L378"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrDischarger\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">gcongrDischarger</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"This is used as the default side-goal discharger,\nit calls the `gcongr_discharger` extensible tactic.\n","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrDischarger","kind":"def","line":361,"name":"Mathlib.Tactic.GCongr.gcongrDischarger","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L361-L369"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.tacticGcongr_discharger\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">tacticGcongr_discharger</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`gcongr_discharger` is used by `gcongr` to discharge side goals.\n\nThis is an extensible tactic using [`macro_rules`](https://lean-lang.org/doc/reference/4.27.0/find/?domain=Verso.Genre.Manual.section&name=tactic-macro-extension).\nBy default it calls `positivity` (after importing the `positivity` tactic).\nExample: ``macro_rules | `(tactic| gcongr_discharger) => `(tactic| positivity)``.\n","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.tacticGcongr_discharger","kind":"def","line":353,"name":"Mathlib.Tactic.GCongr.tacticGcongr_discharger","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L353-L359"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.makeGCongrLemma\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">makeGCongrLemma</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declTy</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numHyps </span><span class=\"fn\">prio</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a></span></div></div>","info":{"doc":"Construct the `GCongrLemma` data from a given lemma. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.makeGCongrLemma","kind":"def","line":237,"name":"Mathlib.Tactic.GCongr.makeGCongrLemma","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L237-L299"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.updateRel\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">updateRel</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r </span><span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">isLhs</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>","info":{"doc":"If `e` is of the form `r a b`, replace either `a` or `b` with `e`. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.updateRel","kind":"def","line":230,"name":"Mathlib.Tactic.GCongr.updateRel","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L230-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.getRel\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">getRel</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"If `e` is of the form `r a b`, return `(r, a, b)`.\nNote: we assume that `e` does not have an `Expr.mdata` annotation. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.getRel","kind":"def","line":218,"name":"Mathlib.Tactic.GCongr.getRel","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L218-L228"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.getCongrAppFnArgs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">getCongrAppFnArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></div></div>","info":{"doc":"Given an application `f a₁ .. aₙ`, return the name of `f`, and the array of arguments `aᵢ`. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.getCongrAppFnArgs","kind":"def","line":206,"name":"Mathlib.Tactic.GCongr.getCongrAppFnArgs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L206-L216"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrExt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">gcongrExt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/ScopedEnvExtension.html#Lean.SimpleScopedEnvExtension\">Lean.SimpleScopedEnvExtension</a> <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a> <span class=\"fn\">(<a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\">GCongrKey</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a>)</span>)</span></span></div></div>","info":{"doc":"Environment extension for \"generalized congruence\" (`gcongr`) lemmas. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrExt","kind":"opaque","line":198,"name":"Mathlib.Tactic.GCongr.gcongrExt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L198-L204"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.addGCongrLemmaEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">addGCongrLemmaEntry</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemmas\">GCongrLemmas</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemmas\">GCongrLemmas</a></div></div>","info":{"doc":"Insert a `GCongrLemma` in a collection of lemmas, making sure that the lemmas are sorted. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.addGCongrLemmaEntry","kind":"def","line":187,"name":"Mathlib.Tactic.GCongr.addGCongrLemmaEntry","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L187-L196"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.prioLE\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrLemma</span>.<span class=\"name\">prioLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Return `true` if the priority of `a` is less than or equal to the priority of `b`. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.prioLE","kind":"def","line":183,"name":"Mathlib.Tactic.GCongr.GCongrLemma.prioLE","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L183-L185"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemmas\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrLemmas</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A collection of `GCongrLemma`, to be stored in the environment extension. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemmas","kind":"def","line":180,"name":"Mathlib.Tactic.GCongr.GCongrLemmas","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L180-L181"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instInhabitedGCongrLemma.default\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">instInhabitedGCongrLemma</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instInhabitedGCongrLemma.default","kind":"def","line":178,"name":"Mathlib.Tactic.GCongr.instInhabitedGCongrLemma.default","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L178-L178"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instInhabitedGCongrLemma\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">instInhabitedGCongrLemma</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instInhabitedGCongrLemma","kind":"instance","line":178,"name":"Mathlib.Tactic.GCongr.instInhabitedGCongrLemma","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L178-L178"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.numVarying\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrLemma</span>.<span class=\"name\">numVarying</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"The number of arguments in the application of `head` that are different.\nThis is used for sorting the lemmas.\nFor example, `a + b ≤ a + c` has `numVarying := 1`. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.numVarying","kind":"def","line":177,"name":"Mathlib.Tactic.GCongr.GCongrLemma.numVarying","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L177-L177"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.prio\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrLemma</span>.<span class=\"name\">prio</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"The given priority of the lemma, for example as `@[gcongr high]`. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.prio","kind":"def","line":173,"name":"Mathlib.Tactic.GCongr.GCongrLemma.prio","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L173-L173"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.numHyps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrLemma</span>.<span class=\"name\">numHyps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"The number of arguments that `declName` takes when applying it. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.numHyps","kind":"def","line":171,"name":"Mathlib.Tactic.GCongr.GCongrLemma.numHyps","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L171-L171"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.mainSubgoals\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrLemma</span>.<span class=\"name\">mainSubgoals</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></div></div>","info":{"doc":"`mainSubgoals` are the subgoals on which `gcongr` will be recursively called. They store\n- the index of the hypothesis\n- the number of parameters in the hypothesis\n- whether it is contravariant (i.e. switches the order of the two arguments) ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.mainSubgoals","kind":"def","line":169,"name":"Mathlib.Tactic.GCongr.GCongrLemma.mainSubgoals","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L169-L169"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.declName\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrLemma</span>.<span class=\"name\">declName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>","info":{"doc":"The name of the lemma. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.declName","kind":"def","line":164,"name":"Mathlib.Tactic.GCongr.GCongrLemma.declName","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L164-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.key\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrLemma</span>.<span class=\"name\">key</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\">GCongrKey</a></div></div>","info":{"doc":"The key under which the lemma is stored. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.key","kind":"def","line":162,"name":"Mathlib.Tactic.GCongr.GCongrLemma.key","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L162-L162"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrLemma</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">key</span> : <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\">GCongrKey</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mainSubgoals</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numHyps </span><span class=\"fn\">prio </span><span class=\"fn\">numVarying</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\">GCongrLemma</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma.mk","kind":"ctor","line":160,"name":"Mathlib.Tactic.GCongr.GCongrLemma.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L160-L160"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrLemma</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Structure recording the data for a \"generalized congruence\" (`gcongr`) lemma. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma","kind":"structure","line":159,"name":"Mathlib.Tactic.GCongr.GCongrLemma","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L159-L178"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instHashableGCongrKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">instHashableGCongrKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\">GCongrKey</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instHashableGCongrKey","kind":"instance","line":157,"name":"Mathlib.Tactic.GCongr.instHashableGCongrKey","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L157-L157"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instHashableGCongrKey.hash\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">instHashableGCongrKey</span>.<span class=\"name\">hash</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\">GCongrKey</a> → <a href=\"./Init/Prelude.html#UInt64\">UInt64</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instHashableGCongrKey.hash","kind":"def","line":157,"name":"Mathlib.Tactic.GCongr.instHashableGCongrKey.hash","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L157-L157"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instBEqGCongrKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">instBEqGCongrKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\">GCongrKey</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instBEqGCongrKey","kind":"instance","line":157,"name":"Mathlib.Tactic.GCongr.instBEqGCongrKey","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L157-L157"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instBEqGCongrKey.beq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">instBEqGCongrKey</span>.<span class=\"name\">beq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\">GCongrKey</a> → <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\">GCongrKey</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instBEqGCongrKey.beq","kind":"def","line":157,"name":"Mathlib.Tactic.GCongr.instBEqGCongrKey.beq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L157-L157"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instInhabitedGCongrKey.default\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">instInhabitedGCongrKey</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\">GCongrKey</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instInhabitedGCongrKey.default","kind":"def","line":157,"name":"Mathlib.Tactic.GCongr.instInhabitedGCongrKey.default","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L157-L157"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instInhabitedGCongrKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">instInhabitedGCongrKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\">GCongrKey</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instInhabitedGCongrKey","kind":"instance","line":157,"name":"Mathlib.Tactic.GCongr.instInhabitedGCongrKey","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L157-L157"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey.arity\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrKey</span>.<span class=\"name\">arity</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\">GCongrKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"The number of arguments that `head` is applied to.\nFor example, `a + b ≤ a + c` has `arity := 6`, because `HAdd.hAdd` has 6 arguments. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey.arity","kind":"def","line":156,"name":"Mathlib.Tactic.GCongr.GCongrKey.arity","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L156-L156"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey.head\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrKey</span>.<span class=\"name\">head</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\">GCongrKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>","info":{"doc":"The name of the head function. For example, `a + b ≤ a + c` has ``head := `HAdd.hAdd``. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey.head","kind":"def","line":153,"name":"Mathlib.Tactic.GCongr.GCongrKey.head","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L153-L153"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey.relName\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrKey</span>.<span class=\"name\">relName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\">GCongrKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>","info":{"doc":"The name of the relation. For example, `a + b ≤ a + c` has ``relName := `LE.le``. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey.relName","kind":"def","line":151,"name":"Mathlib.Tactic.GCongr.GCongrKey.relName","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L151-L151"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrKey</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">relName </span><span class=\"fn\">head</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">arity</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\">GCongrKey</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey.mk","kind":"ctor","line":149,"name":"Mathlib.Tactic.GCongr.GCongrKey.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L149-L149"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GCongr</span>.<span class=\"name\">GCongrKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"`GCongrKey` is the key used in the hashmap for looking up `gcongr` lemmas. ","docLink":"./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrKey","kind":"structure","line":148,"name":"Mathlib.Tactic.GCongr.GCongrKey","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/GCongr/Core.lean#L148-L157"}}],"imports":["Init","Lean","Batteries.Lean.Except","Mathlib.Tactic.GCongr.ForwardAttr","Lean.Meta.Tactic.Apply","Batteries.Tactic.Exact","Mathlib.Order.Defs.Unbundled","Mathlib.Tactic.Core","Mathlib.Tactic.GCongr.ForwardAttr","Mathlib.Tactic.Lemma","Mathlib.Tactic.TypeStar"],"instances":[{"className":"Inhabited","name":"Mathlib.Tactic.GCongr.instInhabitedGCongrKey","typeNames":["Mathlib.Tactic.GCongr.GCongrKey"]},{"className":"BEq","name":"Mathlib.Tactic.GCongr.instBEqGCongrKey","typeNames":["Mathlib.Tactic.GCongr.GCongrKey"]},{"className":"Hashable","name":"Mathlib.Tactic.GCongr.instHashableGCongrKey","typeNames":["Mathlib.Tactic.GCongr.GCongrKey"]},{"className":"Inhabited","name":"Mathlib.Tactic.GCongr.instInhabitedGCongrLemma","typeNames":["Mathlib.Tactic.GCongr.GCongrLemma"]}],"name":"Mathlib.Tactic.GCongr.Core"}