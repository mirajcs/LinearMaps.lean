{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticModule\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">tacticModule</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Given a goal which is an equality in a type `M` (with `M` an `AddCommMonoid`), parse the LHS and\nRHS of the goal as linear combinations of `M`-atoms over some commutative semiring `R`, and prove\nthe goal by checking that the LHS- and RHS-coefficients of each atom are the same up to\nring-normalization in `R`.\n\n(If the proofs of coefficient-wise equality will require more reasoning than just\nring-normalization, use the tactic `match_scalars` instead, and then prove coefficient-wise equality\nby hand.)\n\nExample uses of the `module` tactic:\n```\nexample [AddCommMonoid M] [CommSemiring R] [Module R M] (a b : R) (x : M) :\n    a • x + b • x = (b + a) • x := by\n  module\n\nexample [AddCommMonoid M] [Field K] [CharZero K] [Module K M] (x : M) :\n    (2:K)⁻¹ • x + (3:K)⁻¹ • x + (6:K)⁻¹ • x = x := by\n  module\n\nexample [AddCommGroup M] [CommRing R] [Module R M] (a : R) (v w : M) :\n    (1 + a ^ 2) • (v + w) - a • (a • v - w) = v + (1 + a + a ^ 2) • w := by\n  module\n\nexample [AddCommGroup M] [CommRing R] [Module R M] (a b μ ν : R) (x y : M) :\n    (μ - ν) • a • x = (a • μ • x + b • ν • y) - ν • (a • x + b • y) := by\n  module\n```\n","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticModule","kind":"def","line":626,"name":"Mathlib.Tactic.Module.tacticModule","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L626-L656"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticMatch_scalars\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">tacticMatch_scalars</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Given a goal which is an equality in a type `M` (with `M` an `AddCommMonoid`), parse the LHS and\nRHS of the goal as linear combinations of `M`-atoms over some semiring `R`, and reduce the goal to\nthe respective equalities of the `R`-coefficients of each atom.\n\nFor example, this produces the goal `⊢ a * 1 + b * 1 = (b + a) * 1`:\n```\nexample [AddCommMonoid M] [Semiring R] [Module R M] (a b : R) (x : M) :\n    a • x + b • x = (b + a) • x := by\n  match_scalars\n```\nThis produces the two goals `⊢ a * (a * 1) + b * (b * 1) = 1` (from the `x` atom) and\n`⊢ a * -(b * 1) + b * (a * 1) = 0` (from the `y` atom):\n```\nexample [AddCommGroup M] [Ring R] [Module R M] (a b : R) (x : M) :\n    a • (a • x - b • y) + (b • a • y + b • b • x) = x := by\n  match_scalars\n```\nThis produces the goal `⊢ -2 * (a * 1) = a * (-2 * 1)`:\n```\nexample [AddCommGroup M] [Ring R] [Module R M] (a : R) (x : M) :\n    -(2:R) • a • x = a • (-2:ℤ) • x  := by\n  match_scalars\n```\nThe scalar type for the goals produced by the `match_scalars` tactic is the largest scalar type\nencountered; for example, if `ℕ`, `ℚ` and a characteristic-zero field `K` all occur as scalars, then\nthe goals produced are equalities in `K`.  A variant of `push_cast` is used internally in\n`match_scalars` to interpret scalars from the other types in this largest type.\n\nIf the set of scalar types encountered is not totally ordered (in the sense that for all rings `R`,\n`S` encountered, it holds that either `Algebra R S` or `Algebra S R`), then the `match_scalars`\ntactic fails.\n","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticMatch_scalars","kind":"def","line":592,"name":"Mathlib.Tactic.Module.tacticMatch_scalars","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L592-L624"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.matchScalars\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">matchScalars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>","info":{"doc":"Given a goal which is an equality in a type `M` (with `M` an `AddCommMonoid`), parse the LHS and\nRHS of the goal as linear combinations of `M`-atoms over some semiring `R`, and reduce the goal to\nthe respective equalities of the `R`-coefficients of each atom. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.matchScalars","kind":"def","line":585,"name":"Mathlib.Tactic.Module.matchScalars","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L585-L590"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.postprocess\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">postprocess</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span></div></div>","info":{"doc":"Postprocessing for the scalar goals constructed in the `match_scalars` and `module` tactics.\nThese goals feature a proliferation of `algebraMap` operations (because the scalars start in `ℕ` and\nget successively bumped up by `algebraMap`s as new semirings are encountered), so we reinterpret the\nmost commonly occurring `algebraMap`s (those out of `ℕ`, `ℤ` and `ℚ`) into their standard forms\n(`ℕ`, `ℤ` and `ℚ` casts) and then try to disperse the casts using the various `push_cast` lemmas. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.postprocess","kind":"def","line":567,"name":"Mathlib.Tactic.Module.postprocess","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L567-L583"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.algebraMapThms\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">algebraMapThms</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>","info":{"doc":"Lemmas used to post-process the result of the `match_scalars` and `module` tactics by converting\nthe `algebraMap` operations which (which proliferate in the constructed scalar goals) to more\nfamiliar forms: `ℕ`, `ℤ` and `ℚ` casts. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.algebraMapThms","kind":"def","line":562,"name":"Mathlib.Tactic.Module.algebraMapThms","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L562-L565"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.matchScalarsAux\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">matchScalarsAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>","info":{"doc":"Given a goal which is an equality in a type `M` (with `M` an `AddCommMonoid`), parse the LHS and\nRHS of the goal as linear combinations of `M`-atoms over some semiring `R`, and reduce the goal to\nthe respective equalities of the `R`-coefficients of each atom.\n\nThis is an auxiliary function which produces slightly awkward goals in `R`; they are later cleaned\nup by the function `Mathlib.Tactic.Module.postprocess`. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.matchScalarsAux","kind":"def","line":517,"name":"Mathlib.Tactic.Module.matchScalarsAux","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L517-L560"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.reduceCoefficientwise\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">reduceCoefficientwise</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x✝</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x✝¹</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$R»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iRM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">«$R»</span> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a>\n  (<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a>     <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n    <span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n    <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span></span>)</span></div></div>","info":{"doc":"Given expressions `R` and `M` representing types such that `M`'s is a module over `R`'s, and\ngiven two terms `l₁`, `l₂` of type `qNF R M`, i.e. lists of `(Q($R) × Q($M)) × ℕ`s (two `Expr`s\nand a natural number), construct a list of new goals: that the `R`-coefficient of an `M`-atom which\nappears in only one list is zero, and that the `R`-coefficients of an `M`-atom which appears in both\nlists are equal.  Also construct (dependent on these new goals) a proof that the \"linear\ncombinations\" represented by `l₁` and `l₂` are equal in `M`. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.reduceCoefficientwise","kind":"opaque","line":475,"name":"Mathlib.Tactic.Module.reduceCoefficientwise","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L475-L515"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.parse\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">parse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a>\n  <span class=\"fn\">((<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>) ×\n    <span class=\"fn\">(<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>) ×\n      <span class=\"fn\">(<span class=\"fn\">iR</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$R»</span></span>)</span>) ×\n        <span class=\"fn\">(<span class=\"fn\">x_1</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">«$R»</span> <span class=\"fn\">«$M»</span></span>)</span>) ×\n          <span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>) ×\n            <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n            <span class=\"fn\">Q(<span class=\"fn\">«$x»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span></span></span></span></span>)</span></span></div></div>","info":{"doc":"The main algorithm behind the `match_scalars` and `module` tactics: partially-normalizing an\nexpression in an additive commutative monoid `M` into the form c1 • x1 + c2 • x2 + ... c_k • x_k,\nwhere x1, x2, ... are distinct atoms in `M`, and c1, c2, ... are scalars. The scalar type of the\nexpression is not pre-determined: instead it starts as `ℕ` (when each atom is initially given a\nscalar `(1:ℕ)`) and gets bumped up into bigger semirings when such semirings are encountered.\n\nIt is assumed that there is a \"linear order\" on all the semirings which appear in the expression:\nfor any two semirings `R` and `S` which occur, we have either `Algebra R S` or `Algebra S R`.\n\nTODO: implement a variant in which a semiring `R` is provided by the user, and the assumption is\ninstead that for any semiring `S` which occurs, we have `Algebra S R`. The PR https://github.com/leanprover-community/mathlib4/pull/16984 provides a\nproof-of-concept implementation of this variant, but it would need some polishing before joining\nMathlib.\n\nPossible TODO, if poor performance on large problems is witnessed: switch the implementation from\n`AtomM` to `CanonM`, per the discussion\nhttps://github.com/leanprover-community/mathlib4/pull/16593/files#r1749623191 ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.parse","kind":"opaque","line":397,"name":"Mathlib.Tactic.Module.parse","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L397-L473"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.matchRings\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span>.<span class=\"name\">matchRings</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u₁</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₁</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u₁)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iR₁</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$R₁»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iRM₁</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">«$R₁»</span> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u₂</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₂</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u₂)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iR₂</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$R₂»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iRM₂</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">«$R₂»</span> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₁</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\">Q(<span class=\"fn\">«$R₂»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a>\n  <span class=\"fn\">((<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>) ×\n    <span class=\"fn\">(<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>) ×\n      <span class=\"fn\">(<span class=\"fn\">iR</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$R»</span></span>)</span>) ×\n        <span class=\"fn\">(<span class=\"fn\">x_1</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">«$R»</span> <span class=\"fn\">«$M»</span></span>)</span>) ×\n          <span class=\"fn\">((<span class=\"fn\">l₁'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>) ×\n              <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n              <span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n              <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a>             <span class=\"fn\">((<span class=\"fn\">l₂'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>) ×\n                <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n                <span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n                <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a>               <span class=\"fn\">(<span class=\"fn\">r'</span> : <span class=\"fn\">Q(<span class=\"fn\">«$R»</span>)</span>) × <span class=\"fn\">Q(<span class=\"fn\">«$r'»</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">«$x»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$r»</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">«$x»</span>)</span></span></span></span></span>)</span></span></div></div>","info":{"doc":"Given an expression `M` representing a type which is an `AddCommMonoid` and a module over *two*\nsemirings `R₁` and `R₂`, find the \"bigger\" of the two semirings.  That is, we assume that it will\nturn out to be the case that either (1) `R₁` is an `R₂`-algebra and the `R₂` scalar action on `M` is\ninduced from `R₁`'s scalar action on `M`, or (2) vice versa; we return the semiring `R₁` in the\nfirst case and `R₂` in the second case.\n\nMoreover, given expressions representing particular scalar multiplications of `R₁` and/or `R₂` on\n`M` (a `List (R₁ × M)`, a `List (R₂ × M)`, a pair `(r, x) : R₂ × M`), bump these up to the \"big\"\nring by applying the algebra-map where needed. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.matchRings","kind":"def","line":350,"name":"Mathlib.Tactic.Module.qNF.matchRings","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L350-L389"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkSubProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span>.<span class=\"name\">mkSubProof</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iR</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$R»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iRM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">«$R»</span> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.sub\">sub</a> <span class=\"fn\">iR</span> <span class=\"fn\">l₁</span> <span class=\"fn\">l₂</span>)</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">have <span class=\"fn\">a_2</span> := <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_2»</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span></span></span></div></div>","info":{"doc":"Given two terms `l₁`, `l₂` of type `qNF R M`, i.e. lists of `(Q($R) × Q($M)) × ℕ`s (two `Expr`s\nand a natural number), recursively construct a proof that in the `$R`-module `$M`, the difference\nof the \"linear combinations\" represented by `l₁` and `l₂` is the linear combination represented by\n`Module.qNF.sub iR l₁ l₁`. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkSubProof","kind":"def","line":325,"name":"Mathlib.Tactic.Module.qNF.mkSubProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L325-L344"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.sub\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span>.<span class=\"name\">sub</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iR</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$R»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span></span></div></div>","info":{"doc":"Given two terms `l₁`, `l₂` of type `qNF R M`, i.e. lists of `(Q($R) × Q($M)) × ℕ`s (two `Expr`s\nand a natural number), construct another such term `l`, which will have the property that in the\n`$R`-module `$M`, the difference of the \"linear combinations\" represented by `l₁` and `l₂` is the\nlinear combination represented by `l`.\n\nThe construction assumes, to be valid, that the lists `l₁` and `l₂` are in strictly increasing order\nby `ℕ`-component, and that if pairs `(a₁, x₁)` and `(a₂, x₂)` appear in `l₁`, `l₂` respectively with\nthe same `ℕ`-component `k`, then the expressions `x₁` and `x₂` are equal.\n\nThe construction is as follows: merge the first list and the negation of the second list, except\nthat if pairs `(a₁, x₁)` and `(a₂, x₂)` appear in `l₁`, `l₂` respectively with the same\n`ℕ`-component `k`, then contribute a term `(a₁ - a₂, x₁)` to the output list with `ℕ`-component `k`.\n","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.sub","kind":"def","line":301,"name":"Mathlib.Tactic.Module.qNF.sub","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L301-L323"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkAddProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span>.<span class=\"name\">mkAddProof</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iR</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$R»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iRM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">«$R»</span> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.add\">add</a> <span class=\"fn\">iR</span> <span class=\"fn\">l₁</span> <span class=\"fn\">l₂</span>)</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">have <span class=\"fn\">a_2</span> := <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_2»</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span></span></span></div></div>","info":{"doc":"Given two terms `l₁`, `l₂` of type `qNF R M`, i.e. lists of `(Q($R) × Q($M)) × ℕ`s (two `Expr`s\nand a natural number), recursively construct a proof that in the `$R`-module `$M`, the sum of the\n\"linear combinations\" represented by `l₁` and `l₂` is the linear combination represented by\n`Module.qNF.add iR l₁ l₁`. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkAddProof","kind":"def","line":280,"name":"Mathlib.Tactic.Module.qNF.mkAddProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L280-L299"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span>.<span class=\"name\">add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iR</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$R»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span></span></div></div>","info":{"doc":"Given two terms `l₁`, `l₂` of type `qNF R M`, i.e. lists of `(Q($R) × Q($M)) × ℕ`s (two `Expr`s\nand a natural number), construct another such term `l`, which will have the property that in the\n`$R`-module `$M`, the sum of the \"linear combinations\" represented by `l₁` and `l₂` is the linear\ncombination represented by `l`.\n\nThe construction assumes, to be valid, that the lists `l₁` and `l₂` are in strictly increasing order\nby `ℕ`-component, and that if pairs `(a₁, x₁)` and `(a₂, x₂)` appear in `l₁`, `l₂` respectively with\nthe same `ℕ`-component `k`, then the expressions `x₁` and `x₂` are equal.\n\nThe construction is as follows: merge the two lists, except that if pairs `(a₁, x₁)` and `(a₂, x₂)`\nappear in `l₁`, `l₂` respectively with the same `ℕ`-component `k`, then contribute a term\n`(a₁ + a₂, x₁)` to the output list with `ℕ`-component `k`. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.add","kind":"def","line":257,"name":"Mathlib.Tactic.Module.qNF.add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L257-L278"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.onScalar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span>.<span class=\"name\">onScalar</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u₁ </span><span class=\"fn\">u₂</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₁</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u₁)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₂</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u₂)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$R₁»</span> → <span class=\"fn\">«$R₂»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span></div></div>","info":{"doc":"Given `l` of type `qNF R₁ M`, i.e. a list of `(Q($R₁) × Q($M)) × ℕ`s (two `Expr`s and a natural\nnumber), apply an expression representing a function with domain `R₁` to each of the `Q($R₁)`\ncomponents. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.onScalar","kind":"def","line":250,"name":"Mathlib.Tactic.Module.qNF.onScalar","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L250-L255"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span>.<span class=\"name\">toNF</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">«$R»</span> <span class=\"fn\">«$M»</span></span>)</span></div></div>","info":{"doc":"Given `l` of type `qNF R M`, i.e. a list of `(Q($R) × Q($M)) × ℕ`s (two `Expr`s and a natural\nnumber), build an `Expr` representing an object of type `NF R M` (i.e. `List (R × M)`) in the\nin the obvious way: by forgetting the natural numbers and gluing together the `Expr`s. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF","kind":"def","line":242,"name":"Mathlib.Tactic.Module.qNF.toNF","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L242-L248"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Basic meta-code \"normal form\" object of the `match_scalars` and `module` tactics: a type synonym\nfor a list of ordered triples comprising expressions representing terms of two types `R` and `M`\n(where typically `M` is an `R`-module), together with a natural number \"index\".\n\nThe natural number represents the index of the `M` term in the `AtomM` monad: this is not enforced,\nbut is sometimes assumed in operations.  Thus when items `((a₁, x₁), k)` and `((a₂, x₂), k)`\nappear in two different `Module.qNF` objects (i.e. with the same `ℕ`-index `k`), it is expected that\nthe expressions `x₁` and `x₂` are the same.  It is also expected that the items in a `Module.qNF`\nlist are in strictly increasing order by natural-number index.\n\nBy forgetting the natural number indices, an expression representing a `Mathlib.Tactic.Module.NF`\nobject can be built from a `Module.qNF` object; this construction is provided as\n`Mathlib.Tactic.Module.qNF.toNF`. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF","kind":"def","line":223,"name":"Mathlib.Tactic.Module.qNF","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L223-L236"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_algebraMap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eval_algebraMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">S</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">S</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Algebra/Defs.html#Algebra\">Algebra</a> <span class=\"fn\">S</span> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#SMul\">SMul</a> <span class=\"fn\">S</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Action/Defs.html#MulAction\">MulAction</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Action/Defs.html#IsScalarTower\">IsScalarTower</a> <span class=\"fn\">S</span> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">S</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.algebraMap\">algebraMap</a> <span class=\"fn\">R</span> <span class=\"fn\">l</span>)</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_algebraMap","kind":"theorem","line":207,"name":"Mathlib.Tactic.Module.NF.eval_algebraMap","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L207-L213"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.algebraMap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">algebraMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">S</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">S</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Algebra/Defs.html#Algebra\">Algebra</a> <span class=\"fn\">S</span> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">S</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span></div></div>","info":{"doc":"Operate on a `Module.NF S M` object `l`, i.e. a list of pairs in `S × M`, where `S` is some\ncommutative semiring, by applying to each `S`-component the algebra-map from `S` into a specified\n`S`-algebra `R`. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.algebraMap","kind":"def","line":201,"name":"Mathlib.Tactic.Module.NF.algebraMap","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L201-L205"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_of_eval_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eq_of_eval_eq_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₁</span> : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₂</span> : <a href=\"./foundational_types.html\">Type</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R₁</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R₂</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₂'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x₁ </span><span class=\"fn\">x₂</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx₁</span> : <span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx₂</span> : <span class=\"fn\">x₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x₂</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_of_eval_eq_eval","kind":"theorem","line":192,"name":"Mathlib.Tactic.Module.NF.eq_of_eval_eq_eval","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L192-L197"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_const_cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eq_const_cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">r</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h1</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">r</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h2</span> : <span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">m</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_const_cons","kind":"theorem","line":187,"name":"Mathlib.Tactic.Module.NF.eq_const_cons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L187-L190"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_cons_const\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eq_cons_const</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">r</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h1</span> : <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h2</span> : <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">m</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_cons_const","kind":"theorem","line":182,"name":"Mathlib.Tactic.Module.NF.eq_cons_const","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L182-L185"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_cons_cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eq_cons_cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#SMul\">SMul</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">r₁ </span><span class=\"fn\">r₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h1</span> : <span class=\"fn\">r₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">r₂</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h2</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₁</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">m</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₂</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">m</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_cons_cons","kind":"theorem","line":177,"name":"Mathlib.Tactic.Module.NF.eq_cons_cons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L177-L180"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.smul_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">smul_eq_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">S</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₀</span> : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R₀</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R₀</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">S</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">S</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₀</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R₀</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\">S</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">r</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₀</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hl</span> : <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₀</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hs</span> : <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">s</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">s</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.smul_eq_eval","kind":"theorem","line":170,"name":"Mathlib.Tactic.Module.NF.smul_eq_eval","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L170-L175"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eval_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_smul","kind":"theorem","line":162,"name":"Mathlib.Tactic.Module.NF.eval_smul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L162-L168"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.smul_apply\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">smul_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Mul\">Mul</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Init/Prelude.html#List.map\">List.map</a>\n    <span class=\"fn\">(fun (<span class=\"fn\">x</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>) =&gt;\n      <span class=\"fn\">match <span class=\"fn\">x</span> with\n      | <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">a</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> =&gt; <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a></span>)</span>\n    <span class=\"fn\">l</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.smul_apply","kind":"theorem","line":159,"name":"Mathlib.Tactic.Module.NF.smul_apply","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L159-L160"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.instSMulOfMul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">instSMulOfMul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Mul\">Mul</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#SMul\">SMul</a> <span class=\"fn\">R</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.instSMulOfMul","kind":"instance","line":156,"name":"Mathlib.Tactic.Module.NF.instSMulOfMul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L156-L157"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.neg_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">neg_eq_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">S</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">S</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">S</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₀</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">S</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hl</span> : <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₀</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₀</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.neg_eq_eval","kind":"theorem","line":151,"name":"Mathlib.Tactic.Module.NF.neg_eq_eval","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L151-L154"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.zero_sub_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">zero_sub_eq_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.zero_sub_eq_eval","kind":"theorem","line":147,"name":"Mathlib.Tactic.Module.NF.zero_sub_eq_eval","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L147-L149"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eval_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_neg","kind":"theorem","line":141,"name":"Mathlib.Tactic.Module.NF.eval_neg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L141-L145"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.instNeg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">instNeg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Neg\">Neg</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg\">Neg</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.instNeg","kind":"instance","line":138,"name":"Mathlib.Tactic.Module.NF.instNeg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L138-L139"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">sub_eq_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₁</span> : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₂</span> : <a href=\"./foundational_types.html\">Type</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">S₁</span> : <a href=\"./foundational_types.html\">Type</a> u_6}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">S₂</span> : <a href=\"./foundational_types.html\">Type</a> u_7}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R₁</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R₂</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">S₁</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">S₁</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">S₂</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">S₂</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₂'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁''</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">S₁</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₂''</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">S₂</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x₁ </span><span class=\"fn\">x₂</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx₁</span> : <span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₁''</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx₂</span> : <span class=\"fn\">x₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂''</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁'</span> : <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₁''</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂'</span> : <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂''</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">x₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval","kind":"theorem","line":129,"name":"Mathlib.Tactic.Module.NF.sub_eq_eval","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L129-L136"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₃\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">sub_eq_eval₃</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">(<span class=\"fn\">a₂</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\"><span class=\"fn\">a₂</span>.1</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\"><span class=\"fn\">a₂</span>.2</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₃","kind":"theorem","line":122,"name":"Mathlib.Tactic.Module.NF.sub_eq_eval₃","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L122-L127"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₂\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">sub_eq_eval₂</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r₁ </span><span class=\"fn\">r₂</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₁</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₂</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₁</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">r₂</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₂","kind":"theorem","line":113,"name":"Mathlib.Tactic.Module.NF.sub_eq_eval₂","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L113-L120"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₁\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">sub_eq_eval₁</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#SMul\">SMul</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddGroup\">AddGroup</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₂</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">(<span class=\"fn\">a₂</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">(<span class=\"fn\">a₂</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₁","kind":"theorem","line":108,"name":"Mathlib.Tactic.Module.NF.sub_eq_eval₁","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L108-L111"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">add_eq_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₁</span> : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₂</span> : <a href=\"./foundational_types.html\">Type</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R₁</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R₂</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₂'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x₁ </span><span class=\"fn\">x₂</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx₁</span> : <span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx₂</span> : <span class=\"fn\">x₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">x₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval","kind":"theorem","line":101,"name":"Mathlib.Tactic.Module.NF.add_eq_eval","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L101-L106"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₃\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">add_eq_eval₃</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">(<span class=\"fn\">a₂</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\">a₂</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₃","kind":"theorem","line":92,"name":"Mathlib.Tactic.Module.NF.add_eq_eval₃","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L92-L99"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₂\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">add_eq_eval₂</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r₁ </span><span class=\"fn\">r₂</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₁</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₂</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">r₂</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₂","kind":"theorem","line":83,"name":"Mathlib.Tactic.Module.NF.add_eq_eval₂","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L83-L90"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₁\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">add_eq_eval₁</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#SMul\">SMul</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₂</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">(<span class=\"fn\">a₂</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">(<span class=\"fn\">a₂</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₁","kind":"theorem","line":78,"name":"Mathlib.Tactic.Module.NF.add_eq_eval₁","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L78-L81"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.zero_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">zero_eq_eval</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a> <a href=\"./Init/Prelude.html#List.nil\">[</a><a href=\"./Init/Prelude.html#List.nil\">]</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.zero_eq_eval","kind":"theorem","line":76,"name":"Mathlib.Tactic.Module.NF.zero_eq_eval","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L76-L76"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.atom_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">atom_eq_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">M</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a> <a href=\"./Init/Prelude.html#List.cons\">[</a><a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">1</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a><a href=\"./Init/Prelude.html#List.cons\">]</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.atom_eq_eval","kind":"theorem","line":73,"name":"Mathlib.Tactic.Module.NF.atom_eq_eval","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L73-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eval_cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#SMul\">SMul</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">p</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">p</span>.1</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\"><span class=\"fn\">p</span>.2</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_cons","kind":"theorem","line":69,"name":"Mathlib.Tactic.Module.NF.eval_cons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L69-L71"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Add\">Add</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Zero\">Zero</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#SMul\">SMul</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">M</span></div></div>","info":{"doc":"Evaluate a `Module.NF R M` object `l`, i.e. a list of pairs in `R × M`, to an element of `M`, by\nforming the \"linear combination\" it specifies: scalar-multiply each `R` term to the corresponding\n`M` term, then add them all up. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval","kind":"def","line":64,"name":"Mathlib.Tactic.Module.NF.eval","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L64-L67"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.«term_::ᵣ_»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">«term_::ᵣ_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>","info":{"doc":"Augment a `Module.NF R M` object `l`, i.e. a list of pairs in `R × M`, by prepending another\npair `p : R × M`. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.«term_::ᵣ_»","kind":"def","line":62,"name":"Mathlib.Tactic.Module.NF.«term_::ᵣ_»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L62-L62"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span></div></div>","info":{"doc":"Augment a `Module.NF R M` object `l`, i.e. a list of pairs in `R × M`, by prepending another\npair `p : R × M`. ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons","kind":"def","line":57,"name":"Mathlib.Tactic.Module.NF.cons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L57-L60"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_2)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max u_2 u_1)</div></div>","info":{"doc":"Basic theoretical \"normal form\" object of the `match_scalars` and `module` tactics: a type\nsynonym for a list of ordered pairs in `R × M`, where typically `M` is an `R`-module.  This is the\nform to which the tactics reduce module expressions.\n\n(It is not a full \"normal form\" because the scalars, i.e. `R` components, are not themselves\nring-normalized. But this partial normal form is more convenient for our purposes.) ","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF","kind":"def","line":46,"name":"Mathlib.Tactic.Module.NF","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Module.lean#L46-L52"}}],"imports":["Init","Mathlib.Algebra.Algebra.Tower","Mathlib.Algebra.BigOperators.GroupWithZero.Action","Mathlib.Tactic.Ring","Mathlib.Util.AtomM","Mathlib.Algebra.Algebra.Defs"],"instances":[{"className":"Neg","name":"Mathlib.Tactic.Module.NF.instNeg","typeNames":["Mathlib.Tactic.Module.NF"]},{"className":"SMul","name":"Mathlib.Tactic.Module.NF.instSMulOfMul","typeNames":["Mathlib.Tactic.Module.NF"]}],"name":"Mathlib.Tactic.Module"}