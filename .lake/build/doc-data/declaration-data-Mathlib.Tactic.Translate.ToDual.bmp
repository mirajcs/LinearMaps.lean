{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.data\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToDual</span>.<span class=\"name\">data</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Translate/Core.html#Mathlib.Tactic.Translate.TranslateData\">Translate.TranslateData</a></div></div>","info":{"doc":"The bundle of environment extensions for `to_dual` ","docLink":"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.data","kind":"def","line":211,"name":"Mathlib.Tactic.ToDual.data","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToDual.lean#L211-L217"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.abbreviationDict\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToDual</span>.<span class=\"name\">abbreviationDict</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#String\">String</a> <a href=\"./Init/Prelude.html#String\">String</a></span></div></div>","info":{"doc":"We need to fix a few abbreviations after applying `nameDict`, i.e. replacing `ZeroLE` by `Nonneg`.\nThis dictionary contains these fixes.\nThe input should contain entries that is in `lowerCamelCase` (e.g. `ltzero`; the initial sequence\nof capital letters should be lower-cased) and the output should be in `UpperCamelCase`\n(e.g. `LTZero`).\nWhen applying the dictionary, we lower-case the output if the input was also given in lower-case.\n","docLink":"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.abbreviationDict","kind":"def","line":203,"name":"Mathlib.Tactic.ToDual.abbreviationDict","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToDual.lean#L203-L209"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.nameDict\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToDual</span>.<span class=\"name\">nameDict</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#String\">String</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a>)</span></span></div></div>","info":{"doc":"Dictionary used by `guessName` to autogenerate names.\nThis only transforms single name components, unlike `abbreviationDict`.\n\nNote: `guessName` capitalizes the output according to the capitalization of the input.\nIn order for this to work, the input should always start with a lower case letter, and the output\nshould always start with an upper case letter.\n","docLink":"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.nameDict","kind":"def","line":132,"name":"Mathlib.Tactic.ToDual.nameDict","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToDual.lean#L132-L201"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.translations\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToDual</span>.<span class=\"name\">translations</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>","info":{"doc":"Maps names to their dual counterparts. ","docLink":"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.translations","kind":"opaque","line":129,"name":"Mathlib.Tactic.ToDual.translations","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToDual.lean#L129-L130"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.doTranslateAttr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToDual</span>.<span class=\"name\">doTranslateAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"The global `do_translate`/`dont_translate` attributes specify whether operations on\na given type should be translated. `dont_translate` can be used for types that are translated,\nsuch as `MonoidAlgebra` -> `AddMonoidAlgebra`, or for fixed types, such as `Fin n`/`ZMod n`.\n`do_translate` is for types without arguments, like `Unit` and `Empty`, where the structure on it\ncan be translated.\n\nNote: The name generation is not aware of `dont_translate`, so if some part of a lemma is not\n  translated thanks to this, you generally have to specify the translated name manually.\n","docLink":"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.doTranslateAttr","kind":"opaque","line":114,"name":"Mathlib.Tactic.ToDual.doTranslateAttr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToDual.lean#L114-L115"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.argInfoAttr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToDual</span>.<span class=\"name\">argInfoAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <a href=\"./Mathlib/Tactic/Translate/Core.html#Mathlib.Tactic.Translate.ArgInfo\">Translate.ArgInfo</a></span></div></div>","info":{"doc":"`argInfoAttr` stores the declarations that need some extra information to be translated. ","docLink":"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.argInfoAttr","kind":"opaque","line":111,"name":"Mathlib.Tactic.ToDual.argInfoAttr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToDual.lean#L111-L112"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.ignoreArgsAttr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToDual</span>.<span class=\"name\">ignoreArgsAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span></div></div>","info":{"doc":"An attribute that tells that certain arguments of this definition are not\ninvolved when translating.\nThis helps the translation heuristic by also transforming definitions if `ℕ` or another\nfixed type occurs as one of these arguments. ","docLink":"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.ignoreArgsAttr","kind":"opaque","line":99,"name":"Mathlib.Tactic.ToDual.ignoreArgsAttr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToDual.lean#L99-L109"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.attrTo_dual?_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToDual</span>.<span class=\"name\">attrTo_dual?_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The attribute `to_dual` can be used to automatically transport theorems\nand definitions (but not inductive types and structures) to their dual version.\nIt uses the same implementation as `to_additive`.\n\nTo use this attribute, just write:\n\n```\n@[to_dual]\ntheorem max_comm' {α} [LinearOrder α] (x y : α) : max x y = max y x := max_comm x y\n```\n\nThis code will generate a theorem named `min_comm'`. It is also\npossible to manually specify the name of the new declaration:\n\n```\n@[to_dual le_max_left]\nlemma min_le_left (a b : α) : min a b ≤ a := sorry\n```\n\nAn existing documentation string will _not_ be automatically used, so if the theorem or definition\nhas a doc string, a doc string for the dual version should be passed explicitly to `to_dual`.\n\n```\n/-- The maximum is commutative. -/\n@[to_dual /-- The minimum is commutative. -/]\ntheorem max_comm' {α} [LinearOrder α] (x y : α) : max x y = max y x := max_comm x y\n```\n\nUse the `(reorder := ...)` syntax to reorder the arguments compared to the dual declaration.\nThis is specified using cycle notation. For example `(reorder := α β, 5 6)` swaps the arguments\n`α` and `β` with each other and the fifth and the sixth argument and `(reorder := 3 4 5)` will move\nthe fifth argument before the third argument. For example, this is used when tagging `LE.le`\nwith `to_dual self (reorder := 3 4)`, so that `a ≤ b` gets transformed into `b ≤ a`.\n\nUse the `to_dual self` syntax to mark the lemma as its own dual. This is needed if the lemma is\nits own dual, up to a reordering of its arguments. `to_dual self` (and `to_dual existing`) tries to\nautogenerate the `(reorder := ...)` argument, so it is usually not necessary to give it explicitly.\n\nUse the `to_dual existing` syntax to use an existing dual declaration,\ninstead of automatically generating it.\n\nUse the `(attr := ...)` syntax to apply attributes to both the original and the dual version:\n```\n@[to_dual (attr := simp)] lemma min_self (a : α) : min a a = a := sorry\n```\n\nThe `reassoc` attribute in category theory interacts with `to_dual` in a unique way, because it\ngenerates `_assoc` theorems that aren't dual to any other theorem. To deal with this, the `reassoc`\nattribute will add a `to_dual none` tag to an `_assoc` theorem if the original theorem was\nalready tagged with `to_dual`. This also works with `to_dual (attr := reassoc)`.\n\nWhen troubleshooting, you can see what `to_dual` is doing by replacing it with `to_dual?` and/or\nby using `set_option trace.translate_detail true`.\n ","docLink":"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.attrTo_dual?_","kind":"def","line":97,"name":"Mathlib.Tactic.ToDual.attrTo_dual?_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToDual.lean#L97-L97"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToDual</span>.<span class=\"name\">to_dual</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The attribute `to_dual` can be used to automatically transport theorems\nand definitions (but not inductive types and structures) to their dual version.\nIt uses the same implementation as `to_additive`.\n\nTo use this attribute, just write:\n\n```\n@[to_dual]\ntheorem max_comm' {α} [LinearOrder α] (x y : α) : max x y = max y x := max_comm x y\n```\n\nThis code will generate a theorem named `min_comm'`. It is also\npossible to manually specify the name of the new declaration:\n\n```\n@[to_dual le_max_left]\nlemma min_le_left (a b : α) : min a b ≤ a := sorry\n```\n\nAn existing documentation string will _not_ be automatically used, so if the theorem or definition\nhas a doc string, a doc string for the dual version should be passed explicitly to `to_dual`.\n\n```\n/-- The maximum is commutative. -/\n@[to_dual /-- The minimum is commutative. -/]\ntheorem max_comm' {α} [LinearOrder α] (x y : α) : max x y = max y x := max_comm x y\n```\n\nUse the `(reorder := ...)` syntax to reorder the arguments compared to the dual declaration.\nThis is specified using cycle notation. For example `(reorder := α β, 5 6)` swaps the arguments\n`α` and `β` with each other and the fifth and the sixth argument and `(reorder := 3 4 5)` will move\nthe fifth argument before the third argument. For example, this is used when tagging `LE.le`\nwith `to_dual self (reorder := 3 4)`, so that `a ≤ b` gets transformed into `b ≤ a`.\n\nUse the `to_dual self` syntax to mark the lemma as its own dual. This is needed if the lemma is\nits own dual, up to a reordering of its arguments. `to_dual self` (and `to_dual existing`) tries to\nautogenerate the `(reorder := ...)` argument, so it is usually not necessary to give it explicitly.\n\nUse the `to_dual existing` syntax to use an existing dual declaration,\ninstead of automatically generating it.\n\nUse the `(attr := ...)` syntax to apply attributes to both the original and the dual version:\n```\n@[to_dual (attr := simp)] lemma min_self (a : α) : min a a = a := sorry\n```\n\nThe `reassoc` attribute in category theory interacts with `to_dual` in a unique way, because it\ngenerates `_assoc` theorems that aren't dual to any other theorem. To deal with this, the `reassoc`\nattribute will add a `to_dual none` tag to an `_assoc` theorem if the original theorem was\nalready tagged with `to_dual`. This also works with `to_dual (attr := reassoc)`.\n\nWhen troubleshooting, you can see what `to_dual` is doing by replacing it with `to_dual?` and/or\nby using `set_option trace.translate_detail true`.\n ","docLink":"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual","kind":"def","line":40,"name":"Mathlib.Tactic.ToDual.to_dual","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToDual.lean#L40-L94"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual_dont_translate\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToDual</span>.<span class=\"name\">to_dual_dont_translate</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The global `do_translate`/`dont_translate` attributes specify whether operations on\na given type should be translated. `dont_translate` can be used for types that are translated,\nsuch as `MonoidAlgebra` -> `AddMonoidAlgebra`, or for fixed types, such as `Fin n`/`ZMod n`.\n`do_translate` is for types without arguments, like `Unit` and `Empty`, where the structure on it\ncan be translated.\n\nNote: The name generation is not aware of `dont_translate`, so if some part of a lemma is not\n  translated thanks to this, you generally have to specify the translated name manually.\n","docLink":"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual_dont_translate","kind":"def","line":37,"name":"Mathlib.Tactic.ToDual.to_dual_dont_translate","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToDual.lean#L37-L38"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual_do_translate\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToDual</span>.<span class=\"name\">to_dual_do_translate</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The global `do_translate`/`dont_translate` attributes specify whether operations on\na given type should be translated. `dont_translate` can be used for types that are translated,\nsuch as `MonoidAlgebra` -> `AddMonoidAlgebra`, or for fixed types, such as `Fin n`/`ZMod n`.\n`do_translate` is for types without arguments, like `Unit` and `Empty`, where the structure on it\ncan be translated.\n\nNote: The name generation is not aware of `dont_translate`, so if some part of a lemma is not\n  translated thanks to this, you generally have to specify the translated name manually.\n","docLink":"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual_do_translate","kind":"def","line":34,"name":"Mathlib.Tactic.ToDual.to_dual_do_translate","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToDual.lean#L34-L35"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual_ignore_args\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ToDual</span>.<span class=\"name\">to_dual_ignore_args</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"An attribute that tells that certain arguments of this definition are not\ninvolved when translating.\nThis helps the translation heuristic by also transforming definitions if `ℕ` or another\nfixed type occurs as one of these arguments. ","docLink":"./Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual_ignore_args","kind":"def","line":31,"name":"Mathlib.Tactic.ToDual.to_dual_ignore_args","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Translate/ToDual.lean#L31-L32"}}],"imports":["Init","Mathlib.Tactic.Translate.Core"],"instances":[],"name":"Mathlib.Tactic.Translate.ToDual"}